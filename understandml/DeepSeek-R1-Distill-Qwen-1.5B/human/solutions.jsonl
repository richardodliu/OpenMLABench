{"task_id": 1, "completion_id": 0, "solution": "def matrix_dot_vector(a: list[list[int | float]], b: list[int | float]) -> list[int | float]:\n    if not a:\n        return -1\n    if not b:\n        return -1\n    cols = len(a[0])\n    len_b = len(b)\n    if cols != len_b:\n        return -1\n    result = []\n    for row in a:\n        dot = 0\n        for i in range(len_b):\n            dot += row[i] * b[i]\n        result.append(dot)\n    return result"}
{"task_id": 2, "completion_id": 0, "solution": "def transpose_matrix(a: list[list[int | float]]) -> list[list[int | float]]:\n    if not a:\n        return []\n    rows = len(a)\n    cols = len(a[0])\n    transposed = []\n    for j in range(cols):\n        new_row = [a[i][j] for i in range(rows)]\n        transposed.append(new_row)\n    return transposed"}
{"task_id": 3, "completion_id": 0, "solution": "import numpy as np\ndef reshape_matrix(a: list[list[int | float]], new_shape: tuple[int, int]) -> list[list[int | float]]:\n    a_np = np.array(a)\n    if not isinstance(new_shape, tuple) or len(new_shape) != 2 or (not all((isinstance(x, int) for x in new_shape))):\n        return []\n    current_shape = a_np.shape\n    if current_shape[0] * current_shape[1] != new_shape[0] * new_shape[1]:\n        return []\n    reshaped = a_np.reshape(new_shape)\n    return reshaped.tolist()"}
{"task_id": 4, "completion_id": 0, "solution": ""}
{"task_id": 5, "completion_id": 0, "solution": "def scalar_multiply(matrix: list[list[int | float]], scalar: int | float) -> list[list[int | float]]:\n    return [[element * scalar for element in row] for row in matrix]"}
{"task_id": 6, "completion_id": 0, "solution": "import math\ndef calculate_eigenvalues(matrix: list[list[float | int]]) -> list[float]:\n    a = matrix[0][0]\n    b = matrix[0][1]\n    c = matrix[1][0]\n    d = matrix[1][1]\n    trace = a + d\n    det = a * d - b * c\n    discriminant = trace ** 2 - 4 * det\n    sqrt_discriminant = math.sqrt(discriminant)\n    eigenvalues = [(trace + sqrt_discriminant) / 2, (trace - sqrt_discriminant) / 2]\n    eigenvalues.sort()\n    eigenvalues = eigenvalues[::-1]\n    return eigenvalues"}
{"task_id": 7, "completion_id": 0, "solution": "import numpy as np\ndef transform_matrix(A: list[list[int | float]], T: list[list[int | float]], S: list[list[int | float]]) -> list[list[int | float]]:\n    if len(T) != len(T[0]) or len(T) == 0:\n        return -1\n    if len(S) != len(S[0]) or len(S) == 0:\n        return -1\n    try:\n        T_inv = np.linalg.inv(T)\n    except np.linalg.LinAlgError:\n        return -1\n    try:\n        S_inv = np.linalg.inv(S)\n    except np.linalg.LinAlgError:\n        return -1\n    AT = np.dot(T_inv, A)\n    result = np.dot(AT, S)\n    rounded = np.round(result, 4)\n    return rounded.tolist()"}
{"task_id": 8, "completion_id": 0, "solution": "def inverse_2x2(matrix: list[list[float]]) -> list[list[float]]:\n    (a, b, c, d) = (matrix[0][0], matrix[0][1], matrix[1][0], matrix[1][1])\n    determinant = a * d - b * c\n    if determinant == 0:\n        return None\n    inv_a = d / determinant\n    inv_b = -b / determinant\n    inv_c = -c / determinant\n    inv_d = a / determinant\n    return [[inv_a, inv_b], [inv_c, inv_d]]"}
{"task_id": 9, "completion_id": 0, "solution": "def matrixmul(a: list[list[int | float]], b: list[list[int | float]]) -> list[list[int | float]]:\n    if len(a) == 0 or len(b) == 0:\n        return -1\n    if len(a[0]) != len(b):\n        return -1\n    m = len(a)\n    n = len(a[0])\n    p = len(b)\n    result = [[0 for _ in range(p)] for _ in range(m)]\n    for i in range(m):\n        for j in range(p):\n            total = 0\n            for k in range(n):\n                total += a[i][k] * b[k][j]\n            result[i][j] = total\n    return result"}
{"task_id": 10, "completion_id": 0, "solution": "def calculate_covariance_matrix(vectors: list[list[float]]) -> list[list[float]]:\n    n = len(vectors)\n    if n == 0:\n        return []\n    m = len(vectors[0])\n    if m == 0:\n        return []\n    means = [sum(row) / n for row in vectors]\n    cov_matrix = [[0.0 for _ in range(m)] for _ in range(m)]\n    for i in range(m):\n        for j in range(m):\n            sum_ij = 0.0\n            for k in range(n):\n                x_i = vectors[k][i]\n                x_j = vectors[k][j]\n                sum_ij += (x_i - means[i]) * (x_j - means[j])\n            cov_matrix[i][j] = sum_ij / n\n    return cov_matrix"}
{"task_id": 12, "completion_id": 0, "solution": "import numpy as np\nimport math"}
{"task_id": 13, "completion_id": 0, "solution": "def determinant_4x4(matrix: list[list[int | float]]) -> float:\n\n    def determinant_3x3(submatrix):\n        (a, b, c) = submatrix[0]\n        (d, e, f) = submatrix[1]\n        (g, h, i) = submatrix[2]\n        return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    total = 0\n    for j in range(4):\n        minor = [row[:j] + row[j + 1:] for row in matrix[1:]]\n        det_minor = determinant_3x3(minor)\n        sign = (-1) ** j\n        term = matrix[0][j] * sign * det_minor\n        total += term\n    return total"}
{"task_id": 14, "completion_id": 0, "solution": "import numpy as np\ndef linear_regression_normal_equation(X: list[list[float]], y: list[float]) -> list[float]:\n    X = np.array(X)\n    y = np.array(y)\n    X_transpose = X.T\n    A = X_transpose @ X\n    A_inv = np.linalg.inv(A)\n    b = X_transpose @ y\n    theta = A_inv @ b\n    theta = np.round(theta, 4)\n    return theta"}
{"task_id": 15, "completion_id": 0, "solution": ""}
{"task_id": 19, "completion_id": 0, "solution": "import numpy as np\ndef pca(data: np.ndarray, k: int) -> list[list[float]]:\n    n_samples = data.shape[0]\n    n_features = data.shape[1]\n    mean = np.mean(data, axis=0)\n    data_centered = data - mean\n    try:\n        cov_matrix = np.cov(data_centered, rowvar=False)\n    except:\n        pass\n    (eigenvalues, eigenvectors) = np.linalg.eigh(cov_matrix)\n    eigen_pairs = list(zip(eigenvalues, eigenvectors))\n    eigen_pairs.sort(key=lambda x: -x[0])\n    principal_components = [vec for (val, vec) in eigen_pairs[:k]]\n    projection = data_centered @ principal_components\n    rounded_projection = []\n    for row in projection:\n        rounded_row = [round(x, 4) for x in row]\n        rounded_projection.append(rounded_row)\n    return rounded_projection"}
{"task_id": 22, "completion_id": 0, "solution": "import math\ndef sigmoid(z: float) -> float:\n    exp_z = math.exp(-z)\n    denominator = 1 + exp_z\n    result = 1 / denominator\n    return round(result, 4)"}
{"task_id": 23, "completion_id": 0, "solution": "import math\ndef softmax(scores: list[float]) -> list[float]:\n    if not scores:\n        return []\n    exponentials = [math.exp(score) for score in scores]\n    sum_exp = sum(exponentials)\n    probabilities = [exp / sum_exp for exp in exponentials]\n    rounded = [round(prob, 4) for prob in probabilities]\n    return rounded"}
{"task_id": 24, "completion_id": 0, "solution": "import math\ndef single_neuron_model(features: list[list[float]], labels: list[int], weights: list[float], bias: float) -> (list[float], float):\n    predictions = []\n    for feature in features:\n        z = sum((w * f for (w, f) in zip(weights, feature))) + bias\n        p = 1 / (1 + math.exp(-z))\n        predictions.append(p)\n    mae = 0.0\n    for (p, y) in zip(predictions, labels):\n        mae += (p - y) ** 2\n    mae /= len(labels)\n    mae_rounded = round(mae, 4)\n    rounded_p = [round(p, 4) for p in predictions]\n    return (rounded_p, mae_rounded)"}
{"task_id": 26, "completion_id": 0, "solution": "class Value:\n\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0\n        self._backward = lambda self: None\n        self._prev = set(_children)\n        self._op = _op\n\n    def add(self, other):\n        new_data = self.data + other.data\n        new_grad = self.grad + other.grad\n        new_value = Value(new_data, grad=new_grad)\n        new_value._backward = lambda a, b: a.grad + b.grad\n        new_value._prev = set(self._prev, other._prev)\n        new_value._op = 'add'\n        return new_value\n\n    def multiply(self, other):\n        new_data = self.data * other.data\n        new_grad = self.grad * other.data + other.grad * self.data\n        new_value = Value(new_data, grad=new_grad)\n        new_value._backward = lambda a, b: a.grad * b.data + b.grad * a.data\n        new_value._prev = set(self._prev, other._prev)\n        new_value._op = 'multiply'\n        return new_value\n\n    def relu(self):\n        new_data = self.data * (self.data > 0)\n        new_grad = 1 if self.data > 0 else 0\n        new_value = Value(new_data, grad=new_grad)\n        new_value._backward = lambda a: 1 if a.data > 0 else 0\n        new_value._prev = set(self._prev)\n        new_value._op = 'relu'\n        return new_value"}
{"task_id": 27, "completion_id": 0, "solution": "import numpy as np\ndef transform_basis(B: list[list[int]], C: list[list[int]]) -> list[list[float]]:\n    B_np = np.array(B)\n    C_np = np.array(C)\n    inv_B = np.linalg.inv(B_np)\n    P = np.zeros((3, 3), dtype=float)\n    for i in range(3):\n        c = C_np[i]\n        P[:, i] = np.dot(inv_B, c)\n    P = np.round(P, 4)\n    return P.tolist()"}
{"task_id": 28, "completion_id": 0, "solution": "import numpy as np\ndef svd_2x2(A: np.ndarray) -> tuple:\n    A_T = A.T\n    A_T_A = A_T @ A\n    (eigenvalues, eigenvectors) = np.linalg.eig(A_T_A)\n    eigenvalues = np.sort(eigenvalues, reverse=True)\n    S = np.array([[np.sqrt(eigenvalues[0]), 0], [0, np.sqrt(eigenvalues[1])]])\n    V = eigenvectors\n    U = []\n    for i in range(2):\n        v_i = eigenvectors[:, i]\n        a_v_i = A @ v_i\n        norm = np.linalg.norm(a_v_i)\n        if norm == 0:\n            u_i = np.array([0.0, 0.0])\n        else:\n            u_i = a_v_i / norm\n        U.append(u_i)\n    U = np.array(U).reshape(2, 2)\n    S = np.array(S).reshape(2, 2)\n    V = np.array(V).reshape(2, 2)\n    U = [round(x, 4) for x in U.flatten()]\n    S = [round(x, 4) for x in S.flatten()]\n    V = [round(x, 4) for x in V.flatten()]\n    return (U, S, V)"}
{"task_id": 29, "completion_id": 0, "solution": "import numpy as np\ndef shuffle_data(X, y, seed=None):\n    data = list(zip(np.arange(len(X)), X, y))\n    if seed is not None:\n        np.random.seed(seed)\n    np.random.shuffle(data)\n    new_X = [item[1] for item in data]\n    new_y = [item[2] for item in data]\n    new_X = np.array(new_X).tolist()\n    new_y = np.array(new_y).tolist()\n    return [new_X, new_y]"}
{"task_id": 31, "completion_id": 0, "solution": "import numpy as np\ndef divide_on_feature(X, feature_i, threshold):\n    condition_subset = X[np.where(X[:, feature_i] >= threshold)[0]]\n    other_subset = X[np.where(X[:, feature_i] < threshold)[0]]\n    return [condition_subset, other_subset]"}
{"task_id": 34, "completion_id": 0, "solution": "import numpy as np\ndef to_categorical(x, n_col=None):\n    if n_col is None:\n        unique_values = np.unique(x, return_counts=True)[0]\n        n_col = len(unique_values)\n    result = []\n    for value in x:\n        row = [0] * n_col\n        row[value] = 1\n        result.append(row)\n    return np.array(result).tolist()"}
{"task_id": 35, "completion_id": 0, "solution": "import numpy as np\ndef make_diagonal(x):\n    return np.array(np.diag(x)).tolist()"}
{"task_id": 36, "completion_id": 0, "solution": "import numpy as np\ndef accuracy_score(y_true, y_pred):\n    correct = np.sum(y_true == y_pred)\n    total = len(y_true)\n    accuracy = correct / total\n    return round(accuracy, 4)"}
{"task_id": 37, "completion_id": 0, "solution": "import numpy as np\ndef calculate_correlation_matrix(X, Y=None):\n    if Y is None:\n        Y = X\n    try:\n        cov_matrix = np.cov(X, Y)\n    except:\n        pass\n    std_x = np.std(X, axis=0)\n    std_y = np.std(Y, axis=0)\n    correlation = np.zeros((X.shape[1], Y.shape[1]))\n    for i in range(X.shape[1]):\n        for j in range(Y.shape[1]):\n            if std_x[i] == 0 or std_y[j] == 0:\n                correlation[i][j] = 0.0\n            else:\n                correlation[i][j] = cov_matrix[i][j] / (std_x[i] * std_y[j])\n    rounded = np.round(correlation, 4)\n    return rounded.tolist()"}
{"task_id": 39, "completion_id": 0, "solution": "import numpy as np\ndef log_softmax(scores: list):\n    scores = np.array(scores)\n    exp_scores = np.exp(scores)\n    sum_exp = np.sum(exp_scores)\n    log_sof = scores - np.log(sum_exp)\n    rounded = [round(x, 4) for x in log_sof]\n    return rounded.tolist()"}
{"task_id": 42, "completion_id": 0, "solution": "def relu(z: float) -> float:\n    if z > 0:\n        return z\n    else:\n        return 0"}
{"task_id": 43, "completion_id": 0, "solution": ""}
{"task_id": 44, "completion_id": 0, "solution": "def leaky_relu(z: float, alpha: float=0.01) -> float:\n    if z <= 0:\n        return z\n    else:\n        return alpha * z"}
{"task_id": 45, "completion_id": 0, "solution": "import numpy as np\ndef kernel_function(x1, x2):\n    return np.dot(x1, x2)"}
{"task_id": 46, "completion_id": 0, "solution": "import numpy as np\ndef precision(y_true, y_pred):\n    tp = np.sum((y_true == 1) & (y_pred == 1))\n    fp = np.sum((y_true == 0) & (y_pred == 1))\n    denominator = tp + fp\n    if denominator == 0:\n        return 1.0\n    else:\n        return tp / denominator"}
{"task_id": 50, "completion_id": 0, "solution": "import numpy as np\ndef l1_regularization_gradient_descent(X: np.array, y: np.array, alpha: float=0.1, learning_rate: float=0.01, max_iter: int=1000, tol: float=0.0001) -> tuple:\n    n = len(y)\n    m = X.shape[1]\n    weights = np.zeros(m)\n    bias = 0.0\n    for _ in range(max_iter):\n        error = y - (X @ weights + bias)\n        grad_weights = 1.0 / n * X.T @ error + alpha * np.sign(weights)\n        grad_bias = -1.0 / n * np.sum(error) + alpha * np.sign(bias)\n        weights -= learning_rate * grad_weights\n        bias -= learning_rate * grad_bias\n    weights = np.round(weights, 4)\n    bias = np.round(bias, 4)\n    return (weights, bias)"}
{"task_id": 51, "completion_id": 0, "solution": "def OSA(source: str, target: str) -> int:\n    m = len(source)\n    n = len(target)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if source[i - 1] == target[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                option1 = dp[i - 1][j - 1] + 1\n                option2 = dp[i - 1][j] + 1\n                option3 = dp[i][j - 1] + 1\n                dp[i][j] = min(option1, option2, option3)\n            if source[i - 1] == target[j - 1] and source[i] == target[j]:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)\n    return dp[m][n]"}
{"task_id": 52, "completion_id": 0, "solution": "import numpy as np\ndef recall(y_true, y_pred):\n    tp = np.sum(y_true * y_pred)\n    fn = np.sum(y_true * (1 - y_pred))\n    denominator = tp + fn\n    if denominator == 0:\n        return 0.0\n    else:\n        return tp / denominator"}
{"task_id": 54, "completion_id": 0, "solution": "import numpy as np\ndef rnn_forward(input_sequence: list[list[float]], initial_hidden_state: list[float], Wx: list[list[float]], Wh: list[list[float]], b: list[float]) -> list[float]:\n    h = np.array(initial_hidden_state)\n    for x in input_sequence:\n        pre_activation = np.dot(Wx, h) + b\n        h = np.tanh(pre_activation)\n    return [round(num, 4) for num in h]"}
{"task_id": 55, "completion_id": 0, "solution": "import numpy as np\ndef translate_object(points, tx, ty):\n    translation = np.array([[1, 0, tx], [0, 1, ty]])\n    points_np = np.array(points)\n    translated = np.dot(translation, points_np)\n    return translated.tolist()"}
{"task_id": 58, "completion_id": 0, "solution": "def gaussian_elimination(A, b):\n    n = len(A[0])\n    augmented = []\n    for i in range(n):\n        row = A[i].copy()\n        row.append(b[i])\n        augmented.append(row)\n    for i in range(n):\n        max_row = i\n        for j in range(i, n):\n            if abs(augmented[j][i]) > abs(augmented[max_row][i]):\n                max_row = j\n        (augmented[i], augmented[max_row]) = (augmented[max_row], augmented[i])\n        pivot = augmented[i][i]\n        for j in range(i + 1, n):\n            factor = augmented[j][i] / pivot\n            for k in range(i, n):\n                augmented[j][k] -= factor * augmented[i][k]\n    x = [0.0] * n\n    for i in range(n - 1, -1, -1):\n        x[i] = augmented[i][n] / augmented[i][i]\n    x = [round(num, 4) for num in x]\n    return x"}
{"task_id": 60, "completion_id": 0, "solution": "import math\ndef compute_tf_idf(corpus, query):\n    if not corpus:\n        return []\n    total_count = sum((len(doc) for doc in corpus))\n    word_list = []\n    for word in query:\n        count_in_doc = [doc.count(word) for doc in corpus]\n        df = len([doc for doc in corpus if word in doc])\n        word_list.append((count_in_doc, df))\n    average_TF = total_count / len(corpus)\n    sum_df = sum((df for (count_in_doc, df) in word_list))\n    average_df = sum_df / len(query)\n    N = len(corpus)\n    result = []\n    for doc in corpus:\n        scores = []\n        for (i, (count_in_doc, df)) in enumerate(word_list):\n            TF = count_in_doc / average_TF\n            TF_IDF = TF * math.log((N + 1) / (count_in_doc + 1))\n            scores.append(round(TF_IDF, 5))\n        result.append(scores)\n    return result"}
{"task_id": 61, "completion_id": 0, "solution": "import numpy as np\ndef f_score(y_true, y_pred, beta):\n    \"\"\"\n    Calculate F-Score for a binary classification task.\n    \n    :param y_true: numpy array of true labels (binary)\n    :param y_pred: numpy array of predicted labels (binary)\n    :param beta: float value that adjusts the importance of Precision and Recall\n    :return: F-Score rounded to three decimal places\n    \"\"\"\n    TP = np.sum(y_true * y_pred)\n    FP = np.sum((1 - y_true) * y_pred)\n    FN = np.sum(y_true * (1 - y_pred))\n    p = TP / (TP + FP) if TP + FP != 0 else 1.0\n    r = TP / (TP + FN) if TP + FN != 0 else 1.0\n    f_score_value = 2 * p * r / (p + r)\n    return round(f_score_value, 3)"}
{"task_id": 64, "completion_id": 0, "solution": ""}
{"task_id": 65, "completion_id": 0, "solution": "def compressed_row_sparse_matrix(dense_matrix):\n    values = []\n    column_indices = []\n    row_pointers = [0]\n    for row in dense_matrix:\n        for (col, val) in enumerate(row):\n            if val != 0:\n                values.append(val)\n                column_indices.append(col)\n        row_pointers.append(len(values))\n    return (values, column_indices, row_pointers)"}
{"task_id": 66, "completion_id": 0, "solution": "def orthogonal_projection(v, L):\n    dot_vL = sum((v[i] * L[i] for i in range(len(v))))\n    dot_LL = sum((L[i] * L[i] for i in range(len(L))))\n    scalar = dot_vL / dot_LL\n    projection = [scalar * L[i] for i in range(len(L))]\n    projection_rounded = [round(x, 3) for x in projection]\n    return projection_rounded"}
{"task_id": 67, "completion_id": 0, "solution": "def compressed_col_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix into its Compressed Column Sparse (CSC) representation.\n    Returns a tuple of (values, row_indices, column_ptr)\n    \"\"\"\n    if not dense_matrix or not dense_matrix[0]:\n        return ([], [], [])\n    rows = len(dense_matrix)\n    cols = len(dense_matrix[0])\n    values = []\n    row_indices = []\n    column_ptr = [0] * cols\n    for c in range(cols):\n        col_values = []\n        for r in range(rows):\n            if dense_matrix[r][c] != 0:\n                col_values.append((dense_matrix[r][c], r))\n        for (val, row) in col_values:\n            values.append(val)\n            row_indices.append(row)\n        current_ptr = 0\n        for i in range(c):\n            current_ptr += len(row_indices[i])\n        column_ptr[c] = current_ptr\n    return (values, row_indices, column_ptr)"}
{"task_id": 69, "completion_id": 0, "solution": "import numpy as np\ndef r_squared(y_true, y_pred):\n    mean_y_true = np.mean(y_true)\n    sum_total_sq = np.sum((y_true - mean_y_true) ** 2)\n    sum_sq_resid = np.sum((y_true - y_pred) ** 2)\n    if sum_total_sq == 0:\n        return 1.0\n    else:\n        r_squared_value = 1 - sum_sq_resid / sum_total_sq\n        return round(r_squared_value, 3)"}
{"task_id": 70, "completion_id": 0, "solution": "def calculate_brightness(img):\n    if not img:\n        return -1\n    row_length = len(img[0])\n    for row in img:\n        if len(row) != row_length:\n            return -1\n    for row in img:\n        for pixel in row:\n            if pixel < 0 or pixel > 255:\n                return -1\n    total_pixels = len(img) * len(img[0])\n    sum_pixels = 0\n    for row in img:\n        sum_pixels += sum(row)\n    average = sum_pixels / total_pixels\n    return round(average, 2)"}
{"task_id": 71, "completion_id": 0, "solution": "import numpy as np\ndef rmse(y_true, y_pred):\n    if not isinstance(y_true, np.ndarray) or not isinstance(y_pred, np.ndarray):\n        return None\n    if y_true.shape != y_pred.shape:\n        return None\n    squared_diff = (y_true - y_pred) ** 2\n    mean = np.mean(squared_diff)\n    rmse_value = np.sqrt(mean)\n    return round(rmse_value, 3)"}
{"task_id": 72, "completion_id": 0, "solution": "import numpy as np\ndef jaccard_index(y_true, y_pred):\n    intersection = np.sum(y_true * y_pred)\n    sum_true = np.sum(y_true)\n    sum_pred = np.sum(y_pred)\n    union = sum_true + sum_pred - intersection\n    if union == 0:\n        return 1.0\n    else:\n        return intersection / union"}
{"task_id": 73, "completion_id": 0, "solution": ""}
{"task_id": 74, "completion_id": 0, "solution": "import numpy as np"}
{"task_id": 75, "completion_id": 0, "solution": ""}
{"task_id": 76, "completion_id": 0, "solution": "import numpy as np\ndef cosine_similarity(v1, v2):\n    dot_product = np.dot(v1, v2)\n    norm_v1 = np.linalg.norm(v1)\n    norm_v2 = np.linalg.norm(v2)\n    return round(dot_product / (norm_v1 * norm_v2), 3)"}
{"task_id": 77, "completion_id": 0, "solution": "from collections import Counter\ndef performance_metrics(actual: list[int], predicted: list[int]) -> tuple:\n    tp = 0\n    fp = 0\n    fn = 0\n    tn = 0\n    for (a, p) in zip(actual, predicted):\n        if a == 1 and p == 1:\n            tp += 1\n        elif a == 1 and p == 0:\n            fn += 1\n        elif a == 0 and p == 1:\n            fp += 1\n        else:\n            tn += 1\n    confusion_matrix = [[tn, fp], [fn, tp]]\n    total = len(actual)\n    accuracy = (tp + tn) / total\n    f1 = 2 * (tp / (tp + fp)) * (tp / (tp + fn)) / (1 / (tp + fp) + 1 / (tp + fn))\n    specificity = tn / (tn + fp)\n    npv = tn / (tn + fp)\n    accuracy_rounded = round(accuracy, 3)\n    f1_rounded = round(f1, 3)\n    specificity_rounded = round(specificity, 3)\n    npv_rounded = round(npv, 3)\n    return (confusion_matrix, accuracy_rounded, f1_rounded, specificity_rounded, npv_rounded)"}
{"task_id": 79, "completion_id": 0, "solution": "import math\ndef binomial_probability(n, k, p):\n    if k < 0 or k > n:\n        return 0.0\n    if k == 0:\n        prob = (1 - p) ** n\n    elif k == n:\n        prob = p ** n\n    else:\n        prob = math.comb(n, k) * p ** k * (1 - p) ** (n - k)\n    return round(prob, 5)"}
{"task_id": 80, "completion_id": 0, "solution": "import math\ndef normal_pdf(x, mean, std_dev):\n    exponent = (x - mean) ** 2 / (2 * std_dev ** 2)\n    value = 1 / math.sqrt(2 * math.pi) * math.exp(-exponent)\n    return round(value, 5)"}
{"task_id": 81, "completion_id": 0, "solution": ""}
{"task_id": 82, "completion_id": 0, "solution": "import numpy as np\ndef calculate_contrast(img):\n    \"\"\"\n    Calculate the contrast of a grayscale image.\n    \n    Args:\n        img (numpy.ndarray): 2D array representing a grayscale image with pixel values between 0 and 255.\n    \n    Returns:\n        int: The contrast value of the image.\n    \"\"\"\n    max_val = np.max(img)\n    min_val = np.min(img)\n    return max_val - min_val"}
{"task_id": 83, "completion_id": 0, "solution": "import numpy as np\ndef calculate_dot_product(vec1, vec2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Args:\n        vec1 (numpy.ndarray): 1D array representing the first vector.\n        vec2 (numpy.ndarray): 1D array representing the second vector.\n    \"\"\"\n    return np.dot(vec1, vec2)"}
{"task_id": 84, "completion_id": 0, "solution": "import numpy as np\ndef phi_transform(data: list[float], degree: int) -> list[list[float]]:\n    \"\"\"\n    Perform a Phi Transformation to map input features into a higher-dimensional space by generating polynomial features.\n    \n    Args:\n        data (list[float]): A list of numerical values to transform.\n        degree (int): The degree of the polynomial expansion.\n        \n    Returns:\n        list[list[float]]: A nested list where each inner list contains the polynomial features of the corresponding data point.\n    \"\"\"\n    if degree < 0:\n        return []\n    result = []\n    for point in data:\n        transformed = []\n        for feature in point:\n            for k in range(degree + 1):\n                transformed.append(feature ** k)\n        transformed = [round(num, 8) for num in transformed]\n        result.append(transformed)\n    return result"}
{"task_id": 86, "completion_id": 0, "solution": ""}
{"task_id": 91, "completion_id": 0, "solution": "def calculate_f1_score(y_true, y_pred):\n    TP = 0\n    FP = 0\n    FN = 0\n    for (yt, yp) in zip(y_true, y_pred):\n        if yt == 1 and yp == 1:\n            TP += 1\n        elif yt == 1 and yp == 0:\n            FP += 1\n        elif yt == 0 and yp == 1:\n            FN += 1\n    if TP + FP == 0:\n        precision = 0.0\n    else:\n        precision = TP / (TP + FP)\n    if TP + FN == 0:\n        recall = 0.0\n    else:\n        recall = FN / (TP + FN)\n    if precision + recall == 0:\n        f1 = 0.0\n    else:\n        f1 = 2 * (precision * recall) / (precision + recall)\n    return round(f1, 3)"}
{"task_id": 92, "completion_id": 0, "solution": "import math\ndef power_grid_forecast(consumption_data):\n    f = [10 * math.sin(2 * math.pi * i / 10) for i in range(1, 11)]\n    detrended = [consumption_data[i] - f[i] for i in range(10)]\n    n = len(detrended)\n    sum_x = sum((i for i in range(1, 11)))\n    sum_y = sum(detrended)\n    sum_xy = sum((i * y for (i, y) in zip(range(1, 11), detrended)))\n    sum_x2 = sum((i ** 2 for i in range(1, 11)))\n    a = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x ** 2)\n    b = (sum_y - a * sum_x) / n\n    base_day15 = a * 15 + b\n    f_day15 = 10 * math.sin(2 * math.pi * 15 / 10)\n    total = base_day15 + f_day15\n    rounded_total = round(total)\n    safety = math.ceil(rounded_total * 0.05)\n    final_answer = rounded_total + safety\n    return final_answer"}
{"task_id": 93, "completion_id": 0, "solution": "import numpy as np\ndef mae(y_true, y_pred):\n    absolute_diffs = np.abs(y_true - y_pred)\n    mae = np.mean(absolute_diffs)\n    return round(mae, 3)"}
{"task_id": 94, "completion_id": 0, "solution": "import numpy as np\ndef multi_head_attention(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray, n_heads: int) -> list:\n    batch_size = X.shape[0]\n    input_dim = X.shape[1]\n    output_dim = input_dim // n_heads\n    X_split = [X[i * output_dim:(i + 1) * output_dim] for i in range(n_heads)]\n    q = [X_split[i] @ W_q for i in range(n_heads)]\n    k = [X_split[i] @ W_k for i in range(n_heads)]\n    v = [X_split[i] @ W_v for i in range(n_heads)]\n    attention_outputs = []\n    for (q_head, k_head, v_head) in zip(q, k, v):\n        q_k = q_head @ k_head.T\n        attention_scores = q_k / np.sqrt(input_dim)\n        attention_weights = np.exp(attention_scores) / np.sum(np.exp(attention_scores), axis=1, keepdims=True)\n        output = attention_weights @ v_head\n        attention_outputs.append(output)\n    final_output = np.concatenate(attention_outputs, axis=1)\n    final_output = np.round(final_output, 4)\n    return final_output.tolist()"}
{"task_id": 96, "completion_id": 0, "solution": "def hard_sigmoid(x: float) -> float:\n    return max(0.0, min(1.0, 0.5 * (1 + x)))"}
{"task_id": 97, "completion_id": 0, "solution": "import math\ndef elu(x: float, alpha: float=1.0) -> float:\n    if x > 0:\n        return round(x, 4)\n    else:\n        return round(alpha * (math.exp(x) - 1), 4)"}
{"task_id": 98, "completion_id": 0, "solution": "def prelu(x: float, alpha: float=0.25) -> float:\n    if x > 0:\n        return x\n    else:\n        return x * alpha"}
{"task_id": 99, "completion_id": 0, "solution": "import math\ndef softplus(x: float) -> float:\n    return round(math.log(1 + math.exp(x)), 4)"}
{"task_id": 100, "completion_id": 0, "solution": "def softsign(x: float) -> float:\n    result = x / (1 + abs(x))\n    return round(result, 4)"}
{"task_id": 101, "completion_id": 0, "solution": "import numpy as np\ndef grpo_objective(rhos, A, pi_theta_old, pi_theta_ref, epsilon=0.2, beta=0.01) -> float:\n    sum_A_log_ratio = 0.0\n    kl_div = 0.0\n    for i in range(len(rho)):\n        log_rho = np.log(rho[i])\n        log_pi_old = np.log(pi_old[i])\n        term1 = A[i] * log_rho\n        term2 = A[i] * log_pi_old\n        sum_A_log_ratio += term1 - term2\n        pi_ref_i = pi_ref[i]\n        kl_term = pi_ref_i * np.log(pi_ref_i / pi_old[i])\n        kl_div += kl_term\n    objective = sum_A_log_ratio - beta * kl_div\n    return round(objective, 6)"}
{"task_id": 102, "completion_id": 0, "solution": "import math\ndef swish(x: float) -> float:\n    sigmoid = 1 / (1 + math.exp(-x))\n    swish_val = x * sigmoid\n    return round(swish_val, 4)"}
{"task_id": 104, "completion_id": 0, "solution": ""}
{"task_id": 109, "completion_id": 0, "solution": "import numpy as np\ndef layer_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float=1e-05):\n    mu = np.mean(X, axis=(0, 1), keepdims=True)\n    sigma = np.std(X, axis=(0, 1), ddof=0, keepdims=True)\n    X_centered = X - mu\n    X_normalized = X_centered / sigma\n    X_scaled = X_normalized * gamma\n    X_final = X_scaled + beta\n    X_final_rounded = np.round(X_final, 5).tolist()\n    return X_final_rounded"}
{"task_id": 111, "completion_id": 0, "solution": "import numpy as np\ndef compute_pmi(joint_counts, total_counts_x, total_counts_y, total_samples):\n    sum_pmi = 0.0\n    for x in range(len(joint_counts)):\n        for y in range(len(joint_counts[0])):\n            expected = total_counts_x * total_counts_y / total_samples\n            current_count = joint_counts[x][y]\n            log_term = np.log2(current_count / expected)\n            sum_pmi += current_count * log_term\n    return round(sum_pmi, 3)"}
{"task_id": 112, "completion_id": 0, "solution": "def min_max(x: list[int]) -> list[float]:\n    if not x:\n        return []\n    min_x = min(x)\n    max_x = max(x)\n    if min_x == max_x:\n        return [0.0]\n    scaled = [(num - min_x) / (max_x - min_x) for num in x]\n    return [round(num, 4) for num in scaled]"}
{"task_id": 114, "completion_id": 0, "solution": "import numpy as np\ndef global_avg_pool(x: np.ndarray):\n    return x.mean(axis=(0, 1))"}
{"task_id": 116, "completion_id": 0, "solution": ""}
{"task_id": 118, "completion_id": 0, "solution": ""}
{"task_id": 121, "completion_id": 0, "solution": "def vector_sum(a: list[int | float], b: list[int | float]) -> list[int | float]:\n    if len(a) != len(b):\n        return -1\n    return [a[i] + b[i] for i in range(len(a))]"}
{"task_id": 122, "completion_id": 0, "solution": "import numpy as np\ndef compute_policy_gradient(theta: np.ndarray, episodes: list[list[tuple[int, int, float]]]):\n    total_gradient = 0.0\n    num_episodes = len(episodes)\n    for episode in episodes:\n        return_ = sum((r for (s, a, r) in episode))\n        for (s, a, r) in episode:\n            sum_exp = np.sum(np.exp(theta[s, :]))\n            log_p = np.log(sum_exp)\n            total_gradient += log_p * r\n    average_gradient = total_gradient / num_episodes\n    average_gradient_rounded = [round(x, 4) for x in average_gradient]\n    return list(average_gradient_rounded)"}
{"task_id": 123, "completion_id": 0, "solution": "def compute_efficiency(n_experts, k_active, d_in, d_out):\n    moe_flops = k_active * d_in * d_out\n    dense_flops = d_in * d_out ** 2\n    efficiency = moe_flops / dense_flops * 100\n    return round(efficiency, 1)"}
{"task_id": 125, "completion_id": 0, "solution": "import numpy as np\ndef moe(x: np.ndarray, We: np.ndarray, Wg: np.ndarray, n_experts: int, top_k: int) -> list:\n    p = np.exp(Wg @ x) / np.sum(np.exp(Wg @ x), axis=1, keepdims=True)\n    final_output = []\n    for i in range(x.shape[1]):\n        p_row = p[i, :]\n        sorted_indices = np.argsort(p_row, axis=0)\n        top_k_indices = sorted_indices[-top_k:]\n        sum_expert = 0\n        for j in top_k_indices:\n            sum_expert += We[j] @ x[i, :]\n        final_output.append(round(sum_expert, 4))\n    return final_output"}
