{"task_id": 1, "completion_id": 0, "solution": "def matrix_dot_vector(a: list[list[int | float]], b: list[int | float]) -> list[int | float]:\n    if not a:\n        return [] if not b else -1\n    num_cols = len(a[0])\n    for row in a:\n        if len(row) != num_cols:\n            return -1\n    if len(b) != num_cols:\n        return -1\n    result = []\n    for row in a:\n        dot = 0\n        for i in range(num_cols):\n            dot += row[i] * b[i]\n        result.append(dot)\n    return result"}
{"task_id": 2, "completion_id": 0, "solution": "def transpose_matrix(a: list[list[int | float]]) -> list[list[int | float]]:\n    return [list(row) for row in zip(*a)]"}
{"task_id": 3, "completion_id": 0, "solution": "import numpy as np\ndef reshape_matrix(a: list[list[int | float]], new_shape: tuple[int, int]) -> list[list[int | float]]:\n    total_elements = sum((len(row) for row in a))\n    if new_shape[0] * new_shape[1] != total_elements:\n        return []\n    arr = np.array(a)\n    reshaped = arr.reshape(new_shape)\n    return reshaped.tolist()"}
{"task_id": 4, "completion_id": 0, "solution": "def calculate_matrix_mean(matrix: list[list[float]], mode: str) -> list[float]:\n    if mode == 'row':\n        means = []\n        for row in matrix:\n            mean = sum(row) / len(row)\n            means.append(mean)\n        return means\n    else:\n        if not matrix:\n            return []\n        n_cols = len(matrix[0])\n        means = []\n        for i in range(n_cols):\n            column = [row[i] for row in matrix]\n            mean = sum(column) / len(column)\n            means.append(mean)\n        return means"}
{"task_id": 5, "completion_id": 0, "solution": "def scalar_multiply(matrix: list[list[int | float]], scalar: int | float) -> list[list[int | float]]:\n    result = []\n    for row in matrix:\n        new_row = []\n        for num in row:\n            new_row.append(num * scalar)\n        result.append(new_row)\n    return result"}
{"task_id": 6, "completion_id": 0, "solution": "import math\ndef calculate_eigenvalues(matrix: list[list[float | int]]) -> list[float]:\n    a = matrix[0][0]\n    b = matrix[0][1]\n    c = matrix[1][0]\n    d = matrix[1][1]\n    trace = a + d\n    determinant = a * d - b * c\n    discriminant = trace ** 2 - 4 * determinant\n    sqrt_discriminant = math.sqrt(discriminant)\n    eigen1 = (trace + sqrt_discriminant) / 2\n    eigen2 = (trace - sqrt_discriminant) / 2\n    eigenvalues = [eigen1, eigen2]\n    eigenvalues.sort(reverse=True)\n    return eigenvalues"}
{"task_id": 8, "completion_id": 0, "solution": "def inverse_2x2(matrix: list[list[float]]) -> list[list[float]]:\n    a = matrix[0][0]\n    b = matrix[0][1]\n    c = matrix[1][0]\n    d = matrix[1][1]\n    det = a * d - b * c\n    if det == 0:\n        return None\n    inv_det = 1.0 / det\n    return [[d * inv_det, -b * inv_det], [-c * inv_det, a * inv_det]]"}
{"task_id": 9, "completion_id": 0, "solution": "def matrixmul(a: list[list[int | float]], b: list[list[int | float]]) -> list[list[int | float]]:\n    if not a or not b:\n        return -1\n    rows_a = len(a)\n    cols_a = len(a[0])\n    for row in a:\n        if len(row) != cols_a:\n            return -1\n    rows_b = len(b)\n    cols_b = len(b[0])\n    for row in b:\n        if len(row) != cols_b:\n            return -1\n    if cols_a != rows_b:\n        return -1\n    result = []\n    for i in range(rows_a):\n        new_row = []\n        for j in range(cols_b):\n            sum_val = 0\n            for k in range(cols_a):\n                sum_val += a[i][k] * b[k][j]\n            new_row.append(sum_val)\n        result.append(new_row)\n    return result"}
{"task_id": 11, "completion_id": 0, "solution": "import numpy as np\ndef solve_jacobi(A: np.ndarray, b: np.ndarray, n: int) -> list:\n    m = len(b)\n    x = np.zeros(m)\n    for _ in range(n):\n        x_new = np.zeros(m)\n        for i in range(m):\n            s = np.dot(A[i], x) - A[i, i] * x[i]\n            x_new[i] = (b[i] - s) / A[i, i]\n        x = np.round(x_new, 4)\n    return x.tolist()"}
{"task_id": 14, "completion_id": 0, "solution": "import numpy as np\ndef linear_regression_normal_equation(X: list[list[float]], y: list[float]) -> list[float]:\n    X_np = np.array(X)\n    y_np = np.array(y)\n    XTX = X_np.T @ X_np\n    XTX_inv = np.linalg.inv(XTX)\n    theta = XTX_inv @ (X_np.T @ y_np)\n    theta_rounded = [round(num, 4) for num in theta]\n    return theta_rounded"}
{"task_id": 16, "completion_id": 0, "solution": "import numpy as np\ndef feature_scaling(data: np.ndarray) -> (list[list[float]], list[list[float]]):\n    mean = data.mean(axis=0)\n    std = data.std(axis=0)\n    standardized = (data - mean) / std\n    min_vals = data.min(axis=0)\n    max_vals = data.max(axis=0)\n    normalized = (data - min_vals) / (max_vals - min_vals)\n    standardized_rounded = np.round(standardized, 4)\n    normalized_rounded = np.round(normalized, 4)\n    standardized_list = standardized_rounded.tolist()\n    normalized_list = normalized_rounded.tolist()\n    return (standardized_list, normalized_list)"}
{"task_id": 17, "completion_id": 0, "solution": "import numpy as np\ndef k_means_clustering(points: list[tuple[float, float]], k: int, initial_centroids: list[tuple[float, float]], max_iterations: int) -> list[tuple[float, float]]:\n    points_np = np.array(points)\n    centroids = np.array(initial_centroids)\n    for _ in range(max_iterations):\n        distances = np.sqrt(np.sum((points_np[:, np.newaxis] - centroids) ** 2, axis=2))\n        cluster_indices = np.argmin(distances, axis=1)\n        new_centroids = []\n        for i in range(k):\n            cluster_points = points_np[cluster_indices == i]\n            if len(cluster_points) == 0:\n                new_centroid = centroids[i]\n            else:\n                new_centroid = np.mean(cluster_points, axis=0)\n            new_centroids.append(new_centroid)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = np.array(new_centroids)\n    rounded_centroids = np.round(centroids, decimals=4)\n    final_centroids = [tuple(row) for row in rounded_centroids]\n    return final_centroids"}
{"task_id": 18, "completion_id": 0, "solution": "import numpy as np\ndef k_fold_cross_validation(X: np.ndarray, y: np.ndarray, k=5, shuffle=True, random_seed=None):\n    n = X.shape[0]\n    indices = np.arange(n)\n    if shuffle:\n        if random_seed is not None:\n            np.random.seed(random_seed)\n        indices = np.random.permutation(indices)\n    folds = np.array_split(indices, k)\n    splits = []\n    for i in range(k):\n        test_indices = folds[i]\n        train_indices = np.concatenate(folds[:i] + folds[i + 1:])\n        splits.append((train_indices, test_indices))\n    return splits"}
{"task_id": 22, "completion_id": 0, "solution": "import math\ndef sigmoid(z: float) -> float:\n    result = 1 / (1 + math.exp(-z))\n    return round(result, 4)"}
{"task_id": 23, "completion_id": 0, "solution": "import math\ndef softmax(scores: list[float]) -> list[float]:\n    if not scores:\n        return []\n    max_score = max(scores)\n    adjusted_scores = [s - max_score for s in scores]\n    exp_scores = [math.exp(s) for s in adjusted_scores]\n    sum_exp = sum(exp_scores)\n    softmax_values = [e / sum_exp for e in exp_scores]\n    rounded = [round(v, 4) for v in softmax_values]\n    return rounded"}
{"task_id": 24, "completion_id": 0, "solution": "import math\nimport numpy as np\ndef single_neuron_model(features: list[list[float]], labels: list[int], weights: list[float], bias: float) -> (list[float], float):\n    X = np.array(features)\n    y = np.array(labels)\n    w = np.array(weights)\n    z = np.dot(X, w) + bias\n    predictions = 1 / (1 + np.exp(-z))\n    mse = np.mean((y - predictions) ** 2)\n    predictions_rounded = np.round(predictions, 4).tolist()\n    mse_rounded = np.round(mse, 4)\n    return (predictions_rounded, mse_rounded)"}
{"task_id": 27, "completion_id": 0, "solution": "import numpy as np\ndef transform_basis(B: list[list[int]], C: list[list[int]]) -> list[list[float]]:\n    B_np = np.array(B)\n    C_np = np.array(C)\n    C_inv = np.linalg.inv(C_np)\n    P = C_inv @ B_np\n    P_rounded = np.round(P, 4)\n    return P_rounded.tolist()"}
{"task_id": 29, "completion_id": 0, "solution": "import numpy as np\ndef shuffle_data(X, y, seed=None):\n    if len(X) != len(y):\n        raise ValueError('X and y must have the same number of samples.')\n    if seed is not None:\n        np.random.seed(seed)\n    permutation = np.random.permutation(len(X))\n    X_shuffled = X[permutation]\n    y_shuffled = y[permutation]\n    return (X_shuffled.tolist(), y_shuffled.tolist())"}
{"task_id": 30, "completion_id": 0, "solution": "import numpy as np\ndef batch_iterator(X, y=None, batch_size=64):\n    n_samples = X.shape[0]\n    for i in range(0, n_samples, batch_size):\n        X_batch = X[i:i + batch_size].tolist()\n        if y is not None:\n            y_batch = y[i:i + batch_size].tolist()\n            yield (X_batch, y_batch)\n        else:\n            yield X_batch"}
{"task_id": 31, "completion_id": 0, "solution": "import numpy as np\ndef divide_on_feature(X, feature_i, threshold):\n    mask = X[:, feature_i] >= threshold\n    subset1 = X[mask]\n    subset2 = X[~mask]\n    return (subset1.tolist(), subset2.tolist())"}
{"task_id": 34, "completion_id": 0, "solution": "import numpy as np\ndef to_categorical(x, n_col=None):\n    if len(x) == 0:\n        return []\n    if n_col is None:\n        n_col = np.max(x) + 1\n    result = np.zeros((len(x), n_col), dtype=int)\n    result[np.arange(len(x)), x] = 1\n    return result.tolist()"}
{"task_id": 35, "completion_id": 0, "solution": "import numpy as np\ndef make_diagonal(x):\n    diag_matrix = np.diag(x)\n    return diag_matrix.tolist()"}
{"task_id": 36, "completion_id": 0, "solution": "import numpy as np\ndef accuracy_score(y_true, y_pred):\n    accuracy = np.mean(y_true == y_pred)\n    return round(accuracy, 4)"}
{"task_id": 39, "completion_id": 0, "solution": "import numpy as np\ndef log_softmax(scores: list):\n    scores_np = np.array(scores)\n    m = np.max(scores_np)\n    shifted = scores_np - m\n    exp_shifted = np.exp(shifted)\n    sum_exp = np.sum(exp_shifted)\n    log_sum = np.log(sum_exp)\n    log_softmax_values = shifted - log_sum\n    log_softmax_values = np.round(log_softmax_values, 4)\n    return log_softmax_values.tolist()"}
{"task_id": 42, "completion_id": 0, "solution": "def relu(z: float) -> float:\n    return max(z, 0)"}
{"task_id": 43, "completion_id": 0, "solution": "import numpy as np\ndef ridge_loss(X: np.ndarray, w: np.ndarray, y_true: np.ndarray, alpha: float) -> float:\n    y_pred = X.dot(w)\n    residuals = y_true - y_pred\n    squared_errors = residuals ** 2\n    mse = np.mean(squared_errors)\n    regularization = alpha * np.sum(w ** 2)\n    total_loss = mse + regularization\n    return round(total_loss, 4)"}
{"task_id": 44, "completion_id": 0, "solution": "def leaky_relu(z: float, alpha: float=0.01) -> float:\n    return z if z > 0 else alpha * z"}
{"task_id": 45, "completion_id": 0, "solution": "import numpy as np\ndef kernel_function(x1, x2):\n    return np.dot(x1, x2)"}
{"task_id": 46, "completion_id": 0, "solution": "import numpy as np\ndef precision(y_true, y_pred):\n    tp = np.sum((y_true == 1) & (y_pred == 1))\n    fp = np.sum((y_true == 0) & (y_pred == 1))\n    denominator = tp + fp\n    if denominator == 0:\n        return 0.0\n    return tp / denominator"}
{"task_id": 49, "completion_id": 0, "solution": "import numpy as np\ndef adam_optimizer(f, grad, x0, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08, num_iterations=10):\n    x = np.array(x0, dtype=np.float64)\n    m = np.zeros_like(x)\n    v = np.zeros_like(x)\n    for t in range(1, num_iterations + 1):\n        g = grad(x)\n        m = beta1 * m + (1 - beta1) * g\n        v = beta2 * v + (1 - beta2) * g ** 2\n        m_hat = m / (1 - beta1 ** t)\n        v_hat = v / (1 - beta2 ** t)\n        x = x - learning_rate * m_hat / (np.sqrt(v_hat) + epsilon)\n    x = np.round(x, 4)\n    return x.tolist()"}
{"task_id": 52, "completion_id": 0, "solution": "import numpy as np\ndef recall(y_true, y_pred):\n    y_true = np.array(y_true)\n    y_pred = np.array(y_pred)\n    tp = np.sum((y_true == 1) & (y_pred == 1))\n    fn = np.sum((y_true == 1) & (y_pred == 0))\n    denominator = tp + fn\n    if denominator == 0:\n        return 0.0\n    else:\n        rec = tp / denominator\n        return round(rec, 3)"}
{"task_id": 53, "completion_id": 0, "solution": "import numpy as np\ndef self_attention(X, W_q, W_k, W_v):\n    Q = X @ W_q\n    K = X @ W_k\n    V = X @ W_v\n    scores = Q @ K.T\n    d_k = K.shape[1]\n    scores = scores / np.sqrt(d_k)\n    exp_scores = np.exp(scores - np.max(scores, axis=1, keepdims=True))\n    attention_weights = exp_scores / np.sum(exp_scores, axis=1, keepdims=True)\n    output = attention_weights @ V\n    output = np.round(output, 4)\n    return output.tolist()"}
{"task_id": 54, "completion_id": 0, "solution": "import numpy as np\ndef rnn_forward(input_sequence: list[list[float]], initial_hidden_state: list[float], Wx: list[list[float]], Wh: list[list[float]], b: list[float]) -> list[float]:\n    h = np.array(initial_hidden_state)\n    Wx_np = np.array(Wx)\n    Wh_np = np.array(Wh)\n    b_np = np.array(b)\n    for x in input_sequence:\n        x_t = np.array(x)\n        input_contrib = Wx_np.dot(x_t)\n        hidden_contrib = Wh_np.dot(h)\n        pre_activation = input_contrib + hidden_contrib + b_np\n        h = np.tanh(pre_activation)\n    h_rounded = np.round(h, 4)\n    return h_rounded.tolist()"}
{"task_id": 55, "completion_id": 0, "solution": "import numpy as np\ndef translate_object(points, tx, ty):\n    if not points:\n        return []\n    points_np = np.array(points)\n    homogeneous = np.hstack([points_np, np.ones((points_np.shape[0], 1))])\n    trans_matrix = np.array([[1, 0, tx], [0, 1, ty], [0, 0, 1]])\n    translated = trans_matrix.dot(homogeneous.T)\n    translated_points = translated[:2, :].T\n    return translated_points.tolist()"}
{"task_id": 56, "completion_id": 0, "solution": "import numpy as np\ndef kl_divergence_normal(mu_p, sigma_p, mu_q, sigma_q):\n    delta_mu = mu_p - mu_q\n    term1 = (delta_mu ** 2 + sigma_p ** 2 - sigma_q ** 2) / (2 * sigma_q ** 2)\n    term2 = np.log(sigma_q / sigma_p)\n    return term1 + term2"}
{"task_id": 61, "completion_id": 0, "solution": "import numpy as np\ndef f_score(y_true, y_pred, beta):\n    \"\"\"\n    Calculate F-Score for a binary classification task.\n\n    :param y_true: Numpy array of true labels\n    :param y_pred: Numpy array of predicted labels\n    :param beta: The weight of precision in the harmonic mean\n    :return: F-Score rounded to three decimal places\n    \"\"\"\n    tp = np.sum((y_true == 1) & (y_pred == 1))\n    fp = np.sum((y_true == 0) & (y_pred == 1))\n    fn = np.sum((y_true == 1) & (y_pred == 0))\n    denom_precision = tp + fp\n    precision = tp / denom_precision if denom_precision != 0 else 0.0\n    denom_recall = tp + fn\n    recall = tp / denom_recall if denom_recall != 0 else 0.0\n    numerator = (1 + beta ** 2) * precision * recall\n    denominator = beta ** 2 * precision + recall\n    if denominator == 0:\n        f = 0.0\n    else:\n        f = numerator / denominator\n    return round(f, 3)"}
{"task_id": 63, "completion_id": 0, "solution": ""}
{"task_id": 64, "completion_id": 0, "solution": "import numpy as np\ndef gini_impurity(y: list[int]) -> float:\n    \"\"\"\n    Calculate Gini Impurity for a list of class labels.\n\n    :param y: List of class labels\n    :return: Gini Impurity rounded to three decimal places\n    \"\"\"\n    if not y:\n        return 0.0\n    (unique, counts) = np.unique(y, return_counts=True)\n    total = len(y)\n    sum_sq = 0.0\n    for count in counts:\n        p = count / total\n        sum_sq += p ** 2\n    gini = 1 - sum_sq\n    return round(gini, 3)"}
{"task_id": 65, "completion_id": 0, "solution": "def compressed_row_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix to its Compressed Row Sparse (CSR) representation.\n\n    :param dense_matrix: 2D list representing a dense matrix\n    :return: A tuple containing (values array, column indices array, row pointer array)\n    \"\"\"\n    values = []\n    col_indices = []\n    row_pointers = [0]\n    for row in dense_matrix:\n        non_zero = []\n        cols = []\n        for (idx, val) in enumerate(row):\n            if val != 0:\n                non_zero.append(val)\n                cols.append(idx)\n        count = len(non_zero)\n        row_pointers.append(row_pointers[-1] + count)\n        values.extend(non_zero)\n        col_indices.extend(cols)\n    return (values, col_indices, row_pointers)"}
{"task_id": 66, "completion_id": 0, "solution": "def orthogonal_projection(v, L):\n    \"\"\"\n    Compute the orthogonal projection of vector v onto line L.\n\n    :param v: The vector to be projected\n    :param L: The line vector defining the direction of projection\n    :return: List representing the projection of v onto L\n    \"\"\"\n    dot_product = sum((x * y for (x, y) in zip(v, L)))\n    squared_magnitude = sum((x ** 2 for x in L))\n    t = dot_product / squared_magnitude\n    projection = [t * x for x in L]\n    return [round(num, 3) for num in projection]"}
{"task_id": 67, "completion_id": 0, "solution": "def compressed_col_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix into its Compressed Column Sparse (CSC) representation.\n\n    :param dense_matrix: List of lists representing the dense matrix\n    :return: Tuple of (values, row indices, column pointer)\n    \"\"\"\n    rows = len(dense_matrix)\n    if rows == 0:\n        return ([], [], [0])\n    cols = len(dense_matrix[0])\n    values = []\n    row_indices = []\n    column_pointer = [0]\n    for j in range(cols):\n        for i in range(rows):\n            val = dense_matrix[i][j]\n            if val != 0:\n                values.append(val)\n                row_indices.append(i)\n        column_pointer.append(len(values))\n    return (values, row_indices, column_pointer)"}
{"task_id": 69, "completion_id": 0, "solution": "import numpy as np\ndef r_squared(y_true, y_pred):\n    mean_y = np.mean(y_true)\n    tss = np.sum((y_true - mean_y) ** 2)\n    rss = np.sum((y_true - y_pred) ** 2)\n    if tss == 0:\n        if np.all(y_pred == y_true):\n            return 1.0\n        else:\n            return 0.0\n    else:\n        r_sq = 1 - rss / tss\n        return round(r_sq, 3)"}
{"task_id": 70, "completion_id": 0, "solution": "def calculate_brightness(img):\n    if not img:\n        return -1\n    for row in img:\n        if not row:\n            return -1\n    row_length = len(img[0])\n    for row in img:\n        if len(row) != row_length:\n            return -1\n    for row in img:\n        for pixel in row:\n            if pixel < 0 or pixel > 255:\n                return -1\n    total = 0\n    count = 0\n    for row in img:\n        total += sum(row)\n        count += len(row)\n    average = total / count\n    return round(average, 2)"}
{"task_id": 71, "completion_id": 0, "solution": "import numpy as np\ndef rmse(y_true, y_pred):\n    if not (isinstance(y_true, (list, np.ndarray)) and isinstance(y_pred, (list, np.ndarray))):\n        raise ValueError('Invalid input type. y_true and y_pred must be lists or numpy arrays.')\n    y_true = np.array(y_true)\n    y_pred = np.array(y_pred)\n    if not (np.issubdtype(y_true.dtype, np.number) and np.issubdtype(y_pred.dtype, np.number)):\n        raise ValueError('y_true and y_pred must contain numeric values.')\n    if y_true.shape != y_pred.shape:\n        raise ValueError('y_true and y_pred must have the same shape.')\n    if y_true.size == 0:\n        raise ValueError('y_true and y_pred cannot be empty.')\n    squared_diff = (y_true - y_pred) ** 2\n    mean_squared = np.mean(squared_diff)\n    rmse_value = np.sqrt(mean_squared)\n    return round(rmse_value, 3)"}
{"task_id": 72, "completion_id": 0, "solution": "import numpy as np\ndef jaccard_index(y_true, y_pred):\n    y_true = np.array(y_true)\n    y_pred = np.array(y_pred)\n    intersection = np.sum(y_true * y_pred)\n    union = np.sum(y_true | y_pred)\n    if union == 0:\n        return 1.0\n    else:\n        jaccard = intersection / union\n        return round(jaccard, 3)"}
{"task_id": 73, "completion_id": 0, "solution": "import numpy as np\ndef dice_score(y_true, y_pred):\n    intersection = np.sum(y_true * y_pred)\n    sum_true = np.sum(y_true)\n    sum_pred = np.sum(y_pred)\n    denominator = sum_true + sum_pred\n    if denominator == 0:\n        return 1.0\n    else:\n        dice = 2 * intersection / denominator\n    return round(dice, 3)"}
{"task_id": 75, "completion_id": 0, "solution": "from collections import Counter\ndef confusion_matrix(data):\n    unique_labels = sorted({y for pair in data for y in pair})\n    if len(unique_labels) != 2:\n        raise ValueError('Data must be binary classification')\n    counts = Counter()\n    for (y_true, y_pred) in data:\n        counts[y_true, y_pred] += 1\n    matrix = []\n    for true_label in unique_labels:\n        row = []\n        for pred_label in unique_labels:\n            row.append(counts.get((true_label, pred_label), 0))\n        matrix.append(row)\n    return matrix"}
{"task_id": 76, "completion_id": 0, "solution": "import numpy as np\ndef cosine_similarity(v1, v2):\n    dot_product = np.dot(v1, v2)\n    norm_v1 = np.linalg.norm(v1)\n    norm_v2 = np.linalg.norm(v2)\n    similarity = dot_product / (norm_v1 * norm_v2)\n    return round(similarity, 3)"}
{"task_id": 78, "completion_id": 0, "solution": "import numpy as np\ndef descriptive_statistics(data):\n    data = np.array(data)\n    mean = np.mean(data)\n    median = np.median(data)\n    mode = np.mode(data).mode[0]\n    variance = np.var(data)\n    std_dev = np.std(data)\n    percentiles = np.percentile(data, [25, 50, 75])\n    iqr = percentiles[2] - percentiles[0]\n    mean = round(mean, 4)\n    median = round(median, 4)\n    variance = round(variance, 4)\n    std_dev = round(std_dev, 4)\n    p25 = round(percentiles[0], 4)\n    p50 = round(percentiles[1], 4)\n    p75 = round(percentiles[2], 4)\n    iqr = round(iqr, 4)\n    result = {'mean': mean, 'median': median, 'mode': mode, 'variance': variance, 'standard_deviation': std_dev, '25th_percentile': p25, '50th_percentile': p50, '75th_percentile': p75, 'interquartile_range': iqr}\n    return result"}
{"task_id": 79, "completion_id": 0, "solution": "import math\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Calculate the probability of achieving exactly k successes in n independent Bernoulli trials,\n    each with probability p of success, using the Binomial distribution formula.\n    :param n: Total number of trials\n    :param k: Number of successes\n    :param p: Probability of success on each trial\n    :return: Probability of k successes in n trials, rounded to five decimal places\n    \"\"\"\n    combination = math.comb(n, k)\n    probability = combination * p ** k * (1 - p) ** (n - k)\n    return round(probability, 5)"}
{"task_id": 80, "completion_id": 0, "solution": "import math\ndef normal_pdf(x, mean, std_dev):\n    \"\"\"\n    Calculate the probability density function (PDF) of the normal distribution.\n    :param x: The value at which the PDF is evaluated.\n    :param mean: The mean (\u03bc) of the distribution.\n    :param std_dev: The standard deviation (\u03c3) of the distribution.\n    \"\"\"\n    exponent = -(x - mean) ** 2 / (2 * std_dev ** 2)\n    denominator = std_dev * math.sqrt(2 * math.pi)\n    pdf = 1 / denominator * math.exp(exponent)\n    return round(pdf, 5)"}
{"task_id": 81, "completion_id": 0, "solution": "import math\ndef poisson_probability(k, lam):\n    \"\"\"\n    Calculate the probability of observing exactly k events in a fixed interval,\n    given the mean rate of events lam, using the Poisson distribution formula.\n    :param k: Number of events (non-negative integer)\n    :param lam: The average rate (mean) of occurrences in a fixed interval\n    \"\"\"\n    probability = lam ** k * math.exp(-lam) / math.factorial(k)\n    return round(probability, 5)"}
{"task_id": 82, "completion_id": 0, "solution": "import numpy as np\ndef calculate_contrast(img):\n    \"\"\"\n    Calculate the contrast of a grayscale image.\n    Args:\n        img (numpy.ndarray): 2D array representing a grayscale image with pixel values between 0 and 255.\n    \"\"\"\n    max_val = np.max(img)\n    min_val = np.min(img)\n    return max_val - min_val"}
{"task_id": 83, "completion_id": 0, "solution": "import numpy as np\ndef calculate_dot_product(vec1, vec2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Args:\n        vec1 (numpy.ndarray): 1D array representing the first vector.\n        vec2 (numpy.ndarray): 1D array representing the second vector.\n    \"\"\"\n    return np.dot(vec1, vec2)"}
{"task_id": 84, "completion_id": 0, "solution": "def phi_transform(data: list[float], degree: int):\n    \"\"\"\n    Perform a Phi Transformation to map input features into a higher-dimensional space by generating polynomial features.\n\n    Args:\n        data (list[float]): A list of numerical values to transform.\n        degree (int): The degree of the polynomial expansion.\n    \"\"\"\n    if degree < 0:\n        return []\n    return [[round(x ** d, 8) for d in range(degree + 1)] for x in data]"}
{"task_id": 85, "completion_id": 0, "solution": "import numpy as np\ndef pos_encoding(position: int, d_model: int):\n    if position == 0 or d_model <= 0:\n        return -1\n    pe = np.zeros(d_model, dtype=np.float64)\n    for j in range(d_model):\n        if j % 2 == 0:\n            i = j // 2\n            exponent = 2 * i / d_model\n            denominator = 10000 ** exponent\n            pe[j] = np.sin(position / denominator)\n        else:\n            i = (j - 1) // 2\n            exponent = 2 * i / d_model\n            denominator = 10000 ** exponent\n            pe[j] = np.cos(position / denominator)\n    pe = pe.astype(np.float16)\n    return pe.tolist()"}
{"task_id": 86, "completion_id": 0, "solution": "def model_fit_quality(training_accuracy, test_accuracy):\n    \"\"\"\n    Determine if the model is overfitting, underfitting, or a good fit based on training and test accuracy.\n    :param training_accuracy: float, training accuracy of the model (0 <= training_accuracy <= 1)\n    :param test_accuracy: float, test accuracy of the model (0 <= test_accuracy <= 1)\n    :return: int, one of '1', '-1', or '0'.\n    \"\"\"\n    if training_accuracy - test_accuracy > 0.2:\n        return 1\n    elif training_accuracy < 0.7 and test_accuracy < 0.7:\n        return -1\n    else:\n        return 0"}
{"task_id": 87, "completion_id": 0, "solution": "import numpy as np"}
{"task_id": 90, "completion_id": 0, "solution": "import numpy as np\nfrom collections import Counter\ndef calculate_bm25_scores(corpus, query, k1=1.5, b=0.75):\n    processed_corpus = []\n    doc_freq = Counter()\n    doc_lengths = []\n    for doc in corpus:\n        words = doc.lower().split()\n        doc_lengths.append(len(words))\n        word_counts = Counter(words)\n        processed_corpus.append(word_counts)\n        for word in word_counts:\n            doc_freq[word] += 1\n    avgdl = np.mean(doc_lengths) if doc_lengths else 0\n    query_words = query.lower().split()\n    scores = []\n    for (i, doc_counts) in enumerate(processed_corpus):\n        score = 0.0\n        doc_length = doc_lengths[i]\n        denominator_part = k1 * (1 - b + b * (doc_length / avgdl)) if avgdl != 0 else 0\n        for word in query_words:\n            if word not in doc_counts:\n                continue\n            tf = doc_counts[word]\n            df = doc_freq[word]\n            n = len(corpus)\n            numerator = (k1 + 1) * tf\n            denominator = denominator_part + tf\n            term1 = numerator / denominator if denominator != 0 else 0\n            term2 = np.log((n - df + 0.5) / (df + 0.5)) if df + 0.5 != 0 else 0\n            score += term1 * term2\n        scores.append(round(score, 3))\n    return scores"}
{"task_id": 91, "completion_id": 0, "solution": "def calculate_f1_score(y_true, y_pred):\n    \"\"\"\n    Calculate the F1 score based on true and predicted labels.\n\n    Args:\n        y_true (list): True labels (ground truth).\n        y_pred (list): Predicted labels.\n\n    Returns:\n        float: The F1 score rounded to three decimal places.\n    \"\"\"\n    TP = 0\n    FP = 0\n    FN = 0\n    for (yt, yp) in zip(y_true, y_pred):\n        if yt == 1 and yp == 1:\n            TP += 1\n        elif yt == 0 and yp == 1:\n            FP += 1\n        elif yt == 1 and yp == 0:\n            FN += 1\n    if TP + FP == 0:\n        precision = 0.0\n    else:\n        precision = TP / (TP + FP)\n    if TP + FN == 0:\n        recall = 0.0\n    else:\n        recall = TP / (TP + FN)\n    if precision + recall == 0:\n        f1 = 0.0\n    else:\n        f1 = 2 * (precision * recall) / (precision + recall)\n    return round(f1, 3)"}
{"task_id": 93, "completion_id": 0, "solution": "import numpy as np\ndef mae(y_true, y_pred):\n    \"\"\"\n    Calculate Mean Absolute Error between two arrays.\n\n    Parameters:\n    y_true (numpy.ndarray): Array of true values\n    y_pred (numpy.ndarray): Array of predicted values\n\n    Returns:\n    float: Mean Absolute Error rounded to 3 decimal places\n    \"\"\"\n    return round(np.mean(np.abs(y_true - y_pred)), 3)"}
{"task_id": 95, "completion_id": 0, "solution": "import math\ndef phi_corr(x: list[int], y: list[int]) -> float:\n    \"\"\"\n    Calculate the Phi coefficient between two binary variables.\n\n    Args:\n    x (list[int]): A list of binary values (0 or 1).\n    y (list[int]): A list of binary values (0 or 1).\n\n    Returns:\n    float: The Phi coefficient rounded to 4 decimal places.\n    \"\"\"\n    if len(x) != len(y):\n        raise ValueError('x and y must be of the same length')\n    a = b = c = d = 0\n    for (xi, yi) in zip(x, y):\n        if xi == 1 and yi == 1:\n            a += 1\n        elif xi == 1 and yi == 0:\n            b += 1\n        elif xi == 0 and yi == 1:\n            c += 1\n        else:\n            d += 1\n    numerator = a * d - b * c\n    denominator = math.sqrt((a + b) * (c + d) * (a + c) * (b + d))\n    if denominator == 0:\n        return 0.0\n    phi = numerator / denominator\n    return round(phi, 4)"}
{"task_id": 96, "completion_id": 0, "solution": "def hard_sigmoid(x: float) -> float:\n    \"\"\"\n    Implements the Hard Sigmoid activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Hard Sigmoid of the input\n    \"\"\"\n    if x < -2.5:\n        return 0.0\n    elif x > 2.5:\n        return 1.0\n    else:\n        return (x + 2.5) / 5.0"}
{"task_id": 97, "completion_id": 0, "solution": "import math\ndef elu(x: float, alpha: float=1.0) -> float:\n    \"\"\"\n    Compute the ELU activation function.\n\n    Args:\n        x (float): Input value\n        alpha (float): ELU parameter for negative values (default: 1.0)\n\n    Returns:\n        float: ELU activation value rounded to four decimal places\n    \"\"\"\n    if x >= 0:\n        result = x\n    else:\n        result = alpha * (math.exp(x) - 1)\n    return round(result, 4)"}
{"task_id": 98, "completion_id": 0, "solution": "def prelu(x: float, alpha: float=0.25) -> float:\n    \"\"\"\n    Implements the PReLU (Parametric ReLU) activation function.\n\n    Args:\n        x: Input value\n        alpha: Slope parameter for negative values (default: 0.25)\n\n    Returns:\n        float: PReLU activation value\n    \"\"\"\n    if x < 0:\n        return alpha * x\n    else:\n        return x"}
{"task_id": 99, "completion_id": 0, "solution": "import math\ndef softplus(x: float) -> float:\n    \"\"\"\n    Compute the softplus activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The softplus value: log(1 + e^x), rounded to 4 decimal places.\n    \"\"\"\n    if x > 20:\n        return round(x, 4)\n    elif x < -20:\n        return 0.0\n    else:\n        result = math.log(1 + math.exp(x))\n        return round(result, 4)"}
{"task_id": 100, "completion_id": 0, "solution": "def softsign(x: float) -> float:\n    \"\"\"\n    Implements the Softsign activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Softsign of the input, rounded to four decimal places.\n    \"\"\"\n    return round(x / (1 + abs(x)), 4)"}
{"task_id": 102, "completion_id": 0, "solution": "import math\ndef swish(x: float) -> float:\n    \"\"\"\n    Implements the Swish activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The Swish activation value, rounded to the nearest 4th decimal.\n    \"\"\"\n    sigmoid = 1 / (1 + math.exp(-x))\n    result = x * sigmoid\n    return round(result, 4)"}
{"task_id": 103, "completion_id": 0, "solution": "import math\ndef selu(x: float) -> float:\n    \"\"\"\n    Implements the SELU (Scaled Exponential Linear Unit) activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        SELU activation value rounded to four decimal places.\n    \"\"\"\n    alpha = 1.6732632423543772\n    scale = 1.0507009873554805\n    if x > 0:\n        result = scale * x\n    else:\n        result = scale * alpha * (math.exp(x) - 1)\n    return round(result, 4)"}
{"task_id": 104, "completion_id": 0, "solution": "import numpy as np\ndef predict_logistic(X: np.ndarray, weights: np.ndarray, bias: float) -> list:\n    \"\"\"\n    Implements binary classification prediction using Logistic Regression.\n\n    Args:\n        X: Input feature matrix (shape: N x D)\n        weights: Model weights (shape: D)\n        bias: Model bias\n\n    Returns:\n        Binary predictions (0 or 1)\n    \"\"\"\n    z = np.dot(X, weights) + bias\n    probabilities = 1 / (1 + np.exp(-z))\n    predictions = (probabilities >= 0.5).astype(int)\n    return predictions.tolist()"}
{"task_id": 107, "completion_id": 0, "solution": "import numpy as np\ndef masked_attention(Q: np.ndarray, K: np.ndarray, V: np.ndarray, mask: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute masked self-attention.\n    \"\"\"\n    scores = np.einsum('bik, bjk -> bij', Q, K)\n    d_k = K.shape[-1]\n    scores = scores / np.sqrt(d_k)\n    mask = mask.astype(scores.dtype)\n    scores = scores + (1 - mask) * -1000000000.0\n    attention_weights = np.exp(scores)\n    attention_weights = attention_weights / np.sum(attention_weights, axis=-1, keepdims=True)\n    output = np.einsum('bij, bjk -> bik', attention_weights, V)\n    return output.tolist()"}
{"task_id": 108, "completion_id": 0, "solution": "from collections import Counter\nimport math\ndef disorder(apples: list) -> float:\n    \"\"\"\n    Calculates a measure of disorder in a basket of apples based on their colors.\n    \"\"\"\n    if not apples:\n        return 0.0\n    counts = Counter(apples)\n    total = len(apples)\n    entropy = 0.0\n    for count in counts.values():\n        p = count / total\n        entropy += p * math.log2(p)\n    entropy = -entropy\n    return round(entropy, 4)"}
{"task_id": 109, "completion_id": 0, "solution": "import numpy as np\ndef layer_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float=1e-05):\n    mean = X.mean(axis=2, keepdims=True)\n    var = ((X - mean) ** 2).mean(axis=2, keepdims=True)\n    denominator = np.sqrt(var + epsilon)\n    normalized = (X - mean) / denominator\n    output = gamma * normalized + beta\n    return output.round(5).tolist()"}
{"task_id": 111, "completion_id": 0, "solution": "import numpy as np\ndef compute_pmi(joint_counts, total_counts_x, total_counts_y, total_samples):\n    ratio = joint_counts * total_samples / (total_counts_x * total_counts_y)\n    pmi = np.log(ratio)\n    return round(pmi, 3)"}
{"task_id": 112, "completion_id": 0, "solution": "def min_max(x: list[int]) -> list[float]:\n    min_val = min(x)\n    max_val = max(x)\n    if max_val == min_val:\n        return [0.0 for _ in x]\n    normalized = [(num - min_val) / (max_val - min_val) for num in x]\n    return [round(num, 4) for num in normalized]"}
{"task_id": 113, "completion_id": 0, "solution": "import numpy as np\ndef residual_block(x: np.ndarray, w1: np.ndarray, w2: np.ndarray):\n    y1 = x.dot(w1)\n    y1_relu = np.maximum(y1, 0)\n    y2 = y1_relu.dot(w2)\n    y_add = y2 + x\n    y_final = np.maximum(y_add, 0)\n    return y_final.round(4).tolist()"}
{"task_id": 114, "completion_id": 0, "solution": "import numpy as np\ndef global_avg_pool(x: np.ndarray):\n    return x.mean(axis=(0, 1))"}
{"task_id": 115, "completion_id": 0, "solution": "import numpy as np\ndef batch_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float=1e-05):\n    mean = X.mean(axis=(0, 2, 3))\n    var = X.var(axis=(0, 2, 3))\n    normalized = (X - mean) / np.sqrt(var + epsilon)\n    output = gamma * normalized + beta\n    return np.round(output, decimals=4).tolist()"}
{"task_id": 116, "completion_id": 0, "solution": "def poly_term_derivative(c: float, x: float, n: float) -> float:\n    if n == 0:\n        return round(0.0, 4)\n    else:\n        derivative = c * n * x ** (n - 1)\n        return round(derivative, 4)"}
{"task_id": 117, "completion_id": 0, "solution": "import numpy as np\ndef orthonormal_basis(vectors: list[list[float]], tol: float=1e-10):\n    basis = []\n    for v in vectors:\n        current = np.array(v)\n        for e in basis:\n            proj = current.dot(e) * e\n            current -= proj\n        norm = np.linalg.norm(current)\n        if norm > tol:\n            e = current / norm\n            basis.append(e)\n    rounded_basis = [np.round(vec, 4).tolist() for vec in basis]\n    return rounded_basis"}
{"task_id": 118, "completion_id": 0, "solution": "import numpy as np\ndef cross_product(a, b):\n    cross = np.cross(a, b)\n    cross_rounded = np.round(cross, 4)\n    return cross_rounded.tolist()"}
{"task_id": 119, "completion_id": 0, "solution": "import numpy as np\ndef cramers_rule(A, b):\n    det_A = np.linalg.det(A)\n    if abs(det_A) < 1e-10:\n        return -1\n    n = A.shape[0]\n    x = []\n    for i in range(n):\n        A_i = A.copy()\n        A_i[:, i] = b\n        det_Ai = np.linalg.det(A_i)\n        x_i = det_Ai / det_A\n        x.append(round(x_i, 4))\n    return x"}
{"task_id": 120, "completion_id": 0, "solution": "import numpy as np\ndef bhattacharyya_distance(p: list[float], q: list[float]) -> float:\n    if len(p) != len(q) or len(p) == 0:\n        return 0.0\n    product = np.multiply(p, q)\n    sqrt_product = np.sqrt(product)\n    sum_sqrt = np.sum(sqrt_product)\n    ln_sum = np.log(sum_sqrt)\n    distance = -ln_sum\n    return round(distance, 4)"}
{"task_id": 121, "completion_id": 0, "solution": "def vector_sum(a: list[int | float], b: list[int | float]) -> list[int | float]:\n    if len(a) != len(b):\n        return -1\n    result = []\n    for i in range(len(a)):\n        result.append(a[i] + b[i])\n    return result"}
{"task_id": 122, "completion_id": 0, "solution": "import numpy as np"}
{"task_id": 126, "completion_id": 0, "solution": "import numpy as np\ndef group_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, num_groups: int, epsilon: float=1e-05):\n    (B, C, H, W) = X.shape\n    G = C // num_groups\n    X_grouped = X.reshape(B, num_groups, G, H, W)\n    mean = np.mean(X_grouped, axis=(2, 3, 4), keepdims=True)\n    var = np.var(X_grouped, axis=(2, 3, 4), keepdims=True)\n    X_grouped = (X_grouped - mean) / np.sqrt(var + epsilon)\n    X_normalized = X_grouped.reshape(B, C, H, W)\n    out = gamma * X_normalized + beta\n    out = np.round(out, decimals=4)\n    return out.tolist()"}
{"task_id": 128, "completion_id": 0, "solution": "import numpy as np\ndef dynamic_tanh(x: np.ndarray, alpha: float, gamma: float, beta: float) -> list[float]:\n    scaled_x = alpha * x\n    tanh_x = np.tanh(scaled_x)\n    result = gamma * tanh_x + beta\n    rounded_result = np.round(result, 4)\n    return rounded_result.tolist()"}
