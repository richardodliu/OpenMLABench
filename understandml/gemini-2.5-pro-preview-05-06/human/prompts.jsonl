{"task_id": 1, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Matrix-Vector Dot Product\n# Description:\nWrite a Python function that computes the dot product of a matrix and a vector. The function should return a list representing the resulting vector if the operation is valid, or -1 if the matrix and vector dimensions are incompatible. A matrix (a list of lists) can be dotted with a vector (a list) only if the number of columns in the matrix equals the length of the vector. For example, an n x m matrix requires a vector of length m.\n# Your code should start with:\n```python\ndef matrix_dot_vector(a: list[list[int|float]], b: list[int|float]) -> list[int|float]:\n```\n# Output Constraints:\nYour code should return a list where each element is the dot product of a row of 'a' with 'b'. If the number of columns in 'a' does not match the length of 'b', return -1.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 2, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Transpose of a Matrix\n# Description:\nWrite a Python function that computes the transpose of a given matrix.\n# Your code should start with:\n```python\ndef transpose_matrix(a: list[list[int|float]]) -> list[list[int|float]]:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 3, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Reshape Matrix\n# Description:\nWrite a Python function that reshapes a given matrix into a specified shape. if it can not be reshaped return back an empty list \"[]\".\n# Your code should start with:\n```python\nimport numpy as np\ndef reshape_matrix(a: list[list[int|float]], new_shape: tuple[int, int]) -> list[list[int|float]]:\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 4, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Mean by Row or Column\n# Description:\nWrite a Python function that calculates the mean of a matrix either by row or by column, based on a given mode. The function should take a matrix (list of lists) and a mode ('row' or 'column') as input and return a list of means according to the specified mode.\n# Your code should start with:\n```python\ndef calculate_matrix_mean(matrix: list[list[float]], mode: str) -> list[float]:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 5, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Scalar Multiplication of a Matrix\n# Description:\nWrite a Python function that multiplies a matrix by a scalar and returns the result.\n# Your code should start with:\n```python\ndef scalar_multiply(matrix: list[list[int|float]], scalar: int|float) -> list[list[int|float]]:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 6, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Eigenvalues of a Matrix\n# Description:\nWrite a Python function that calculates the eigenvalues of a 2x2 matrix. The function should return a list containing the eigenvalues, sort values from highest to lowest.\n# Your code should start with:\n```python\ndef calculate_eigenvalues(matrix: list[list[float|int]]) -> list[float]:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 7, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Matrix Transformation\n# Description:\nWrite a Python function that transforms a given matrix $A$ using the operation $T^{-1}AS$, where $T$ and $S$ are invertible matrices. The function should first validate if the matrices $T$ and $S$ are invertible, and then perform the transformation. In cases where there is no solution return -1.\n# Your code should start with:\n```python\nimport numpy as np\ndef transform_matrix(A: list[list[int|float]], T: list[list[int|float]], S: list[list[int|float]]) -> list[list[int|float]]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 8, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate 2x2 Matrix Inverse\n# Description:\nWrite a Python function that calculates the inverse of a 2x2 matrix. Return 'None' if the matrix is not invertible.\n# Your code should start with:\n```python\ndef inverse_2x2(matrix: list[list[float]]) -> list[list[float]]:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 9, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Matrix times Matrix\n# Description:\nWrite a Python function that multiplies two matrices. If the matrices cannot be multiplied, return -1.\n# Your code should start with:\n```python\ndef matrixmul(a:list[list[int|float]], b:list[list[int|float]])-> list[list[int|float]]:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 10, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Covariance Matrix\n# Description:\nWrite a Python function to calculate the covariance matrix for a given set of vectors. The function should take a list of lists, where each inner list represents a feature with its observations, and return a covariance matrix as a list of lists. Additionally, provide test cases to verify the correctness of your implementation.\n# Your code should start with:\n```python\ndef calculate_covariance_matrix(vectors: list[list[float]]) -> list[list[float]]:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 11, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Solve Linear Equations using Jacobi Method\n# Description:\nWrite a Python function that uses the Jacobi method to solve a system of linear equations given by Ax = b. The function should iterate n times, rounding each intermediate solution to four decimal places, and return the approximate solution x.\n# Your code should start with:\n```python\nimport numpy as np\ndef solve_jacobi(A: np.ndarray, b: np.ndarray, n: int) -> list:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 12, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Singular Value Decomposition (SVD)\n# Description:\nWrite a Python function that approximates the Singular Value Decomposition on a 2x2 matrix by using the jacobian method and without using numpy svd function, i mean you could but you wouldn't learn anything. return the result in this format.\n# Your code should start with:\n```python\nimport numpy as np\ndef svd_2x2_singular_values(A: np.ndarray) -> tuple:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 13, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Determinant of a 4x4 Matrix using Laplace's Expansion\n# Description:\nWrite a Python function that calculates the determinant of a 4x4 matrix using Laplace's Expansion method. The function should take a single argument, a 4x4 matrix represented as a list of lists, and return the determinant of the matrix. The elements of the matrix can be integers or floating-point numbers. Implement the function recursively to handle the computation of determinants for the 3x3 minor matrices.\n# Your code should start with:\n```python\ndef determinant_4x4(matrix: list[list[int|float]]) -> float:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 14, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Linear Regression Using Normal Equation\n# Description:\nWrite a Python function that performs linear regression using the normal equation. The function should take a matrix X (features) and a vector y (target) as input, and return the coefficients of the linear regression model. Round your answer to four decimal places, -0.0 is a valid result for rounding a very small number.\n# Your code should start with:\n```python\nimport numpy as np\ndef linear_regression_normal_equation(X: list[list[float]], y: list[float]) -> list[float]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 15, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Linear Regression Using Gradient Descent\n# Description:\nWrite a Python function that performs linear regression using gradient descent. The function should take NumPy arrays X (features with a column of ones for the intercept) and y (target) as input, along with learning rate alpha and the number of iterations, and return the coefficients of the linear regression model as a list. Round your answer to four decimal places. -0.0 is a valid result for rounding a very small number.\n# Your code should start with:\n```python\nimport numpy as np\ndef linear_regression_gradient_descent(X: np.ndarray, y: np.ndarray, alpha: float, iterations: int) -> np.ndarray:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 16, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Feature Scaling Implementation\n# Description:\nWrite a Python function that performs feature scaling on a dataset using both standardization and min-max normalization. The function should take a 2D NumPy array as input, where each row represents a data sample and each column represents a feature. It should return two 2D lists: one scaled by standardization and one by min-max normalization.\n# Your code should start with:\n```python\nimport numpy as np\ndef feature_scaling(data: np.ndarray) -> (list[list[float]], list[list[float]]):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 17, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Polynomial Regression using Normal Equation\n# Description:\nWrite a Python function that implements the k-Means clustering algorithm. This function should take specific inputs and produce a list of final centroids. k-Means clustering is a method used to partition n points into k clusters. The goal is to group similar points together and represent each group by its center (called the centroid).\nFunction Inputs:\n- points: A list of points, where each point is a tuple of coordinates (e.g., (x, y) for 2D points)\n- k: An integer representing the number of clusters to form\n- initial_centroids: A list of initial centroid points, each a tuple of coordinates\n- max_iterations: An integer representing the maximum number of iterations to perform\nFunction Output:\n- A list of the final centroids of the clusters, where each centroid is rounded to the nearest fourth decimal.\n# Your code should start with:\n```python\nimport numpy as np\ndef k_means_clustering(points: list[tuple[float, float]], k: int, initial_centroids: list[tuple[float, float]], max_iterations: int) -> list[tuple[float, float]]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 18, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement K-Fold Cross-Validation\n# Description:\nWrite a Python function to generate train and test splits for K-Fold Cross-Validation. Your task is to divide the dataset into k folds and return a list of train-test indices for each fold.\n# Your code should start with:\n```python\nimport numpy as np\ndef k_fold_cross_validation(X: np.ndarray, y: np.ndarray, k=5, shuffle=True, random_seed=None):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 19, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Principal Component Analysis (PCA) Implementation\n# Description:\nWrite a Python function that performs Principal Component Analysis (PCA) from scratch. The function should take a 2D NumPy array as input, where each row represents a data sample and each column represents a feature. The function should standardize the dataset, compute the covariance matrix, find the eigenvalues and eigenvectors, and return the principal components (the eigenvectors corresponding to the largest eigenvalues). The function should also take an integer k as input, representing the number of principal components to return.\n# Your code should start with:\n```python\nimport numpy as np\ndef pca(data: np.ndarray, k: int) -> list[list[float]]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 20, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Decision Tree Learning\n# Description:\nWrite a Python function that implements the decision tree learning algorithm for classification. The function should use recursive binary splitting based on entropy and information gain to build a decision tree. It should take a list of examples (each example is a dict of attribute-value pairs) and a list of attribute names as input, and return a nested dictionary representing the decision tree.\n# Your code should start with:\n```python\nimport math\nfrom collections import Counter\ndef learn_decision_tree(examples: list[dict], attributes: list[str], target_attr: str) -> dict:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 21, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Pegasos Kernel SVM Implementation\n# Description:\nWrite a Python function that implements a deterministic version of the Pegasos algorithm to train a kernel SVM classifier from scratch. The function should take a dataset (as a 2D NumPy array where each row represents a data sample and each column represents a feature), a label vector (1D NumPy array where each entry corresponds to the label of the sample), and training parameters such as the choice of kernel (linear or RBF), regularization parameter (lambda), and the number of iterations. Note that while the original Pegasos algorithm is stochastic (it selects a single random sample at each step), this problem requires using all samples in every iteration (i.e., no random sampling). The function should perform binary classification and return the model's alpha coefficients and bias.\n# Your code should start with:\n```python\nimport numpy as np\ndef pegasos_kernel_svm(data: np.ndarray, labels: np.ndarray, kernel='linear', lambda_val=0.01, iterations=100, sigma=1.0):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 22, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Sigmoid Activation Function Understanding\n# Description:\nWrite a Python function that computes the output of the sigmoid activation function given an input value z. The function should return the output rounded to four decimal places.\n# Your code should start with:\n```python\nimport math\ndef sigmoid(z: float) -> float:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 23, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Softmax Activation Function Implementation\n# Description:\nWrite a Python function that computes the softmax activation for a given list of scores. The function should return the softmax values as a list, each rounded to four decimal places.\n# Your code should start with:\n```python\nimport math\ndef softmax(scores: list[float]) -> list[float]:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 24, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Single Neuron\n# Description:\nWrite a Python function that simulates a single neuron with a sigmoid activation function for binary classification, handling multidimensional input features. The function should take a list of feature vectors (each vector representing multiple features for an example), associated true binary labels, and the neuron's weights (one for each feature) and bias as input. It should return the predicted probabilities after sigmoid activation and the mean squared error between the predicted probabilities and the true labels, both rounded to four decimal places.\n# Your code should start with:\n```python\nimport math\ndef single_neuron_model(features: list[list[float]], labels: list[int], weights: list[float], bias: float) -> (list[float], float):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 25, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Single Neuron with Backpropagation\n# Description:\nWrite a Python function that simulates a single neuron with sigmoid activation, and implements backpropagation to update the neuron's weights and bias. The function should take a list of feature vectors, associated true binary labels, initial weights, initial bias, a learning rate, and the number of epochs. The function should update the weights and bias using gradient descent based on the MSE loss, and return the updated weights, bias, and a list of MSE values for each epoch, each rounded to four decimal places.\n# Your code should start with:\n```python\nimport numpy as np\ndef train_neuron(features: np.ndarray, labels: np.ndarray, initial_weights: np.ndarray, initial_bias: float, learning_rate: float, epochs: int) -> (np.ndarray, float, list[float]):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 26, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implementing Basic Autograd Operations\n# Description:\nWrite a Python class similar to the provided 'Value' class that implements the basic autograd operations: addition, multiplication, and ReLU activation. The class should handle scalar values and should correctly compute gradients for these operations through automatic differentiation.\n# Your code should start with:\n```python\nclass Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0\n        self._backward = lambda: None\n        self._prev = set(_children)\n        self._op = _op\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 27, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Transformation Matrix from Basis B to C\n# Description:\nGiven basis vectors in two different bases B and C for R^3, write a Python function to compute the transformation matrix P from basis B to C.\n# Your code should start with:\n```python\nimport numpy as np\ndef transform_basis(B: list[list[int]], C: list[list[int]]) -> list[list[float]]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 28, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: SVD of a 2x2 Matrix using eigen values & vectors\n# Description:\nGiven a 2x2 matrix, write a Python function to compute its Singular Value Decomposition (SVD). The function should return the matrices U, S, and V such that A = U * S * V, use the method based on eigendecomposition of $A^T A$. Specifically:\n- Compute $A^T A$, which is symmetric and positive semi-definite\n- Perform eigendecomposition on $A^T A$ to obtain its eigenvalues and eigenvectors\n- Construct the singular values as the square roots of the eigenvalues, forming the diagonal matrix $S$\n- Use the eigenvectors of $A^T A$ as the columns of $V$\n- Compute $U$ by normalizing $A v_i$ for each non-zero singular value $\\sigma_i$\nThis approach provides a geometrically motivated construction of SVD suitable for small matrices.\n# Your code should start with:\n```python\nimport numpy as np\ndef svd_2x2(A: np.ndarray) -> tuple:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 29, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Random Shuffle of Dataset\n# Description:\nWrite a Python function to perform a random shuffle of the samples in two numpy arrays, X and y, while maintaining the corresponding order between them. The function should have an optional seed parameter for reproducibility.\n# Your code should start with:\n```python\nimport numpy as np\ndef shuffle_data(X, y, seed=None):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 30, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Batch Iterator for Dataset\n# Description:\nImplement a batch iterable function that samples in a numpy array X and an optional numpy array y. The function should yield batches of a specified size. If y is provided, the function should yield batches of (X, y) pairs; otherwise, it should yield batches of X only.\n# Your code should start with:\n```python\nimport numpy as np\ndef batch_iterator(X, y=None, batch_size=64):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 31, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Divide Dataset Based on Feature Threshold\n# Description:\nWrite a Python function to divide a dataset based on whether the value of a specified feature is greater than or equal to a given threshold. The function should return two subsets of the dataset: one with samples that meet the condition and another with samples that do not.\n# Your code should start with:\n```python\nimport numpy as np\ndef divide_on_feature(X, feature_i, threshold):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 32, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Generate Polynomial Features\n# Description:\nWrite a Python function to generate polynomial features for a given dataset. The function should take in a 2D numpy array X and an integer degree, and return a new 2D numpy array with polynomial features up to the specified degree.\n# Your code should start with:\n```python\nimport numpy as np\nfrom itertools import combinations_with_replacement\ndef polynomial_features(X, degree):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 33, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Generate Random Subsets of a Dataset\n# Description:\nWrite a Python function to generate random subsets of a given dataset. The function should take in a 2D numpy array X, a 1D numpy array y, an integer n_subsets, and a boolean replacements. It should return a list of n_subsets random subsets of the dataset, where each subset is a tuple of (X_subset, y_subset). If replacements is True, the subsets should be created with replacements; otherwise, without replacements.\n# Your code should start with:\n```python\nimport numpy as np\ndef get_random_subsets(X, y, n_subsets, replacements=True, seed=42):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 34, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: One-Hot Encoding of Nominal Values\n# Description:\nWrite a Python function to perform one-hot encoding of nominal values. The function should take in a 1D numpy array x of integer values and an optional integer n_col representing the number of columns for the one-hot encoded array. If n_col is not provided, it should be automatically determined from the input array.\n# Your code should start with:\n```python\nimport numpy as np\ndef to_categorical(x, n_col=None):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 35, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Convert Vector to Diagonal Matrix\n# Description:\nWrite a Python function to convert a 1D numpy array into a diagonal matrix. The function should take in a 1D numpy array x and return a 2D numpy array representing the diagonal matrix.\n# Your code should start with:\n```python\nimport numpy as np\ndef make_diagonal(x):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 36, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Accuracy Score\n# Description:\nWrite a Python function to calculate the accuracy score of a model's predictions. The function should take in two 1D numpy arrays: y_true, which contains the true labels, and y_pred, which contains the predicted labels. It should return the accuracy score as a float.\n# Your code should start with:\n```python\nimport numpy as np\ndef accuracy_score(y_true, y_pred):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 37, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Correlation Matrix\n# Description:\nWrite a Python function to calculate the correlation matrix for a given dataset. The function should take in a 2D numpy array X and an optional 2D numpy array Y. If Y is not provided, the function should calculate the correlation matrix of X with itself. It should return the correlation matrix as a 2D numpy array.\n# Your code should start with:\n```python\nimport numpy as np\ndef calculate_correlation_matrix(X, Y=None):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 38, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement AdaBoost Fit Method\n# Description:\nWrite a Python function `adaboost_fit` that implements the fit method for an AdaBoost classifier. The function should take in a 2D numpy array `X` of shape `(n_samples, n_features)` representing the dataset, a 1D numpy array `y` of shape `(n_samples,)` representing the labels, and an integer `n_clf` representing the number of classifiers. The function should initialize sample weights, find the best thresholds for each feature, calculate the error, update weights, and return a list of classifiers with their parameters.\n# Your code should start with:\n```python\nimport numpy as np\nimport math\ndef adaboost_fit(X, y, n_clf):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 39, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implementation of Log Softmax Function\n# Description:\nIn machine learning and statistics, the softmax function is a generalization of the logistic function that converts a vector of scores into probabilities.\nThe log-softmax function is the logarithm of the softmax function, and it is often used for numerical stability when computing the softmax of large numbers.\nGiven a 1D numpy array of scores, implement a Python function to compute the log-softmax of the array.\n# Your code should start with:\n```python\nimport numpy as np\ndef log_softmax(scores: list):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 40, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implementing a Custom Dense Layer in Python\n# Description:\nYou are provided with a base `Layer` class that defines the structure of a neural network layer.\nThe `Dense` class represents a fully connected neural network layer and extend the `Layer` class with the `__init__` method:\n- Define the layer with a specified number of neurons (`n_units`) and an optional input shape (`input_shape`).\n- Set up placeholders for the layer's weights (`W`), biases (`w0`), and optimizers.\nYour task is to complete the subclass `Dense` and implement the following methods:\n1. Weight Initialization (`initialize`):\n  - Initialize the weights `W` using a uniform distribution with a limit of `1 / sqrt(input_shape[0])`, and bias `w0` should be set to zero.\n  - Initialize optimizers for `W` and `w0`.\n2. Parameter Count (`parameters`):\n  - Return the total number of trainable parameters in the layer, which includes the parameters in `W` and `w0`.\n3. Forward Pass (`forward_pass`):\n  - Compute the output of the layer by performing a dot product between the input `X` and the weight matrix `W`, and then adding the bias `w0`.\n4. Backward Pass (`backward_pass`):\n  - Calculate and return the gradient with respect to the input.\n  - If the layer is trainable, update the weights and biases using the optimizer's update rule.\n5. Output Shape (`output_shape`):\n- Return the shape of the output produced by the forward pass, which should be `(self.n_units,)`.\nObjective:\nExtend the `Layer` class by implementing the `Dense` class to ensure it functions correctly within a neural network framework.\n# Your code should start with:\n```python\nimport numpy as np\nimport copy\nimport math\n\nclass Layer(object):\n\n    def set_input_shape(self, shape):\n    \n        self.input_shape = shape\n\n    def layer_name(self):\n        return self.__class__.__name__\n\n    def parameters(self):\n        return 0\n\n    def forward_pass(self, X, training):\n        raise NotImplementedError()\n\n    def backward_pass(self, accum_grad):\n        raise NotImplementedError()\n\n    def output_shape(self):\n        raise NotImplementedError()\nclass Dense(Layer):\n    def __init__(self, n_units, input_shape=None):\n        self.layer_input = None\n        self.input_shape = input_shape\n        self.n_units = n_units\n        self.trainable = True\n        self.W = None\n        self.w0 = None\n\n    \"\"\"\n    implement the Dense class based on the above structure\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 41, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Simple Convolutional 2D Layer\n# Description:\nIn this problem, you need to implement a 2D convolutional layer in Python. This function will process an input matrix using a specified convolutional kernel, padding, and stride.\n# Your code should start with:\n```python\nimport numpy as np\ndef simple_conv2d(input_matrix: np.ndarray, kernel: np.ndarray, padding: int, stride: int):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 42, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement ReLU Activation Function\n# Description:\nWrite a Python function `relu` that implements the Rectified Linear Unit (ReLU) activation function. The function should take a single float as input and return the value after applying the ReLU function. The ReLU function returns the input if it's greater than 0, otherwise, it returns 0.\n# Your code should start with:\n```python\ndef relu(z: float) -> float:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 43, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Ridge Regression Loss Function\n# Description:\nWrite a Python function `ridge_loss` that implements the Ridge Regression loss function. The function should take a 2D numpy array `X` representing the feature matrix, a 1D numpy array `w` representing the coefficients, a 1D numpy array `y_true` representing the true labels, and a float `alpha` representing the regularization parameter. The function should return the Ridge loss, which combines the Mean Squared Error (MSE) and a regularization term.\n# Your code should start with:\n```python\nimport numpy as np\ndef ridge_loss(X: np.ndarray, w: np.ndarray, y_true: np.ndarray, alpha: float) -> float:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 44, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Leaky ReLU Activation Function\n# Description:\nWrite a Python function `leaky_relu` that implements the Leaky Rectified Linear Unit (Leaky ReLU) activation function. The function should take a float `z` as input and an optional float `alpha`, with a default value of 0.01, as the slope for negative inputs. The function should return the value after applying the Leaky ReLU function.\n# Your code should start with:\n```python\ndef leaky_relu(z: float, alpha: float = 0.01) -> float|int:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 45, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Linear Kernel Function\n# Description:\nWrite a Python function `kernel_function` that computes the linear kernel between two input vectors `x1` and `x2`. The linear kernel is defined as the dot product (inner product) of two vectors.\n# Your code should start with:\n```python\nimport numpy as np\ndef kernel_function(x1, x2):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 46, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Precision Metric\n# Description:\nWrite a Python function `precision` that calculates the precision metric given two numpy arrays: `y_true` and `y_pred`. The `y_true` array contains the true binary labels, and the `y_pred` array contains the predicted binary labels. Precision is defined as the ratio of true positives to the sum of true positives and false positives.\n# Your code should start with:\n```python\nimport numpy as np\ndef precision(y_true, y_pred):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 47, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Gradient Descent Variants with MSE Loss\n# Description:\nIn this problem, you need to implement a single function that can perform three variants of gradient descent\u00e2\u0080\u0094Stochastic Gradient Descent (SGD), Batch Gradient Descent, and Mini-Batch Gradient Descent\u00e2\u0080\u0094using Mean Squared Error (MSE) as the loss function. The function will take an additional parameter to specify which variant to use.\n# Your code should start with:\n```python\nimport numpy as np\ndef gradient_descent(X, y, weights, learning_rate, n_iterations, batch_size=1, method='batch'):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 48, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Reduced Row Echelon Form (RREF) Function\n# Description:\nIn this problem, your task is to implement a function that converts a given matrix into its Reduced Row Echelon Form (RREF). The RREF of a matrix is a special form where each leading entry in a row is 1, and all other elements in the column containing the leading 1 are zeros, except for the leading 1 itself.\nHowever, there are some additional details to keep in mind:\n- Diagonal entries can be 0 if the matrix is reducible (i.e., the row corresponding to that position can be eliminated entirely).\n- Some rows may consist entirely of zeros.\n- If a column contains a pivot (a leading 1), all other entries in that column should be zero.\nYour task is to implement the RREF algorithm, which must handle these cases and convert any given matrix into its RREF.\n# Your code should start with:\n```python\nimport numpy as np\ndef rref(matrix):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 49, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Adam Optimization Algorithm\n# Description:\nImplement the Adam (Adaptive Moment Estimation) optimization algorithm in Python. Adam is an optimization algorithm that adapts the learning rate for each parameter. Your task is to write a function `adam_optimizer` that updates the parameters of a given function using the Adam algorithm.\nThe function should take the following parameters:\n- `f`: The objective function to be optimized\n- `grad`: A function that computes the gradient of `f`\n- `x0`: Initial parameter values\n- `learning_rate`: The step size (default: 0.001)\n- `beta1`: Exponential decay rate for the first moment estimates (default: 0.9)\n- `beta2`: Exponential decay rate for the second moment estimates (default: 0.999)\n- `epsilon`: A small constant for numerical stability (default: 1e-8)\n- `num_iterations`: Number of iterations to run the optimizer (default: 1000)\nThe function should return the optimized parameters.\n# Your code should start with:\n```python\nimport numpy as np\ndef adam_optimizer(f, grad, x0, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8, num_iterations=10):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 50, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Lasso Regression using Gradient Descent\n# Description:\nIn this problem, you need to implement the Lasso Regression algorithm using Gradient Descent. Lasso Regression (L1 Regularization) adds a penalty equal to the absolute value of the coefficients to the loss function. Your task is to update the weights and bias iteratively using the gradient of the loss function and the L1 penalty.\nThe objective function of Lasso Regression is:\n$J(w, b) = \frac{1}{2n} \\sum\\limits_{i=1}^n (y_i - (\\sum\\limits_{j=1}^p X_{ij} w_j + b))^2$\nWhere:\n- $y_i$  is the actual value for the i-th sample\n- $\\hat{y_i} = \\sum_{j=1}^p X_{ij}w_j + b$ is the predicted value for the i-th sample\n- $w_j$ is the weight associated with the j-th feature\n- $\u0007lpha$ is the regularization parameter\n- $b$ is the bias\nYour task is to use the L1 penalty to shrink some of the feature coefficients to zero during gradient descent, thereby helping with feature selection.\n# Your code should start with:\n```python\nimport numpy as np\ndef l1_regularization_gradient_descent(X: np.array, y: np.array, alpha: float = 0.1, learning_rate: float = 0.01, max_iter: int = 1000, tol: float = 1e-4) -> tuple:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 51, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Optimal String Alignment Distance\n# Description:\nIn this problem, you need to implement a function that calculates the Optimal String Alignment (OSA) distance between two given strings. The OSA distance represents the minimum number of edits required to transform one string into another. The allowed edit operations are:\n- Insert a character\n- Delete a character\n- Substitute a character\n- Transpose two adjacent characters\nEach of these operations costs 1 unit.\nYour task is to find the minimum number of edits needed to convert the first string (s1) into the second string (s2).\nFor example, the OSA distance between the strings `caper` and `acer` is 2: one deletion (removing \"p\") and one transposition (swapping \"a\" and \"c\").\n# Your code should start with:\n```python\nimport numpy as np\ndef OSA(source: str, target: str) -> int:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 52, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Recall Metric in Binary Classification\n# Description:\nYour task is to implement the recall metric in a binary classification setting. Recall is a performance measure that evaluates how effectively a machine learning model identifies positive instances from all the actual positive cases in a dataset.\nYou need to write a function `recall(y_true, y_pred)` that calculates the recall metric. The function should accept two inputs:\n- `y_true`: A list of true binary labels (0 or 1) for the dataset.\n- `y_pred`: A list of predicted binary labels (0 or 1) from the model.\nYour function should return the recall value rounded to three decimal places. If the denominator (TP + FN) is zero, the recall should be 0.0 to avoid division by zero.\n# Your code should start with:\n```python\nimport numpy as np\ndef recall(y_true, y_pred):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 53, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Self-Attention Mechanism\n# Description:\nYour task is to implement the self-attention mechanism, which is a fundamental component of transformer models, widely used in natural language processing and computer vision tasks. The self-attention mechanism allows a model to dynamically focus on different parts of the input sequence when generating a contextualized representation.\nYour function should return the self-attention output as a numpy array.\n# Your code should start with:\n```python\nimport numpy as np\ndef self_attention(X, W_q, W_k, W_v):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 54, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implementing a Simple RNN\n# Description:\nWrite a Python function that implements a simple Recurrent Neural Network (RNN) cell. The function should process a sequence of input vectors and produce the final hidden state. Use the tanh activation function for the hidden state updates. The function should take as inputs the sequence of input vectors, the initial hidden state, the weight matrices for input-to-hidden and hidden-to-hidden connections, and the bias vector. The function should return the final hidden state after processing the entire sequence, rounded to four decimal places.\n# Your code should start with:\n```python\nimport numpy as np\ndef rnn_forward(input_sequence: list[list[float]], initial_hidden_state: list[float], Wx: list[list[float]], Wh: list[list[float]], b: list[float]) -> list[float]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 55, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: 2D Translation Matrix Implementation\n# Description:\nYour task is to implement a function that applies a 2D translation matrix to a set of points. A translation matrix is used to move points in 2D space by a specified distance in the x and y directions.\nWrite a function `translate_object(points, tx, ty)` where `points` is a list of [x, y] coordinates and `tx` and `ty` are the translation distances in the x and y directions, respectively.\nThe function should return a new list of points after applying the translation matrix.\n# Your code should start with:\n```python\nimport numpy as np\ndef translate_object(points, tx, ty):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 56, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: KL Divergence Between Two Normal Distributions\n# Description:\nYour task is to compute the Kullback-Leibler (KL) divergence between two normal distributions. KL divergence measures how one probability distribution differs from a second, reference probability distribution.\nWrite a function `kl_divergence_normal(mu_p, sigma_p, mu_q, sigma_q)` that calculates the KL divergence between two normal distributions, where $ P \\sim N(\\mu_P, \\sigma_P^2) $ and $ Q \\sim N(\\mu_Q, \\sigma_Q^2) $.\nThe function should return the KL divergence as a floating-point number.\n# Your code should start with:\n```python\nimport numpy as np\ndef kl_divergence_normal(mu_p, sigma_p, mu_q, sigma_q):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 57, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Gauss-Seidel Method for Solving Linear Systems\n# Description:\nYour task is to implement the Gauss-Seidel method, an iterative technique for solving a system of linear equations (Ax = b).\nThe function should iteratively update the solution vector (x) by using the most recent values available during the iteration process.\nWrite a function `gauss_seidel(A, b, n, x_ini=None)` where:\n- `A` is a square matrix of coefficients,\n- `b` is the right-hand side vector,\n- `n` is the number of iterations,\n- `x_ini` is an optional initial guess for (x) (if not provided, assume a vector of zeros).\nThe function should return the approximated solution vector (x) after performing the specified number of iterations.\n# Your code should start with:\n```python\nimport numpy as np\ndef gauss_seidel(A, b, n, x_ini=None):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 58, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Gaussian Elimination for Solving Linear Systems\n# Description:\nYour task is to implement the Gaussian Elimination method, which transforms a system of linear equations into an upper triangular matrix. This method can then be used to solve for the variables using backward substitution.\nWrite a function `gaussian_elimination(A, b)` that performs Gaussian Elimination with partial pivoting to solve the system (Ax = b).\nThe function should return the solution vector (x).\n# Your code should start with:\n```python\nimport numpy as np\ndef gaussian_elimination(A, b):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 59, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Long Short-Term Memory (LSTM) Network\n# Description:\nYour task is to implement an LSTM network that processes a sequence of inputs and produces the final hidden state and cell state after processing all inputs.\nComplete the class `LSTM` with the method `forward(self, x, initial_hidden_state, initial_cell_state)`: processes a sequence of inputs and returns the hidden states at each time step, as well as the final hidden state and cell state.\nThe LSTM should compute the forget gate, input gate, candidate cell state, and output gate at each time step to update the hidden state and cell state.\n# Your code should start with:\n```python\nimport numpy as np\nclass LSTM:\n    def __init__(self, input_size, hidden_size):\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n\n        # Initialize weights and biases\n        self.Wf = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wi = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wc = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wo = np.random.randn(hidden_size, input_size + hidden_size)\n\n        self.bf = np.zeros((hidden_size, 1))\n        self.bi = np.zeros((hidden_size, 1))\n        self.bc = np.zeros((hidden_size, 1))\n        self.bo = np.zeros((hidden_size, 1))\n\n    def forward(self, x, initial_hidden_state, initial_cell_state):\n        \"\"\"\n        Processes a sequence of inputs and returns the hidden states, final hidden state, and final cell state.\n        \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 60, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement TF-IDF (Term Frequency-Inverse Document Frequency)\n# Description:\nYour task is to implement a function that computes the TF-IDF scores for a query against a given corpus of documents.\nFunction Signature\nWrite a function `compute_tf_idf(corpus, query)` that takes the following inputs:\n- `corpus`: A list of documents, where each document is a list of words.\n- `query`: A list of words for which you want to compute the TF-IDF scores.\nOutput\nThe function should return a list of lists containing the TF-IDF scores for the query words in each document, rounded to five decimal places.\nImportant Considerations\n1. Handling Division by Zero:\nWhen implementing the Inverse Document Frequency (IDF) calculation, you must account for cases where a term does not appear in any document (`df = 0`). This can lead to division by zero in the standard IDF formula. Add smoothing (e.g., adding 1 to both numerator and denominator) to avoid such errors.\n2. Empty Corpus:\nEnsure your implementation gracefully handles the case of an empty corpus. If no documents are provided, your function should either raise an appropriate error or return an empty result. This will ensure the program remains robust and predictable.\n3. Edge Cases:\n  - Query terms not present in the corpus.\n  - Documents with no words.\n  - Extremely large or small values for term frequencies or document frequencies.\nBy addressing these considerations, your implementation will be robust and handle real-world scenarios effectively.\n# Your code should start with:\n```python\nimport numpy as np\ndef compute_tf_idf(corpus, query):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 61, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement F-Score Calculation for Binary Classification\n# Description:\nImplement a function that calculates the F-Score for a binary classification task.\nThe F-Score combines both Precision and Recall into a single metric, providing a balanced measure of a model's performance.\nWrite a function `f_score(y_true, y_pred, beta)` where:\n- `y_true`: A numpy array of true labels (binary).\n- `y_pred`: A numpy array of predicted labels (binary).\n- `beta`: A float value that adjusts the importance of Precision and Recall. When `beta`=1, it computes the F1-Score, a balanced measure of both Precision and Recall.\nThe function should return the F-Score rounded to three decimal places.\n# Your code should start with:\n```python\nimport numpy as np\ndef f_score(y_true, y_pred, beta):\n    \"\"\"\n    Calculate F-Score for a binary classification task.\n\n    :param y_true: Numpy array of true labels\n    :param y_pred: Numpy array of predicted labels\n    :param beta: The weight of precision in the harmonic mean\n    :return: F-Score rounded to three decimal places\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 62, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement a Simple RNN with Backpropagation Through Time (BPTT)\n# Description:\nImplement a simple Recurrent Neural Network (RNN) and backpropagation through time (BPTT) to learn from sequential data.\nThe RNN will process input sequences, update hidden states, and perform backpropagation to adjust weights based on the error gradient.\n`initialize_weights(input_size, hidden_size, output_size)` function initializes the RNN with weights set to random values multiplied by 0.01 and biases set to zero.\nWrite the following methods to complete forward pass, and backward pass of the RNN:\n- `rnn_forward(W_xh, W_hh, W_hy, b_h, b_y, hidden_size, input_sequence)`: Processes a sequence of inputs and returns the output, the last inputs and the hidden states.\n- `rnn_backward(W_xh, W_hh, W_hy, b_h, b_y, hidden_size, input_sequence, expected_output, outputs, last_inputs, last_hiddens, learning_rate)`: Performs backpropagation through time (BPTT) to adjust the weights based on the loss.\nIn this task, the RNN will be trained on sequence prediction, where the network will learn to predict the next item in a sequence.\nYou should use 1/2 * Mean Squared Error (MSE) as the loss function and make sure to aggregate the losses at each time step by summing.\n# Your code should start with:\n```python\nimport numpy as np\nclass SimpleRNN:\n    def __init__(self, input_size, hidden_size, output_size):\n        \"\"\"\n        Initializes the RNN with random weights and zero biases.\n        \"\"\"\n        self.hidden_size = hidden_size\n        self.W_xh = np.random.randn(hidden_size, input_size)*0.01\n        self.W_hh = np.random.randn(hidden_size, hidden_size)*0.01\n        self.W_hy = np.random.randn(output_size, hidden_size)*0.01\n        self.b_h = np.zeros((hidden_size, 1))\n        self.b_y = np.zeros((output_size, 1))\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass through the RNN for a given sequence of inputs.\n        \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 63, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Conjugate Gradient Method for Solving Linear Systems\n# Description:\nImplement the Conjugate Gradient (CG) method, an efficient iterative algorithm for solving large, sparse, symmetric, positive-definite linear systems.\nGiven a matrix `A` and a vector `b`, the algorithm will solve for `x` in the system ( Ax = b ).\nWrite a function `conjugate_gradient(A, b, n, x0=None, tol=1e-8)` that performs the Conjugate Gradient method as follows:\n- `A`: A symmetric, positive-definite matrix representing the linear system.\n- `b`: The vector on the right side of the equation.\n- `n`: Maximum number of iterations.\n- `x0`: Initial guess for the solution vector.\n- `tol`: Tolerance for stopping criteria.\nThe function should return the solution vector `x`.\n# Your code should start with:\n```python\nimport numpy as np\ndef conjugate_gradient(A: np.array, b: np.array, n: int, x0: np.array=None, tol=1e-8):\n    \"\"\"\n    Solve the system Ax = b using the Conjugate Gradient method.\n\n    :param A: Symmetric positive-definite matrix\n    :param b: Right-hand side vector\n    :param n: Maximum number of iterations\n    :param x0: Initial guess for solution (default is zero vector)\n    :param tol: Convergence tolerance\n    :return: Solution vector x\n    \"\"\"\n```\n# Output Constraints:\nThe final solution vector x should be rounded to 8 decimal places and converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 64, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Gini Impurity Calculation for a Set of Classes\n# Description:\nImplement a function that calculates the Gini Impurity for a set of classes.\nGini impurity is commonly used in decision tree algorithms to measure the impurity or disorder within a node.\n# Your code should start with:\n```python\nimport numpy as np\ndef gini_impurity(y: list[int]) -> float:\n    \"\"\"\n    Calculate Gini Impurity for a list of class labels.\n\n    :param y: List of class labels\n    :return: Gini Impurity rounded to three decimal places\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 65, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Compressed Row Sparse Matrix (CSR) Format Conversion\n# Description:\nImplement a function that converts a given dense matrix into the Compressed Row Sparse (CSR) format, an efficient storage representation for sparse matrices.\nThe CSR format only stores non-zero elements and their positions, significantly reducing memory usage for matrices with a large number of zeros.\nWrite a function `compressed_row_sparse_matrix(dense_matrix)` that takes a 2D list `dense_matrix` as input and returns a tuple containing three lists:\n- Values array: List of all non-zero elements in row-major order.\n- Column indices array: Column index for each non-zero element in the values array.\n- Row pointer array: Cumulative number of non-zero elements per row, indicating the start of each row in the values array.\n# Your code should start with:\n```python\ndef compressed_row_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix to its Compressed Row Sparse (CSR) representation.\n\n    :param dense_matrix: 2D list representing a dense matrix\n    :return: A tuple containing (values array, column indices array, row pointer array)\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 66, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Orthogonal Projection of a Vector onto a Line\n# Description:\nImplement a function that calculates the orthogonal projection of a vector `v` onto another vector `L`. This projection results in the vector on `L` that is closest to `v`.\nWrite a function `orthogonal_projection(v, L)` that takes in two lists, `v` (the vector to be projected) and `L` (the line vector), and returns the orthogonal projection of `v` onto `L`.\nThe function should output a list representing the projection vector rounded to three decimal places.\n# Your code should start with:\n```python\ndef orthogonal_projection(v, L):\n    \"\"\"\n    Compute the orthogonal projection of vector v onto line L.\n\n    :param v: The vector to be projected\n    :param L: The line vector defining the direction of projection\n    :return: List representing the projection of v onto L\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 67, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Compressed Column Sparse Matrix Format (CSC)\n# Description:\nImplement a function that converts a dense matrix into its Compressed Column Sparse (CSC) representation.\nThe CSC format stores only non-zero elements of the matrix and is efficient for matrices with a high number of zero elements.\nWrite a function `compressed_col_sparse_matrix(dense_matrix)` that takes in a two-dimensional list `dense_matrix` and returns a tuple of three lists:\n- `values`: List of non-zero elements, stored in column-major order.\n- `row indices`: List of row indices corresponding to each value in the values array.\n- `column pointer`: List that indicates the starting index of each column in the values array.\n# Your code should start with:\n```python\ndef compressed_col_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix into its Compressed Column Sparse (CSC) representation.\n\n    :param dense_matrix: List of lists representing the dense matrix\n    :return: Tuple of (values, row indices, column pointer)\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 68, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Find the Image of a Matrix Using Row Echelon Form\n# Description:\nImplement a function `matrix_image(A)` that calculates the column space of a given matrix `A`.\nThe column space, also known as the image or span, consists of all linear combinations of the columns of `A`. \nTo find this, you'll use concepts from linear algebra, focusing on identifying independent columns that span the matrix's image. \nThe function `matrix_image(A)` should return the basis vectors that span the column space of `A`.\nThese vectors should be extracted from the original matrix and correspond to the independent columns.\n# Your code should start with:\n```python\nimport numpy as np\ndef matrix_image(A):\n```\n# Output Constraints:\nThe matrix representing basis vectors should be rounded to 8 decimal places and converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 69, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate R-squared for Regression Analysis\n# Description:\nR-squared, also known as the coefficient of determination, is a measure that indicates how well the independent variables explain the variability of the dependent variable in a regression model.\nTo implement the function `r_squared(y_true, y_pred)` that calculates the R-squared value, given arrays of true values `y_true` and predicted values `y_pred`.\n# Your code should start with:\n```python\nimport numpy as np\ndef r_squared(y_true, y_pred):\n```\n# Output Constraints:\nYour code should return the R-squared value rounded to three decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 70, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Image Brightness\n# Description:\nImplement a function `calculate_brightness(img)` that calculates the average brightness of a grayscale image. The image is represented as a 2D matrix, where each element represents a pixel value between 0 (black) and 255 (white).\nThe function `calculate_brightness(img)` should:\n1. Return the average brightness of the image rounded to two decimal places.\n2. Handle edge cases:\n    - If the image matrix is empty.\n    - If the rows in the matrix have inconsistent lengths.\n    - If any pixel values are outside the valid range (0-255).\nFor any of these edge cases, the function should return `-1`.\n# Your code should start with:\n```python\ndef calculate_brightness(img):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 71, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Root Mean Square Error (RMSE)\n# Description:\nImplement a function `rmse(y_true, y_pred)` that calculates the Root Mean Square Error (RMSE) between the actual values and the predicted values. RMSE is a commonly used metric for evaluating the accuracy of regression models, providing insight into the standard deviation of residuals.\nThe function `rmse(y_true, y_pred)` should:\n1. Calculate the RMSE between the arrays y_true and y_pred.\n2. Return the RMSE value rounded to three decimal places.\n3. Ensure the function handles edge cases such as:\n    - Mismatched array shapes.\n    - Empty arrays.\n    - Invalid input types.\nThe RMSE is defined as $ RMSE = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (y_{true,i} - y_{pred,i})^2} $, where:\n- $n$ is the number of observations.\n- $y_{true,i}$ and $y_{pred,i}$ are the actual and predicted values for the $i$-th observation.\n# Your code should start with:\n```python\nimport numpy as np\ndef rmse(y_true, y_pred):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 72, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Jaccard Index for Binary Classification\n# Description:\nImplement a function `jaccard_index(y_true, y_pred)` that calculates the Jaccard Index, a measure of similarity between two binary sets. The Jaccard Index is widely used in binary classification tasks to evaluate the overlap between predicted and true labels.\nThe function `jaccard_index(y_true, y_pred)` should:\n1. Calculate the Jaccard Index between the arrays `y_true` and `y_pred`.\n2. Return the Jaccard Index as a float value.\n3. Ensure the function handles cases where:\n    - There is no overlap between `y_true` and `y_pred`.\n    - Both arrays contain only zeros (edge cases).\n\nThe Jaccard Index is defined as $ Jaccard Index = \\frac{\\text{Number of elements in the intersection of } y_{\\text{true}} \\text{ and } y_{\\text{pred}} }{\\text{Number of elements in the union of } y_{\\text{true}} \\text{ and } y_{\\text{pred}}} $, where:\n- $y_{\\text{true}}$ and $y_{\\text{pred}}$ are binary arrays of the same length, representing true and predicted labels.\n- The result ranges from 0 (no overlap) to 1 (perfect overlap).\n# Your code should start with:\n```python\nimport numpy as np\ndef jaccard_index(y_true, y_pred):\n```\n# Output Constraints:\nYour code should return the Jaccard Index rounded to three decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 73, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Dice Score for Classification\n# Description:\nImplement a function `dice_score(y_true, y_pred)` that calculates the Dice Score, also known as the S\u00c3\u00b8rensen-Dice coefficient or F1-score, for binary classification. The Dice Score is used to measure the similarity between two sets and is particularly useful in tasks like image segmentation and binary classification.\nThe function `dice_score(y_true, y_pred)` should:\n1. Calculate the Dice Score between the arrays `y_true` and `y_pred`.\n2. Return the Dice Score as a float value rounded to 3 decimal places.\n3. Handle edge cases appropriately, such as when there are no true or predicted positives.\n\nThe Dice Score is defined as $ Dice Score = \\frac{2 \\times (\\text{Number of elements in the intersection of } y_{\\text{true}} \\text{ and } y_{\\text{pred}})}{\\text{Number of elements in } y_{\\text{true}} + \\text{Number of elements in } y_{\\text{pred}}} $, where:\n- $y_{\\text{true}}$ and $y_{\\text{pred}}$ are binary arrays of the same length, representing true and predicted labels.\n- The result ranges from 0 (no overlap) to 1 (perfect overlap).\n# Your code should start with:\n```python\nimport numpy as np\ndef dice_score(y_true, y_pred):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 74, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Create Composite Hypervector for a Dataset Row\n# Description:\nImplement the function `create_row_hv(row, dim, random_seeds)` to generate a composite hypervector for a given dataset row using Hyperdimensional Computing (HDC).\nEach feature in the row is represented by binding hypervectors for the feature name and its value.\nThe hypervectors for the values are created using the same feature seed provided in the `random_seeds` dictionary to ensure reproducibility.\nAll feature hypervectors are then bundled to create a composite hypervector for the row.\nInput:\n- `row`: A dictionary representing a dataset row, where keys are feature names and values are their corresponding values.\n- `dim`: The dimensionality of the hypervectors.\n- `random_seeds`: A dictionary where keys are feature names and values are seeds to ensure reproducibility of hypervectors.\nOutput:\n- A composite hypervector representing the entire row.\n# Your code should start with:\n```python\nimport numpy as np\ndef create_row_hv(row, dim, random_seeds):\n```\n# Output Constraints:\nThe composite hypervector should be converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 75, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Generate a Confusion Matrix for Binary Classification\n# Description:\nImplement the function `confusion_matrix(data)` that generates a confusion matrix for a binary classification problem.\nThe confusion matrix provides a summary of the prediction results on a classification problem, allowing you to visualize how many data points were correctly or incorrectly labeled.\nInput:\n    - A list of lists, where each inner list represents a pair\n    - `[y_true, y_pred]` for one observation. `y_true` is the actual label, and `y_pred` is the predicted label.\nOutput:\n    - A 2x2 confusion matrix represented as a list of lists.\n# Your code should start with:\n```python\nfrom collections import Counter\ndef confusion_matrix(data):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 76, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Cosine Similarity Between Vectors\n# Description:\nImplement a function `cosine_similarity(v1, v2)` that calculates the cosine similarity between two vectors.\nCosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\nInput:\n- `v1` and `v2`: Numpy arrays representing the input vectors.\nOutput:\n- A float representing the cosine similarity, rounded to three decimal places.\nConstraints:\n- Both input vectors must have the same shape.\n- Input vectors cannot be empty or have zero magnitude.\n# Your code should start with:\n```python\nimport numpy as np\ndef cosine_similarity(v1, v2):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 77, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Performance Metrics for a Classification Model\n# Description:\nImplement a function `performance_metrics(actual, predicted)` that computes various performance metrics for a binary classification problem.\nThese metrics include:\n- Confusion Matrix\n- Accuracy\n- F1 Score\n- Specificity\n- Negative Predictive Value\nThe function should take in two lists as input:\n- `actual`: The actual class labels (1 for positive, 0 for negative).\n- `predicted`: The predicted class labels from the model.\nThe function should return a tuple containing:\n- `confusion_matrix`: A 2x2 matrix.\n- `accuracy`: A float representing the accuracy of the model.\n- `f1_score`: A float representing the F1 score of the model.\n- `specificity`: A float representing the specificity of the model.\n- `negative_predictive_value`: A float representing the negative predictive value.\nConstraints\n- All elements in the `actual` and `predicted` lists must be either 0 or 1.\n- Both lists must have the same length.\n# Your code should start with:\n```python\nfrom collections import Counter\ndef performance_metrics(actual: list[int], predicted: list[int]) -> tuple:\n```\n# Output Constraints:\nWhen your code return `accuracy`, `f1_score`, `specificity`, and `negative_predictive_value`, their values should be rounded to three decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 78, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Descriptive Statistics Calculator\n# Description:\nWrite a Python function to calculate various descriptive statistics metrics for a given dataset. The function should take a list or NumPy array of numerical values and return a dictionary containing mean, median, mode, variance, standard deviation, percentiles (25th, 50th, 75th), and interquartile range (IQR).\n# Your code should start with:\n```python\nimport numpy as np\ndef descriptive_statistics(data):\n```\n# Output Constraints:\nThe output should be a dictionary with the following keys:\n- 'mean'\n- 'median'\n- 'mode'\n- 'variance'\n- 'standard_deviation'\n- '25th_percentile'\n- '50th_percentile'\n- '75th_percentile'\n- 'interquartile_range'\nExcept for statistics that draw from the data, all other values should be rounded to four decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 79, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Binomial Distribution Probability\n# Description:\nWrite a Python function to calculate the probability of achieving exactly k successes in n independent Bernoulli trials, each with probability p of success, using the Binomial distribution formula.\n# Your code should start with:\n```python\nimport math\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Calculate the probability of achieving exactly k successes in n independent Bernoulli trials,\n    each with probability p of success, using the Binomial distribution formula.\n    :param n: Total number of trials\n    :param k: Number of successes\n    :param p: Probability of success on each trial\n    :return: Probability of k successes in n trials\n    \"\"\"\n```\n# Output Constraints:\nYour code should return the probability rounded to five decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 80, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Normal Distribution PDF Calculator\n# Description:\nWrite a Python function to calculate the probability density function (PDF) of the normal distribution for a given value, mean, and standard deviation. The function should use the mathematical formula of the normal distribution to return the PDF value rounded to 5 decimal places.\n# Your code should start with:\n```python\nimport math\ndef normal_pdf(x, mean, std_dev):\n    \"\"\"\n    Calculate the probability density function (PDF) of the normal distribution.\n    :param x: The value at which the PDF is evaluated.\n    :param mean: The mean (\u03bc) of the distribution.\n    :param std_dev: The standard deviation (\u03c3) of the distribution.\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 81, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Poisson Distribution Probability Calculator\n# Description:\nWrite a Python function to calculate the probability of observing exactly k events in a fixed interval using the Poisson distribution formula. The function should take k (number of events) and lam (mean rate of occurrences) as inputs and return the probability rounded to 5 decimal places.\n# Your code should start with:\n```python\nimport math\ndef poisson_probability(k, lam):\n    \"\"\"\n    Calculate the probability of observing exactly k events in a fixed interval,\n    given the mean rate of events lam, using the Poisson distribution formula.\n    :param k: Number of events (non-negative integer)\n    :param lam: The average rate (mean) of occurrences in a fixed interval\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 82, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Grayscale Image Contrast Calculator\n# Description:\nWrite a Python function to calculate the contrast of a grayscale image using the difference between the maximum and minimum pixel values.\n# Your code should start with:\n```python\nimport numpy as np\ndef calculate_contrast(img):\n    \"\"\"\n    Calculate the contrast of a grayscale image.\n    Args:\n        img (numpy.ndarray): 2D array representing a grayscale image with pixel values between 0 and 255.\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 83, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Dot Product Calculator\n# Description:\nWrite a Python function to calculate the dot product of two vectors. The function should take two 1D NumPy arrays as input and return the dot product as a single number.\n# Your code should start with:\n```python\nimport numpy as np\ndef calculate_dot_product(vec1, vec2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Args:\n        vec1 (numpy.ndarray): 1D array representing the first vector.\n        vec2 (numpy.ndarray): 1D array representing the second vector.\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 84, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Phi Transformation for Polynomial Features\n# Description:\nWrite a Python function to perform a Phi Transformation that maps input features into a higher-dimensional space by generating polynomial features. The transformation allows models like linear regression to fit nonlinear data by introducing new feature dimensions that represent polynomial combinations of the original input features. The function should take a list of numerical data and a degree as inputs, and return a nested list where each inner list represents the transformed features of a data point. If the degree is less than 0, the function should return an empty list.\n# Your code should start with:\n```python\nimport numpy as np\ndef phi_transform(data: list[float], degree: int):\n    \"\"\"\n    Perform a Phi Transformation to map input features into a higher-dimensional space by generating polynomial features.\n\n    Args:\n        data (list[float]): A list of numerical values to transform.\n        degree (int): The degree of the polynomial expansion.\n    \"\"\"\n```\n# Output Constraints:\nThe function should output a list of lists, where each inner list contains the polynomial features of the corresponding data point. The output should be rounded to 8 decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 85, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Positional Encoding Calculator\n# Description:\nWrite a Python function to implement the Positional Encoding layer for Transformers. The function should calculate positional encodings for a sequence length (`position`) and model dimensionality (`d_model`) using sine and cosine functions as specified in the Transformer architecture. The function should return -1 if `position` is 0, or if `d_model` is less than or equal to 0.\n# Your code should start with:\n```python\nimport numpy as np\ndef pos_encoding(position: int, d_model: int):\n```\n# Output Constraints:\nThe position encoding array should be of dtype np.float16 and converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 86, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Detect Overfitting or Underfitting\n# Description:\nWrite a Python function to determine whether a machine learning model is overfitting, underfitting, or performing well based on training and test accuracy values. The function should take two inputs: `training_accuracy` and `test_accuracy`. It should return one of three values: 1 if Overfitting, -1 if Underfitting, or 0 if a Good fit. The rules for determination are as follows:\n\n- **Overfitting**: The training accuracy is significantly higher than the test accuracy (difference > 0.2).\n- **Underfitting**: Both training and test accuracy are below 0.7.\n- **Good fit**: Neither of the above conditions is true.\n# Your code should start with:\n```python\ndef model_fit_quality(training_accuracy, test_accuracy):\n    \"\"\"\n    Determine if the model is overfitting, underfitting, or a good fit based on training and test accuracy.\n    :param training_accuracy: float, training accuracy of the model (0 <= training_accuracy <= 1)\n    :param test_accuracy: float, test accuracy of the model (0 <= test_accuracy <= 1)\n    :return: int, one of '1', '-1', or '0'.\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 87, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Adam Optimizer\n# Description:\nImplement the Adam optimizer update step function. Your function should take the current parameter value, gradient, and moving averages as inputs, and return the updated parameter value and new moving averages. The function should also handle scalar and array inputs and include bias correction for the moving averages.\n# Your code should start with:\n```python\nimport numpy as np\ndef adam_optimizer(parameter, grad, m, v, t, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8):\n    \"\"\"\n    Update parameters using the Adam optimizer.\n    Adjusts the learning rate based on the moving averages of the gradient and squared gradient.\n    :param parameter: Current parameter value\n    :param grad: Current gradient\n    :param m: First moment estimate\n    :param v: Second moment estimate\n    :param t: Current timestep\n    :param learning_rate: Learning rate (default=0.001)\n    :param beta1: First moment decay rate (default=0.9)\n    :param beta2: Second moment decay rate (default=0.999)\n    :param epsilon: Small constant for numerical stability (default=1e-8)\n    :return: tuple: (updated_parameter, updated_m, updated_v)\n    \"\"\"\n```\n# Output Constraints:\nThe updated parameter, first moment (m), and second moment (v) should be rounded to 5 decimal places and converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 88, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: GPT-2 Text Generation\n# Description:\nImplement a Simplified GPT-2-like Text Generation Function\n\nYou are tasked with implementing a simplified GPT-2-like text generation function in Python. This function will incorporate the following components of a minimal GPT-2 architecture:\n\n- **Token Embeddings**: Map input tokens to dense vector representations.\n- **Positional Embeddings**: Add positional information to token embeddings.\n- **Multi-head Attention**: Attend to various parts of the sequence.\n- **Feed-Forward Network**: Process attention outputs through a dense layer.\n- **Layer Normalization**: Stabilize the training process.\n\nThe function must take in the following parameters:\n\n1. Prompt: The initial text to guide the generation process.\n2. Number of Tokens to Generate: Specify how many tokens to output.\n\nYour function should output the generated text.\n\nAdditionally, utilize the helper function `load_encoder_hparams_and_params` to retrieve:\n\n- A dummy encoder.\n- Model hyperparameters.\n- Model parameters.\n\nBuild your text generation logic around these components. This exercise is designed to help you understand the core concepts behind GPT-2's autoregressive text generation.\n# Your code should start with:\n```python\nimport numpy as np\n\ndef load_encoder_hparams_and_params(model_size: str = \"124M\", models_dir: str = \"models\"):\n    class DummyBPE:\n        def __init__(self):\n            self.encoder_dict = {\"hello\": 1, \"world\": 2, \"<UNK>\": 0}\n\n        def encode(self, text: str):\n            tokens = text.strip().split()\n            return [self.encoder_dict.get(token, self.encoder_dict[\"<UNK>\"]) for token in tokens]\n\n        def decode(self, token_ids: list):\n            reversed_dict = {v: k for k, v in self.encoder_dict.items()}\n            return \" \".join([reversed_dict.get(tok_id, \"<UNK>\") for tok_id in token_ids])\n\n    hparams = {\n        \"n_ctx\": 1024,\n        \"n_head\": 12\n    }\n\n    params = {\n        \"wte\": np.random.rand(3, 10),\n        \"wpe\": np.random.rand(1024, 10),\n        \"blocks\": [],\n        \"ln_f\": {\n            \"g\": np.ones(10),\n            \"b\": np.zeros(10),\n        }\n    }\n\n    encoder = DummyBPE()\n    return encoder, hparams, params\ndef gen_text(prompt: str, n_tokens_to_generate: int = 40):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 89, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: The Pattern Weaver's Code\n# Description:\nDeep in the Crystal Cave, the enigmatic Pattern Weaver creates stunning sequences by uncovering the intricate relationships between crystals.\nEach crystal is marked by a unique numeric value, and the Weaver emphasizes that the true power of any crystal depends on how it interacts with all others.\nYou have discovered N crystals, each with a specific value, and need to reveal their enhanced patterns by analyzing these relationships using self-attention.\nGiven a sequence of crystals and their values, implement a simplified self-attention mechanism.\nFor each crystal, calculate its relationship with every other crystal, compute the attention scores using the softmax function, and derive the final weighted pattern for each crystal.\n# Your code should start with:\n```python\nimport numpy as np\ndef pattern_weaver(n, crystal_values, dimension):\n    def softmax(values):\n        # Implement the softmax function first\n```\n# Output Constraints:\nYour code should return a list of floats, each rounded to the 4th decimal place.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 90, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: BM25 Ranking\n# Description:\nImplement the BM25 ranking function to calculate document scores for a query in an information retrieval context. BM25 is an advanced variation of TF-IDF that incorporates term frequency saturation, document length normalization, and a configurable penalty for document length effects.\n# Your code should start with:\n```python\nimport numpy as np\nfrom collections import Counter\ndef calculate_bm25_scores(corpus, query, k1=1.5, b=0.75):\n```\n# Output Constraints:\nThe function should output a list representing the score of each document in the corpus, with each rounded to three decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 91, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate F1 Score from Predicted and True Labels\n# Description:\nImplement a function to calculate the F1 score given predicted and true labels. The F1 score is a widely used metric in machine learning, combining precision and recall into a single measure. round your solution to the 3rd decimal place\n# Your code should start with:\n```python\ndef calculate_f1_score(y_true, y_pred):\n    \"\"\"\n    Calculate the F1 score based on true and predicted labels.\n\n    Args:\n        y_true (list): True labels (ground truth).\n        y_pred (list): Predicted labels.\n\n    Returns:\n        float: The F1 score rounded to three decimal places.\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 92, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Linear Regression - Power Grid Optimization\n# Description:\nIt is the year 2157. Mars has its first thriving colony, and energy consumption is steadily on the rise. As the lead data scientist, you have daily power usage measurements (10 days) affected by both a growing linear trend and a daily fluctuation. The fluctuation follows the formula $f(i) = 10 \\times \\sin(2\\pi i / 10)$, where i is the day number (1 through 10). Your challenge is to remove this known fluctuation from each data point, fit a linear regression model to the detrended data, predict day 15's base consumption, add back the fluctuation for day 15, and finally include a 5% safety margin. The final answer must be an integer, ensuring you meet the colony's future needs.\n# Your code should start with:\n```python\nimport math\nPI = 3.14159\ndef power_grid_forecast(consumption_data):\n    # 1) Subtract the daily fluctuation (10 * sin(2\u03c0 * i / 10)) from each data point.\n    # 2) Perform linear regression on the detrended data.\n    # 3) Predict day 15's base consumption.\n    # 4) Add the day 15 fluctuation back.\n    # 5) Round, then add a 5% safety margin (rounded up).\n    # 6) Return the final integer.\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 93, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Mean Absolute Error (MAE)\n# Description:\nImplement a function to calculate the Mean Absolute Error (MAE) between two arrays of actual and predicted values. The MAE is a metric used to measure the average magnitude of errors in a set of predictions without considering their direction.\n# Your code should start with:\n```python\nimport numpy as np\ndef mae(y_true, y_pred):\n    \"\"\"\n    Calculate Mean Absolute Error between two arrays.\n\n    Parameters:\n    y_true (numpy.ndarray): Array of true values\n    y_pred (numpy.ndarray): Array of predicted values\n\n    Returns:\n    float: Mean Absolute Error rounded to 3 decimal places\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 94, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Multi-Head Attention\n# Description:\nImplement the multi-head attention mechanism, a key component in the Transformer model, via three key functions: `compute_qkv`, `self_attention`, and `multi_head_attention`.\n# Your code should start with:\n```python\nimport numpy as np\ndef multi_head_attention(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray, n_heads: int) -> list:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 95, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate the Phi Coefficient\n# Description:\nImplement a function to calculate the Phi coefficient, a measure of the correlation between two binary variables. The function should take two lists of integers (0s and 1s) as input and return the Phi coefficient rounded to 4 decimal places.\n# Your code should start with:\n```python\ndef phi_corr(x: list[int], y: list[int]) -> float:\n    \"\"\"\n    Calculate the Phi coefficient between two binary variables.\n\n    Args:\n    x (list[int]): A list of binary values (0 or 1).\n    y (list[int]): A list of binary values (0 or 1).\n\n    Returns:\n    float: The Phi coefficient rounded to 4 decimal places.\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 96, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Hard Sigmoid Activation Function\n# Description:\nImplement the Hard Sigmoid activation function, a computationally efficient approximation of the standard sigmoid function. Your function should take a single input value and return the corresponding output based on the Hard Sigmoid definition.\n# Your code should start with:\n```python\ndef hard_sigmoid(x: float) -> float:\n    \"\"\"\n    Implements the Hard Sigmoid activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Hard Sigmoid of the input\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 97, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the ELU Activation Function\n# Description:\nImplement the ELU (Exponential Linear Unit) activation function, which helps mitigate the limitations of ReLU by providing negative outputs for negative inputs. The function should compute the ELU activation value for a given input.\n# Your code should start with:\n```python\nimport math\ndef elu(x: float, alpha: float = 1.0) -> float:\n    \"\"\"\n    Compute the ELU activation function.\n\n    Args:\n        x (float): Input value\n        alpha (float): ELU parameter for negative values (default: 1.0)\n\n    Returns:\n        float: ELU activation value\n    \"\"\"\n```\n# Output Constraints:\nYour code should return a float rounded to the 4th decimal place.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 98, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the PReLU Activation Function\n# Description:\nImplement the PReLU (Parametric ReLU) activation function, a variant of the ReLU activation function that introduces a learnable parameter for negative inputs.\nCompute the PReLU activation value for a given input.\n# Your code should start with:\n```python\ndef prelu(x: float, alpha: float = 0.25) -> float:\n    \"\"\"\n    Implements the PReLU (Parametric ReLU) activation function.\n\n    Args:\n        x: Input value\n        alpha: Slope parameter for negative values (default: 0.25)\n\n    Returns:\n        float: PReLU activation value\n    \"\"\"\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 99, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Softplus Activation Function\n# Description:\nImplement the Softplus activation function, a smooth approximation of the ReLU function.\nCompute the Softplus value for a given input, handling edge cases to prevent numerical overflow or underflow.\n# Your code should start with:\n```python\nimport math\ndef softplus(x: float) -> float:\n    \"\"\"\n    Compute the softplus activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The softplus value: log(1 + e^x)\n    \"\"\"\n```\n# Output Constraints:\nYour code should return a float rounded to the 4th decimal place.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 100, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Softsign Activation Function\n# Description:\nImplement the Softsign activation function, a smooth activation function used in neural networks.\nCompute the Softsign value for a given input, ensuring the output is bounded between -1 and 1.\n# Your code should start with:\n```python\ndef softsign(x: float) -> float:\n    \"\"\"\n    Implements the Softsign activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Softsign of the input\n    \"\"\"\n```\n# Output Constraints:\nYour code should return a float rounded to the 4th decimal place.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 101, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the GRPO Objective Function\n# Description:\nImplement the GRPO (Group Relative Policy Optimization) objective function used to optimize policy parameters in reinforcement learning. Your task is to compute the GRPO objective given the likelihood ratios, advantage estimates, old policy probabilities, reference policy probabilities, and apply the clipping mechanism and KL divergence penalty correctly to maintain training stability.\n# Your code should start with:\n```python\nimport numpy as np\ndef grpo_objective(rhos, A, pi_theta_old, pi_theta_ref, epsilon=0.2, beta=0.01) -> float:\n    \"\"\"\n    Compute the GRPO objective function.\n\n    Args:\n        rhos: List of likelihood ratios (p_i) = pi_theta(o_i | q) / pi_theta_old(o_i | q).\n        A: List of advantage estimates (A_i).\n        pi_theta_old: List representing the old policy probabilities pi_theta_old(o_i | q).\n        pi_theta_ref: List representing the reference policy probabilities pi_ref(o_i | q).\n        epsilon: Clipping parameter (eps).\n        beta: KL divergence penalty coefficient (beta).\n\n    Returns:\n        The computed GRPO objective value.\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 6th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 102, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Swish Activation Function\n# Description:\nImplement the Swish activation function, a self-gated activation function that has shown superior performance in deep neural networks compared to ReLU. Your task is to compute the Swish value for a given input.\n# Your code should start with:\n```python\nimport math\nimport numpy as np\ndef swish(x: float) -> float:\n    \"\"\"\n    Implements the Swish activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The Swish activation value\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 103, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the SELU Activation Function\n# Description:\nImplement the SELU (Scaled Exponential Linear Unit) activation function, a self-normalizing variant of ELU. Your task is to compute the SELU value for a given input while ensuring numerical stability.\n# Your code should start with:\n```python\nimport math\nimport numpy as np\ndef selu(x: float) -> float:\n    \"\"\"\n    Implements the SELU (Scaled Exponential Linear Unit) activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        SELU activation value\n    \"\"\"\n    alpha = 1.6732632423543772\n    scale = 1.0507009873554804\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 104, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Binary Classification with Logistic Regression\n# Description:\nImplement the prediction function for binary classification using Logistic Regression. Your task is to compute class probabilities using the sigmoid function and return binary predictions based on a threshold of 0.5.\n# Your code should start with:\n```python\nimport numpy as np\ndef predict_logistic(X: np.ndarray, weights: np.ndarray, bias: float) -> list:\n    \"\"\"\n    Implements binary classification prediction using Logistic Regression.\n\n    Args:\n        X: Input feature matrix (shape: N \u00c3\u0097 D)\n        weights: Model weights (shape: D)\n        bias: Model bias\n\n    Returns:\n        Binary predictions (0 or 1)\n    \"\"\"\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 105, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Train Softmax Regression with Gradient Descent\n# Description:\nImplement a gradient descent-based training algorithm for Softmax regression. Your task is to compute model parameters using Cross Entropy loss and return the optimized coefficients along with collected loss values over iterations.\n# Your code should start with:\n```python\nimport numpy as np\ndef train_softmaxreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for Softmax regression, optimizing parameters with Cross Entropy loss.\n\n    Returns:\n        B : list[float], CxM updated parameter vector rounded to 4 floating points\n        losses : list[float], collected values of a Cross Entropy rounded to 4 floating points\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 106, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Train Logistic Regression with Gradient Descent\n# Description:\nImplement a gradient descent-based training algorithm for logistic regression. Your task is to compute model parameters using Binary Cross Entropy loss and return the optimized coefficients along with collected loss values over iterations(round to the 4th decimal).\n# Your code should start with:\n```python\nimport numpy as np\ndef train_logreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for logistic regression, optimizing parameters with Binary Cross Entropy loss.\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 107, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Masked Self-Attention\n# Description:\nImplement masked self-attention, a variation of the attention mechanism used in sequence modeling tasks such as text generation. Your task is to compute masked self-attention using query (Q), key (K), value (V) matrices and an attention mask.\n# Your code should start with:\n```python\nimport numpy as np\n\ndef compute_qkv(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray):\n    \"\"\"\n    Compute Query (Q), Key (K), and Value (V) matrices.\n    \"\"\"\n    Q = np.dot(X, W_q)\n    K = np.dot(X, W_k)\n    V = np.dot(X, W_v)\n    return Q, K, V\ndef masked_attention(Q: np.ndarray, K: np.ndarray, V: np.ndarray, mask: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute masked self-attention.\n    \"\"\"\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 108, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Measure Disorder in Apple Colors\n# Description:\nImplement a function that calculates the disorder in a basket of apples based on their colors, where each apple color is represented by an integer. The disorder must be 0 if all apples are the same color and must increase as the variety of colors increases. In particular:\n- [0,0,0,0] should yield 0.\n- [1,1,0,0] should have a higher disorder than [0,0,0,0].\n- [0,1,2,3] should have a higher disorder than [1,1,0,0].\n- [0,0,1,1,2,2,3,3] should have a higher disorder than [0,0,0,0,0,1,2,3].\nYou may use any method to measure disorder as long as these properties are satisfied.\n# Your code should start with:\n```python\ndef disorder(apples: list) -> float:\n    \"\"\"\n    Calculates a measure of disorder in a basket of apples based on their colors.\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 109, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Layer Normalization for Sequence Data\n# Description:\nImplement a function to perform Layer Normalization on an input tensor. Given a 3D array representing batch size, sequence length, and feature dimensions, normalize the data across the feature dimension for each sequence, then apply scaling and shifting parameters.\n# Your code should start with:\n```python\nimport numpy as np\ndef layer_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5):\n```\n# Output Constraints:\nThe normalized X should be rounded to 5 decimal places and converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 110, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Evaluate Translation Quality with METEOR Score\n# Description:\nDevelop a function to compute the METEOR score for evaluating machine translation quality. Given a reference translation and a candidate translation, calculate the score based on unigram matches, precision, recall, F-mean, and a penalty for word order fragmentation.\n# Your code should start with:\n```python\nimport numpy as np\nfrom collections import Counter\ndef meteor_score(reference, candidate, alpha=0.9, beta=3, gamma=0.5):\n```\n# Output Constraints:\nYour function should return a float value rounded to 3 decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 111, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Compute Pointwise Mutual Information\n# Description:\nImplement a function to compute the Pointwise Mutual Information (PMI) given the joint occurrence count of two events, their individual counts, and the total number of samples. PMI measures how much the actual joint occurrence of events differs from what we would expect by chance.\n# Your code should start with:\n```python\nimport numpy as np\ndef compute_pmi(joint_counts, total_counts_x, total_counts_y, total_samples):\n```\n# Output Constraints:\nYour function should return a float value rounded to 3 decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 112, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Min-Max Normalization of Feature Values\n# Description:\nImplement a function that performs Min-Max Normalization on a list of integers, scaling all values to the range [0, 1]. Min-Max normalization helps ensure that all features contribute equally to a model by scaling them to a common range.\n# Your code should start with:\n```python\ndef min_max(x: list[int]) -> list[float]:\n```\n# Output Constraints:\nYour function should return a list of floats rounded to 4 decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 113, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement a Simple Residual Block with Shortcut Connection\n# Description:\nImplement a function that creates a simple residual block using NumPy. The block should take a 1D input array, process it through two weight layers (using matrix multiplication), apply ReLU activations, and add the original input via a shortcut connection before a final ReLU activation.\n# Your code should start with:\n```python\nimport numpy as np\ndef residual_block(x: np.ndarray, w1: np.ndarray, w2: np.ndarray):\n```\n# Output Constraints:\nThe final output should be rounded to 4 decimal places and converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 114, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Global Average Pooling\n# Description:\nImplement a function that performs Global Average Pooling on a 3D NumPy array representing feature maps from a convolutional layer. The function should take an input of shape (height, width, channels) and return a 1D array of shape (channels,), where each element is the average of all values in the corresponding feature map.\n# Your code should start with:\n```python\nimport numpy as np\ndef global_avg_pool(x: np.ndarray):\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 115, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Batch Normalization for BCHW Input\n# Description:\nImplement a function that performs Batch Normalization on a 4D NumPy array representing a batch of feature maps in the BCHW format (batch, channels, height, width). The function should normalize the input across the batch and spatial dimensions for each channel, then apply scale (gamma) and shift (beta) parameters. Use the provided epsilon value to ensure numerical stability.\n# Your code should start with:\n```python\nimport numpy as np\ndef batch_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5):\n```\n# Output Constraints:\nThe final output should be rounded to 4 decimal places and converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 116, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Derivative of a Polynomial\n# Description:\nImplement a function that computes the derivative of a polynomial term of the form `c * x^n` at a given point `x`, where `c` is a coefficient and `n` is the exponent. The function should return the value of the derivative, accounting for the coefficient in the power rule. This is useful for understanding how polynomials change at specific points in machine learning optimization problems.\n# Your code should start with:\n```python\ndef poly_term_derivative(c: float, x: float, n: float) -> float:\n```\n# Output Constraints:\nYour function should return a float value rounded to 4 decimal places.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 117, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Compute Orthonormal Basis for 2D Vectors\n# Description:\nImplement a function that computes an orthonormal basis for the subspace spanned by a list of 2D vectors using the Gram-Schmidt process. The function should take a list of 2D vectors and a tolerance value (tol) to determine linear independence, returning a list of orthonormal vectors (unit length and orthogonal to each other) that span the same subspace. This is a fundamental concept in linear algebra with applications in machine learning, such as feature orthogonalization.\n# Your code should start with:\n```python\nimport numpy as np\ndef orthonormal_basis(vectors: list[list[float]], tol: float = 1e-10):\n```\n# Output Constraints:\nEvery basis within your return list should be rounded to 4 decimal places and converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 118, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Compute the Cross Product of Two 3D Vectors\n# Description:\nImplement a function to compute the cross product of two 3-dimensional vectors. The cross product of two vectors results in a third vector that is perpendicular to both and follows the right-hand rule. This concept is fundamental in physics, engineering, and 3D graphics.\n# Your code should start with:\n```python\nimport numpy as np\ndef cross_product(a, b):\n```\n# Output Constraints:\nThe final output should be rounded to 4 decimal places and converted to a list using tolist() when returned.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 119, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Solve System of Linear Equations Using Cramer's Rule\n# Description:\nImplement a function to solve a system of linear equations $Ax = b$ using Cramer's Rule. The function should take a square coefficient matrix $A$ and a constant vector $b$, and return the solution vector $x$. If the system has no unique solution (i.e., the determinant of $A$ is zero), return -1.\n# Your code should start with:\n```python\nimport numpy as np\ndef cramers_rule(A, b):\n```\n# Output Constraints:\nMake sure all valid results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 120, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Bhattacharyya Distance Between Two Distributions\n# Description:\nImplement a function to calculate the Bhattacharyya distance between two probability distributions. The function should take two lists representing discrete probability distributions `p` and `q`, and return the Bhattacharyya distance rounded to 4 decimal places. If the inputs have different lengths or are empty, return 0.0.\n# Your code should start with:\n```python\nimport numpy as np\ndef bhattacharyya_distance(p: list[float], q: list[float]) -> float:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 121, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Vector Element-wise Sum\n# Description:\nWrite a Python function that computes the element-wise sum of two vectors. The function should return a new vector representing the resulting sum if the operation is valid, or -1 if the vectors have incompatible dimensions. Two vectors (lists) can be summed element-wise only if they are of the same length.\n# Your code should start with:\n```python\ndef vector_sum(a: list[int|float], b: list[int|float]) -> list[int|float]:\n```\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 122, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Policy Gradient with REINFORCE\n# Description:\nImplement the policy gradient estimator using the REINFORCE algorithm. The policy is parameterized by a 2D NumPy array `theta` of shape `(num_states, num_actions)`. The policy for each state is computed via softmax over `theta[s, :]`. Given a list of episodes (each a list of (state, action, reward) tuples), compute the average gradient of the log-policy multiplied by the return at each time step.\n# Your code should start with:\n```python\nimport numpy as np\ndef compute_policy_gradient(theta: np.ndarray, episodes: list[list[tuple[int, int, float]]]):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 123, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Computational Efficiency of MoE\n# Description:\nCalculate the computational cost savings of an MoE layer compared to a dense layer, as discussed in the paper 'Outrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer.' Given the number of experts, sparsity (number of active experts), and input/output dimensions, compute the floating-point operations (FLOPs) for both and determine the savings percentage.\n# Your code should start with:\n```python\ndef compute_efficiency(n_experts, k_active, d_in, d_out):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 1th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 124, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Noisy Top-K Gating Function\n# Description:\nImplement the Noisy Top-K gating mechanism used in Mixture-of-Experts (MoE) models. Given an input matrix, weight matrices, pre-sampled noise, and a sparsity constraint k, compute the final gating probabilities matrix.\n# Your code should start with:\n```python\nimport numpy as np\ndef noisy_topk_gating(\n    X: np.ndarray,\n    W_g: np.ndarray,\n    W_noise: np.ndarray,\n    N: np.ndarray,\n    k: int\n):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 125, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement a Sparse Mixture of Experts Layer\n# Description:\nImplement a Mixture-of-Experts (MoE) layer using softmax gating and top-k routing. Given an input tensor, a set of expert weight matrices, a gating weight matrix, and parameters specifying the number of experts and the value of k, compute the final MoE output by selecting the top-k experts per token, applying their transformations, and aggregating the results weighted by the normalized gating probabilities.\n# Your code should start with:\n```python\nimport numpy as np\ndef moe(x: np.ndarray, We: np.ndarray, Wg: np.ndarray, n_experts: int, top_k: int):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 126, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Group Normalization\n# Description:\nWrite a Python function to perform Group Normalization on a 4D input tensor with shape (B, C, H, W). The function should normalize over smaller groups of channels, then apply a learned scale (gamma) and shift (beta).\n# Your code should start with:\n```python\nimport numpy as np\ndef group_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, num_groups: int, epsilon: float = 1e-5):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 127, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Find Captain Redbeard's Hidden Treasure\n# Description:\nCaptain Redbeard, the most daring pirate of the seven seas, has uncovered a mysterious ancient map.\nInstead of islands, it shows a strange wavy curve, and the treasure lies at the lowest point of the land! (watch out for those tricky local mins)\nThe land's height at any point $x$ is given by: $ f(x) = x^4 - 3x^3 + 2$.\nYour Mission: Implement a Python function that finds the value of $x$ where $f(x)$ reaches its minimum, starting from any random initial position.\n# Your code should start with:\n```python\nimport numpy as np\ndef find_treasure(start_x: float, learning_rate: float = 0.1, tolerance: float = 1e-6, max_iters: int = 10000) -> float:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 128, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Dynamic Tanh: Normalization-Free Transformer Activation\n# Description:\nImplement the Dynamic Tanh (DyT) function, a normalization-free transformation inspired by the Tanh function. DyT replaces layer normalization in Transformer architectures while preserving squashing behavior and enabling stable training.\n# Your code should start with:\n```python\nimport numpy as np\ndef dynamic_tanh(x: np.ndarray, alpha: float, gamma: float, beta: float) -> list[float]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease provide a self-contained Python script that solves the above task in a markdown code block.\n"}
