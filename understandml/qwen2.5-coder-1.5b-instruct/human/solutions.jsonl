{"task_id": 1, "completion_id": 0, "solution": "def matrix_dot_vector(a: list[list[int | float]], b: list[int | float]) -> list[int | float]:\n    if len(a[0]) != len(b):\n        return -1\n    result = [sum((row[i] * b[i] for i in range(len(row)))) for row in a]\n    return result"}
{"task_id": 2, "completion_id": 0, "solution": "def transpose_matrix(a: list[list[int | float]]) -> list[list[int | float]]:\n    \"\"\"\n    Compute the transpose of a given matrix.\n\n    Args:\n    a (list[list[int|float]]): A 2D list representing the input matrix.\n\n    Returns:\n    list[list[int|float]]: The transposed matrix.\n    \"\"\"\n    transposed = [[0 for _ in range(len(a))] for _ in range(len(a[0]))]\n    for i in range(len(a)):\n        for j in range(len(a[i])):\n            transposed[j][i] = a[i][j]\n    return transposed"}
{"task_id": 3, "completion_id": 0, "solution": "import numpy as np\ndef reshape_matrix(a: list[list[int | float]], new_shape: tuple[int, int]) -> list[list[int | float]]:\n    arr = np.array(a)\n    if arr.size != np.prod(new_shape):\n        return []\n    reshaped_arr = arr.reshape(*new_shape)\n    return reshaped_arr.tolist()"}
{"task_id": 4, "completion_id": 0, "solution": "def calculate_matrix_mean(matrix: list[list[float]], mode: str) -> list[float]:\n    \"\"\"\n    Calculate the mean of a matrix either by row or by column.\n\n    Parameters:\n    - matrix: A 2D list of floats representing the matrix.\n    - mode: A string indicating whether to calculate the mean by rows ('row') or columns ('column').\n\n    Returns:\n    - A list of means calculated by the specified mode.\n    \"\"\"\n    if mode == 'row':\n        means = [sum(row) / len(row) for row in matrix]\n    elif mode == 'column':\n        means = [sum(column) / len(column) for column in zip(*matrix)]\n    else:\n        raise ValueError(\"Invalid mode. Please choose 'row' or 'column'.\")\n    return means"}
{"task_id": 5, "completion_id": 0, "solution": "from typing import List, Union\ndef scalar_multiply(matrix: List[List[Union[int, float]]], scalar: Union[int, float]) -> List[List[Union[int, float]]]:\n    return [[element * scalar for element in row] for row in matrix]"}
{"task_id": 6, "completion_id": 0, "solution": "from typing import List\ndef calculate_eigenvalues(matrix: List[List[float | int]]) -> List[float]:\n    \"\"\"\n    Calculates the eigenvalues of a 2x2 matrix.\n\n    Args:\n        matrix (List[List[float|int]]): A 2x2 matrix represented as a list of lists.\n\n    Returns:\n        List[float]: A list containing the eigenvalues of the matrix, sorted from highest to lowest.\n    \"\"\"\n    a = matrix[0][0]\n    b = matrix[0][1]\n    c = matrix[1][0]\n    d = matrix[1][1]\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        raise ValueError('Matrix is singular and does not have real eigenvalues.')\n    lambda1 = (-b + discriminant ** 0.5) / (2 * a)\n    lambda2 = (-b - discriminant ** 0.5) / (2 * a)\n    return [lambda1, lambda2]\nmatrix = [[3, 1], [1, 2]]"}
{"task_id": 7, "completion_id": 0, "solution": "import numpy as np\ndef transform_matrix(A: list[list[int | float]], T: list[list[int | float]], S: list[list[int | float]]) -> list[list[int | float]]:\n    A = np.array(A)\n    T = np.array(T)\n    S = np.array(S)\n    if not np.linalg.det(T) or not np.linalg.det(S):\n        return -1\n    result = np.dot(np.dot(np.linalg.inv(T), A), np.linalg.inv(S))\n    result_rounded = np.round(result, 4).tolist()\n    return result_rounded\nA = [[1, 2], [3, 4]]\nT = [[2, 0], [0, 3]]\nS = [[-1, 0], [0, 5]]"}
{"task_id": 8, "completion_id": 0, "solution": "from typing import List\ndef inverse_2x2(matrix: List[List[float]]) -> List[List[float]]:\n    if len(matrix) != 2 or any((len(row) != 2 for row in matrix)):\n        return None\n    a = matrix[0][0]\n    b = matrix[0][1]\n    c = matrix[1][0]\n    d = matrix[1][1]\n    det = a * d - b * c\n    if det == 0:\n        return None\n    inv_matrix = [[d / det, -b / det], [-c / det, a / det]]\n    return inv_matrix"}
{"task_id": 9, "completion_id": 0, "solution": "def matrixmul(a: list[list[int | float]], b: list[list[int | float]]) -> list[list[int | float]]:\n    if len(a[0]) != len(b):\n        return -1\n    result = [[0 for _ in range(len(b[0]))] for _ in range(len(a))]\n    for i in range(len(a)):\n        for j in range(len(b[0])):\n            for k in range(len(b)):\n                result[i][j] += a[i][k] * b[k][j]\n    return result"}
{"task_id": 10, "completion_id": 0, "solution": "from typing import List\ndef calculate_covariance_matrix(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Calculate the covariance matrix for a given set of vectors.\n\n    Args:\n    vectors (List[List[float]]): A list of lists, where each inner list represents a feature with its observations.\n\n    Returns:\n    List[List[float]]: A covariance matrix as a list of lists.\n    \"\"\"\n    num_features = len(vectors[0])\n    num_vectors = len(vectors)\n    covariance_matrix = [[0.0] * num_features for _ in range(num_features)]\n    means = [sum(feature) / num_vectors for feature in zip(*vectors)]\n    for i in range(num_features):\n        for j in range(i, num_features):\n            variance_sum = 0.0\n            for vector in vectors:\n                variance_sum += (vector[i] - means[i]) * (vector[j] - means[j])\n            covariance_matrix[i][j] = variance_sum / (num_vectors - 1)\n            if i != j:\n                covariance_matrix[j][i] = covariance_matrix[i][j]\n    return covariance_matrix"}
{"task_id": 11, "completion_id": 0, "solution": "import numpy as np\ndef solve_jacobi(A: np.ndarray, b: np.ndarray, n: int) -> list:\n    \"\"\"\n    Solves a system of linear equations using the Jacobi method.\n\n    Parameters:\n    - A (np.ndarray): Coefficient matrix of the system of equations.\n    - b (np.ndarray): Right-hand side vector of the system of equations.\n    - n (int): Number of iterations for the Jacobi method.\n\n    Returns:\n    - list: An approximate solution to the system of equations, rounded to 4 decimal places.\n    \"\"\"\n    x = np.zeros_like(b)\n    for _ in range(n):\n        new_x = np.zeros_like(x)\n        for i in range(len(A)):\n            sum_term = np.dot(A[i, :i], new_x[:i]) + np.dot(A[i, i + 1:], x[i + 1:])\n            new_x[i] = (b[i] - sum_term) / A[i, i]\n        x = np.round(new_x, 4).tolist()\n    return x\nA = np.array([[2, 1], [3, 5]])\nb = np.array([8, 19])\nn = 10"}
{"task_id": 12, "completion_id": 0, "solution": "import numpy as np\ndef svd_2x2_singular_values(A: np.ndarray) -> tuple:\n    \"\"\"\n    Approximate the Singular Value Decomposition (SVD) on a 2x2 matrix using the Jacobian method.\n    \n    Parameters:\n    A (np.ndarray): A 2x2 square matrix.\n    \n    Returns:\n    tuple: A tuple containing the singular values of the matrix in descending order.\n    \"\"\"\n    n = A.shape[0]\n    if n != 2:\n        raise ValueError('Matrix must be 2x2')\n    J11 = np.array([[A[1, 1], -A[1, 0]], [-A[1, 0], A[0, 0]]])\n    J12 = np.array([[-A[0, 1], A[0, 0]], [A[0, 1], -A[1, 1]]])\n    J21 = np.array([[A[1, 1], -A[1, 0]], [-A[1, 0], A[0, 0]]])\n    J22 = np.array([[-A[0, 1], A[0, 0]], [A[0, 1], -A[1, 1]]])\n    det_J11 = np.linalg.det(J11)\n    det_J12 = np.linalg.det(J12)\n    det_J21 = np.linalg.det(J21)\n    det_J22 = np.linalg.det(J22)\n    lambda_1 = det_J11 / (det_J11 + det_J12)\n    lambda_2 = det_J22 / (det_J21 + det_J22)\n    singular_values = sorted((lambda_1, lambda_2), reverse=True)\n    singular_values_rounded = tuple((round(value, 4) for value in singular_values))\n    return singular_values_rounded\nA = np.array([[3, 1], [1, 2]])\nsingular_values = svd_2x2_singular_values(A)"}
{"task_id": 13, "completion_id": 0, "solution": "from typing import List, Union\ndef determinant_4x4(matrix: List[List[Union[int, float]]]) -> float:\n    if len(matrix) == 2:\n        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]\n    det = 0\n    sign = 1\n    for j in range(4):\n        sub_matrix = [row[:j] + row[j + 1:] for row in matrix[1:]]\n        det += sign * matrix[0][j] * determinant_4x4(sub_matrix)\n        sign *= -1\n    return det"}
{"task_id": 14, "completion_id": 0, "solution": "import numpy as np\ndef linear_regression_normal_equation(X: list[list[float]], y: list[float]) -> list[float]:\n    \"\"\"\n    Perform linear regression using the normal equation.\n\n    Args:\n        X (list[list[float]]): Features matrix (n_samples, n_features).\n        y (list[float]): Target vector (n_samples,).\n\n    Returns:\n        list[float]: Coefficients of the linear regression model (n_features + 1,).\n    \"\"\"\n    X = np.column_stack((np.ones(len(X)), X))\n    beta = np.linalg.inv(X.T @ X) @ X.T @ y\n    return [round(coef, 4) for coef in beta]\nX = [[1, 2], [3, 4], [5, 6]]\ny = [7, 8, 9]"}
{"task_id": 15, "completion_id": 0, "solution": "import numpy as np\ndef linear_regression_gradient_descent(X: np.ndarray, y: np.ndarray, alpha: float, iterations: int) -> np.ndarray:\n    m = len(y)\n    X = np.hstack((np.ones((m, 1)), X))\n    theta = np.zeros(X.shape[1])\n    for _ in range(iterations):\n        h = np.dot(X, theta)\n        error = h - y\n        gradient = np.dot(X.T, error) / m\n        theta -= alpha * gradient\n    return theta.round(4).tolist()"}
{"task_id": 16, "completion_id": 0, "solution": "import numpy as np\ndef feature_scaling(data: np.ndarray) -> (list[list[float]], list[list[float]]):\n    \"\"\"\n    Perform feature scaling on a given 2D numpy array.\n\n    Args:\n        data (np.ndarray): A 2D numpy array of shape (n_samples, n_features).\n\n    Returns:\n        tuple: Two lists of lists containing the scaled data. The first list contains\n               the standardized data, and the second list contains the normalized data.\n    \"\"\"\n    mean = np.mean(data, axis=0)\n    std_dev = np.std(data, axis=0)\n    standardized_data = (data - mean) / std_dev\n    min_val = np.min(data, axis=0)\n    max_val = np.max(data, axis=0)\n    normalized_data = (data - min_val) / (max_val - min_val)\n    return (standardized_data.tolist(), normalized_data.tolist())"}
{"task_id": 17, "completion_id": 0, "solution": "import numpy as np"}
{"task_id": 18, "completion_id": 0, "solution": "import numpy as np\ndef k_fold_cross_validation(X: np.ndarray, y: np.ndarray, k=5, shuffle=True, random_seed=None):\n    \"\"\"\n    Generate train and test splits for K-Fold Cross-Validation.\n\n    Args:\n        X (np.ndarray): Input features matrix.\n        y (np.ndarray): Target vector.\n        k (int): Number of folds.\n        shuffle (bool): Whether to shuffle the data before splitting.\n        random_seed (int): Random seed for reproducibility.\n\n    Returns:\n        List[int]: A list containing the train-test indices for each fold.\n    \"\"\"\n    if random_seed is not None:\n        np.random.seed(random_seed)\n    if X.shape[0] != y.shape[0]:\n        raise ValueError('The number of samples in X must be equal to the number of samples in y.')\n    if shuffle:\n        combined = np.hstack((X, y.reshape(-1, 1)))\n        np.random.shuffle(combined)\n        (X_shuffled, y_shuffled) = (combined[:, :-1], combined[:, -1])\n    fold_size = len(X) // k\n    train_test_indices = []\n    for i in range(k):\n        start_index = i * fold_size\n        end_index = start_index + fold_size\n        train_indices = np.arange(start_index, end_index)\n        test_indices = np.arange(end_index, len(X))\n        train_test_indices.append((train_indices, test_indices))\n    return train_test_indices"}
{"task_id": 19, "completion_id": 0, "solution": "import numpy as np\ndef pca(data: np.ndarray, k: int) -> list[list[float]]:\n    \"\"\"\n    Perform Principal Component Analysis on a given 2D NumPy array.\n\n    Parameters:\n    - data (np.ndarray): A 2D NumPy array where rows represent data samples and columns represent features.\n    - k (int): The number of principal components to return.\n\n    Returns:\n    - list[list[float]]: A list containing the principal components (eigenvectors).\n    \"\"\"\n    mean = np.mean(data, axis=0)\n    std_dev = np.std(data, axis=0)\n    standardized_data = (data - mean) / std_dev\n    cov_matrix = np.cov(standardized_data, rowvar=False)\n    (eigenvalues, eigenvectors) = np.linalg.eigh(cov_matrix)\n    sorted_indices = np.argsort(eigenvalues)[::-1]\n    sorted_eigenvalues = eigenvalues[sorted_indices]\n    sorted_eigenvectors = eigenvectors[:, sorted_indices]\n    return sorted_eigenvectors[:k].round(4)"}
{"task_id": 20, "completion_id": 0, "solution": "import math\nfrom collections import Counter\ndef learn_decision_tree(examples: list[dict], attributes: list[str], target_attr: str) -> dict:\n\n    def entropy(data):\n        labels = [example[target_attr] for example in data]\n        label_counts = Counter(labels)\n        total_count = len(labels)\n        entropy = 0.0\n        for count in label_counts.values():\n            probability = count / total_count\n            entropy -= probability * math.log2(probability)\n        return entropy\n    if all((example[target_attr] == examples[0][target_attr] for example in examples)):\n        return {target_attr: examples[0][target_attr]}\n    best_attribute = None\n    min_entropy = float('inf')\n    for attr in attributes:\n        unique_values = set([example[attr] for example in examples])\n        entropy_sum = 0.0\n        for value in unique_values:\n            subset = [example for example in examples if example[attr] == value]\n            subset_entropy = entropy(subset)\n            entropy_sum += len(subset) / len(examples) * subset_entropy\n        if entropy_sum < min_entropy:\n            min_entropy = entropy_sum\n            best_attribute = attr\n    tree = {best_attribute: {}}\n    for value in set([example[best_attribute] for example in examples]):\n        subset = [example for example in examples if example[best_attribute] == value]\n        subtree = learn_decision_tree(subset, attributes, target_attr)\n        tree[best_attribute][value] = subtree\n    return tree"}
{"task_id": 21, "completion_id": 0, "solution": "import numpy as np\ndef pegasos_kernel_svm(data: np.ndarray, labels: np.ndarray, kernel='linear', lambda_val=0.01, iterations=100, sigma=1.0):\n    \"\"\"\n    Train a kernel SVM classifier using the Pegasos algorithm.\n\n    Parameters:\n    - data: A 2D numpy array representing the input features.\n    - labels: A 1D numpy array representing the corresponding labels.\n    - kernel: A string indicating the type of kernel ('linear' or 'rbf').\n    - lambda_val: The regularization parameter for the SVM.\n    - iterations: The number of iterations for the Pegasos algorithm.\n    - sigma: The standard deviation for the Gaussian kernel (used only if kernel=='rbf').\n\n    Returns:\n    - A list containing the alpha coefficients and the bias of the trained model.\n    \"\"\"\n    (n_samples, n_features) = data.shape\n    alpha = np.zeros(n_samples)\n    bias = 0\n    for _ in range(iterations):\n        for i in range(n_samples):\n            xi = data[i]\n            yi = labels[i]\n            if kernel == 'linear':\n                prediction = np.dot(alpha, xi) + bias\n                if yi * prediction <= 1:\n                    alpha[i] += lambda_val / (n_samples * sigma ** 2)\n                    bias += yi\n            elif kernel == 'rbf':\n                dists = np.linalg.norm(xi - data, axis=1)\n                prediction = np.sum(np.exp(-dists ** 2 / (2 * sigma ** 2)) * alpha) + bias\n                if yi * prediction <= 1:\n                    alpha[i] += lambda_val / (n_samples * sigma ** 2)\n                    bias += yi\n    alpha_reshaped = alpha.reshape(1, -1)\n    return alpha_reshaped.tolist()\ndata = np.array([[1, 2], [3, 4], [5, 6]])\nlabels = np.array([1, -1, 1])"}
{"task_id": 22, "completion_id": 0, "solution": "import math\ndef sigmoid(z: float) -> float:\n    \"\"\"\n    Computes the output of the sigmoid activation function for a given input value z.\n    \n    Args:\n    z (float): The input value for which the sigmoid function is to be computed.\n    \n    Returns:\n    float: The output of the sigmoid function after rounding to four decimal places.\n    \"\"\"\n    result = 1 / (1 + math.exp(-z))\n    return round(result, 4)"}
{"task_id": 23, "completion_id": 0, "solution": "import math\ndef softmax(scores: list[float]) -> list[float]:\n    \"\"\"\n    Computes the softmax activation for a given list of scores.\n\n    Args:\n    scores (list[float]): A list of floating-point numbers representing the input scores.\n\n    Returns:\n    list[float]: A list of softmax values corresponding to the input scores, rounded to four decimal places.\n    \"\"\"\n    exp_scores = [math.exp(score) for score in scores]\n    total_exp = sum(exp_scores)\n    softmax_values = [exp / total_exp for exp in exp_scores]\n    rounded_softmax_values = [round(value, 4) for value in softmax_values]\n    return rounded_softmax_values\nscores = [1.0, 2.0, 3.0]"}
{"task_id": 24, "completion_id": 0, "solution": "import numpy as np\ndef sigmoid(x):\n    return 1 / (1 + math.exp(-x))\ndef single_neuron_model(features: list[list[float]], labels: list[int], weights: list[float], bias: float) -> (list[float], float):\n    features = np.array(features)\n    weighted_sum = np.dot(features, weights) + bias\n    predictions = [sigmoid(feature) for feature in weighted_sum]\n    mse = np.mean((predictions - labels) ** 2)\n    predictions_rounded = [round(prediction, 4) for prediction in predictions]\n    mse_rounded = round(mse, 4)\n    return (predictions_rounded, mse_rounded)"}
{"task_id": 25, "completion_id": 0, "solution": "import numpy as np\ndef train_neuron(features: np.ndarray, labels: np.ndarray, initial_weights: np.ndarray, initial_bias: float, learning_rate: float, epochs: int) -> (np.ndarray, float, list[float]):\n    weights = initial_weights.copy()\n    bias = initial_bias\n    mse_values = []\n    for epoch in range(epochs):\n        predictions = sigmoid(np.dot(features, weights) + bias)\n        errors = predictions - labels\n        bias -= learning_rate * np.mean(errors)\n        gradients = features.T @ errors / len(labels)\n        weights -= learning_rate * gradients\n        mse = np.mean((predictions - labels) ** 2)\n        mse_values.append(round(mse, 4))\n    return (weights, bias, mse_values.tolist())\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\nfeatures = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])\nlabels = np.array([0, 1, 1, 0])\ninitial_bias = 0\nlearning_rate = 0.5\nepochs = 100"}
{"task_id": 26, "completion_id": 0, "solution": "import numpy as np\nclass Value:\n\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0\n        self._backward = lambda : None\n        self._prev = set(_children)\n        self._op = _op\n\n    def backward(self):\n        topo = []\n        visited = set()\n\n        def build_topo(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._prev:\n                    build_topo(child)\n                topo.append(v)\n        build_topo(self)\n        self.grad = 1.0\n        for node in reversed(topo):\n            node._backward()\n\n    def __add__(self, other):\n        out = Value(self.data + other.data, (self, other), '+')\n\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        out = Value(self.data * other.data, (self, other), '*')\n\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n        out._backward = _backward\n        return out\n\n    def relu(self):\n        out = Value(max(0, self.data), (self,), 'ReLU')\n\n        def _backward():\n            self.grad += (self.data > 0) * out.grad\n        out._backward = _backward\n        return out"}
{"task_id": 27, "completion_id": 0, "solution": "import numpy as np\ndef transform_basis(B: list[list[int]], C: list[list[int]]) -> list[list[float]]:\n    B = np.array(B)\n    C = np.array(C)\n    P = np.linalg.inv(C).dot(B)\n    return P.tolist()"}
{"task_id": 28, "completion_id": 0, "solution": "import numpy as np\ndef svd_2x2(A: np.ndarray) -> tuple:\n    AT_A = np.dot(A.T, A)\n    (eigenvalues, eigenvectors) = np.linalg.eig(AT_A)\n    singular_values = np.sqrt(eigenvalues)\n    normalized_eigenvectors = eigenvectors / np.linalg.norm(eigenvectors, axis=0)\n    U = np.dot(np.diag(singular_values), normalized_eigenvectors)\n    return (U.tolist(), singular_values.tolist(), normalized_eigenvectors.tolist())"}
{"task_id": 29, "completion_id": 0, "solution": "import numpy as np\ndef shuffle_data(X, y, seed=None):\n    \"\"\"\n    Perform a random shuffle of the samples in two numpy arrays, X and y, while maintaining the corresponding order between them.\n\n    Parameters:\n    - X (numpy.ndarray): First input array.\n    - y (numpy.ndarray): Second input array.\n    - seed (int): Optional seed for reproducibility.\n\n    Returns:\n    - list: A list containing the shuffled X and y arrays.\n    \"\"\"\n    combined = np.hstack((X, y))\n    X_shuffled = combined[:, :-1]\n    y_shuffled = combined[:, -1:]\n    if seed is not None:\n        np.random.seed(seed)\n    np.random.shuffle(combined)\n    X_shuffled = combined[:, :-1]\n    y_shuffled = combined[:, -1:]\n    return [X_shuffled.tolist(), y_shuffled.tolist()]"}
{"task_id": 30, "completion_id": 0, "solution": "import numpy as np\ndef batch_iterator(X, y=None, batch_size=64):\n    \"\"\"\n    Yields batches from a numpy array X and an optional numpy array y.\n    \n    Parameters:\n    - X: numpy.ndarray, the input data.\n    - y: numpy.ndarray, optional, the target labels.\n    - batch_size: int, the size of each batch.\n    \n    Returns:\n    - A generator yielding batches of data or (X, y) pairs if y is provided.\n    \"\"\"\n    num_samples = len(X)\n    for i in range(0, num_samples, batch_size):\n        end_index = min(i + batch_size, num_samples)\n        batch_X = X[i:end_index]\n        if y is not None:\n            batch_y = y[i:end_index]\n            yield (batch_X, batch_y)\n        else:\n            yield batch_X"}
{"task_id": 31, "completion_id": 0, "solution": "import numpy as np\ndef divide_on_feature(X, feature_i, threshold):\n    \"\"\"\n    Divides a dataset into two subsets based on whether the value of a specified feature is greater than or equal to a given threshold.\n\n    Parameters:\n    X (np.ndarray): A 2D numpy array representing the dataset.\n    feature_i (int): The index of the feature to be used for division.\n    threshold (float): The threshold value for dividing the dataset.\n\n    Returns:\n    tuple: A tuple containing two numpy arrays. The first array contains rows where the value of the specified feature is greater than or equal to the threshold,\n           and the second array contains rows where the value of the specified feature is less than the threshold.\n    \"\"\"\n    mask_greater = X[:, feature_i] >= threshold\n    mask_less = X[:, feature_i] < threshold\n    subset_greater = X[mask_greater]\n    subset_less = X[mask_less]\n    subset_greater_list = subset_greater.tolist()\n    subset_less_list = subset_less.tolist()\n    return (subset_greater_list, subset_less_list)"}
{"task_id": 32, "completion_id": 0, "solution": "import numpy as np\nfrom itertools import combinations_with_replacement\ndef polynomial_features(X, degree):\n    \"\"\"\n    Generate polynomial features for a given dataset.\n\n    Parameters:\n    - X (np.ndarray): A 2D numpy array where each row represents a data point.\n    - degree (int): The degree of the polynomial features to be generated.\n\n    Returns:\n    - np.ndarray: A 2D numpy array containing the polynomial features.\n    \"\"\"\n    poly_features = []\n    for r in range(degree + 1):\n        for combo in combinations_with_replacement(range(len(X[0])), r):\n            power_values = [X[:, i] ** power for (i, power) in enumerate(combo)]\n            feature_vector = np.concatenate(power_values)\n            poly_features.append(feature_vector)\n    poly_features_array = np.array(poly_features).T\n    return poly_features_array.tolist()"}
{"task_id": 33, "completion_id": 0, "solution": "import numpy as np\ndef get_random_subsets(X, y, n_subsets, replacements=True, seed=42):\n    \"\"\"\n    Generates random subsets of a given dataset.\n\n    Parameters:\n        X (np.ndarray): A 2D numpy array representing the dataset features.\n        y (np.ndarray): A 1D numpy array representing the dataset labels.\n        n_subsets (int): The number of random subsets to generate.\n        replacements (bool): Whether to allow subsets to contain duplicate elements (True) or not (False).\n        seed (int): The random seed for reproducibility.\n\n    Returns:\n        List of tuples containing random subsets of (X_subset, y_subset).\n    \"\"\"\n    np.random.seed(seed)\n    indices = np.arange(len(y))\n    subsets = []\n    for _ in range(n_subsets):\n        if replacements:\n            selected_indices = np.random.choice(indices, size=len(y), replace=True)\n        else:\n            selected_indices = np.random.choice(indices, size=len(y), replace=False)\n        X_subset = X[selected_indices]\n        y_subset = y[selected_indices]\n        subsets.append((X_subset, y_subset))\n    return subsets.tolist()\nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([0, 1, 0])\nn_subsets = 3\nsubsets = get_random_subsets(X, y, n_subsets)"}
{"task_id": 34, "completion_id": 0, "solution": "import numpy as np\ndef to_categorical(x, n_col=None):\n    \"\"\"\n    Perform one-hot encoding of nominal values.\n\n    Parameters:\n    - x (np.ndarray): A 1D numpy array of integer values.\n    - n_col (int, optional): Number of columns for the one-hot encoded array. Defaults to None.\n\n    Returns:\n    - list: One-hot encoded array as a list of lists.\n    \"\"\"\n    if n_col is None:\n        n_col = max(x) + 1\n    one_hot_encoded = [[0] * n_col for _ in range(len(x))]\n    for (i, val) in enumerate(x):\n        one_hot_encoded[i][val] = 1\n    return one_hot_encoded.tolist()\nx = np.array([1, 2, 3, 4, 5])\none_hot_encoded = to_categorical(x)"}
{"task_id": 35, "completion_id": 0, "solution": "import numpy as np\ndef make_diagonal(x):\n    \"\"\"\n    Converts a 1D numpy array to a diagonal matrix.\n\n    Args:\n    x (np.array): A 1D numpy array of shape (n,) where n is the number of elements in the diagonal.\n\n    Returns:\n    np.array: A 2D numpy array representing the diagonal matrix.\n    \"\"\"\n    diagonal_matrix = np.diag(x)\n    return diagonal_matrix.tolist()"}
{"task_id": 36, "completion_id": 0, "solution": "import numpy as np\ndef accuracy_score(y_true, y_pred):\n    \"\"\"\n    Calculate the accuracy score of a model's predictions.\n\n    Args:\n    - y_true (np.array): An array containing the true labels.\n    - y_pred (np.array): An array containing the predicted labels.\n\n    Returns:\n    - float: The accuracy score as a float, rounded to the nearest 4th decimal.\n    \"\"\"\n    y_true_bool = y_true.astype(bool)\n    y_pred_bool = y_pred.astype(bool)\n    correct_predictions = np.sum(y_true_bool == y_pred_bool)\n    total_samples = len(y_true)\n    accuracy = correct_predictions / total_samples\n    return round(accuracy, 4)\ny_true = np.array([0, 1, 0, 1])"}
{"task_id": 37, "completion_id": 0, "solution": "import numpy as np\ndef calculate_correlation_matrix(X, Y=None):\n    \"\"\"\n    Calculate the correlation matrix for a given dataset.\n\n    Parameters:\n    X (np.array): A 2D numpy array representing the data.\n    Y (np.array, optional): An optional 2D numpy array representing another dataset. If None, calculates the correlation matrix of X with itself.\n\n    Returns:\n    np.array: A 2D numpy array representing the correlation matrix.\n    \"\"\"\n    if Y is None:\n        correlation_matrix = np.corrcoef(X)\n    else:\n        correlation_matrix = np.corrcoef(X, Y)\n    correlation_matrix_rounded = np.round(correlation_matrix, 4)\n    correlation_list = correlation_matrix_rounded.tolist()\n    return correlation_list\nX = np.array([[1, 2], [3, 4]])\nY = np.array([[5, 6], [7, 8]])"}
{"task_id": 38, "completion_id": 0, "solution": "import numpy as np\nimport math\ndef adaboost_fit(X, y, n_clf):\n    n_samples = X.shape[0]\n    sample_weights = np.ones(n_samples) / n_samples\n    classifiers = []\n    for _ in range(n_clf):\n        best_thresholds = [np.inf] * X.shape[1]\n        best_error = float('inf')\n        for feature_idx in range(X.shape[1]):\n            sorted_indices = np.argsort(X[:, feature_idx])\n            thresholds = np.unique(X[sorted_indices, feature_idx])\n            for threshold in thresholds:\n                left_mask = X[:, feature_idx] <= threshold\n                right_mask = X[:, feature_idx] > threshold\n                left_error = sum(sample_weights[left_mask] * (y[left_mask] != 1))\n                right_error = sum(sample_weights[right_mask] * (y[right_mask] != -1))\n                total_error = left_error + right_error\n                if total_error < best_error:\n                    best_error = total_error\n                    best_threshold = threshold\n                    alpha = 0.5 * math.log((1 - best_error) / best_error)\n                    for i in range(n_samples):\n                        if X[i, feature_idx] <= best_threshold:\n                            sample_weights[i] *= math.exp(-alpha)\n                        else:\n                            sample_weights[i] *= math.exp(alpha)\n                    sample_weights /= sum(sample_weights)\n                    classifiers.append({'feature': feature_idx, 'threshold': best_threshold, 'alpha': alpha})\n    return classifiers"}
{"task_id": 39, "completion_id": 0, "solution": "import numpy as np\ndef log_softmax(scores: list):\n    scores_array = np.array(scores)\n    exp_scores = np.exp(scores_array)\n    sum_exp_scores = np.sum(exp_scores)\n    log_softmax_values = np.log(exp_scores) - np.log(sum_exp_scores)\n    return log_softmax_values.tolist()"}
{"task_id": 40, "completion_id": 0, "solution": "import numpy as np\nimport copy\nimport math\nclass Layer(object):\n\n    def set_input_shape(self, shape):\n        self.input_shape = shape\n\n    def layer_name(self):\n        return self.__class__.__name__\n\n    def parameters(self):\n        return 0\n\n    def forward_pass(self, X, training):\n        raise NotImplementedError()\n\n    def backward_pass(self, accum_grad):\n        raise NotImplementedError()\n\n    def output_shape(self):\n        raise NotImplementedError()\nclass Dense(Layer):\n\n    def __init__(self, n_units, input_shape=None):\n        self.layer_input = None\n        self.input_shape = input_shape\n        self.n_units = n_units\n        self.trainable = True\n        self.W = None\n        self.w0 = None\n    '\\n    implement the Dense class based on the above structure\\n    '\n\n    def initialize(self):\n        if self.input_shape is not None:\n            self.W = np.random.uniform(-1 / np.sqrt(self.input_shape[0]), 1 / np.sqrt(self.input_shape[0]), (self.input_shape[0], self.n_units))\n            self.w0 = np.zeros((1, self.n_units))\n            self.optimizer_W = copy.deepcopy(self.input_shape)\n            self.optimizer_w0 = copy.deepcopy(self.n_units)\n\n    def parameters(self):\n        return sum([self.W.size, self.w0.size])\n\n    def forward_pass(self, X, training):\n        self.layer_input = X\n        return np.dot(X, self.W) + self.w0\n\n    def backward_pass(self, accum_grad):\n        dW = np.dot(self.layer_input.T, accum_grad)\n        dw0 = np.sum(accum_grad, axis=0, keepdims=True)\n        if self.trainable:\n            self.W -= self.optimizer_W * dW\n            self.w0 -= self.optimizer_w0 * dw0\n        return dW\n\n    def output_shape(self):\n        return (self.n_units,)"}
{"task_id": 41, "completion_id": 0, "solution": "import numpy as np\ndef simple_conv2d(input_matrix: np.ndarray, kernel: np.ndarray, padding: int, stride: int):\n    out_height = (input_matrix.shape[0] - kernel.shape[0] + 2 * padding) // stride + 1\n    out_width = (input_matrix.shape[1] - kernel.shape[1] + 2 * padding) // stride + 1\n    if padding > 0:\n        padded_input = np.pad(input_matrix, ((padding, padding), (padding, padding)), mode='constant', constant_values=0)\n    else:\n        padded_input = input_matrix\n    output_matrix = np.zeros((out_height, out_width))\n    for i in range(out_height):\n        for j in range(out_width):\n            patch = padded_input[i * stride:i * stride + kernel.shape[0], j * stride:j * stride + kernel.shape[1]]\n            output_matrix[i, j] = np.sum(patch * kernel)\n    return output_matrix.tolist()\ninput_matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nkernel = np.array([[1, 0], [0, 1]])\npadding = 1\nstride = 2"}
{"task_id": 42, "completion_id": 0, "solution": "def relu(z: float) -> float:\n    \"\"\"\n    Applies the Rectified Linear Unit (ReLU) activation function to the given input.\n\n    Args:\n    z (float): Input value\n\n    Returns:\n    float: Output after applying the ReLU function\n    \"\"\"\n    return max(0, z)"}
{"task_id": 43, "completion_id": 0, "solution": "import numpy as np\ndef ridge_loss(X: np.ndarray, w: np.ndarray, y_true: np.ndarray, alpha: float) -> float:\n    \"\"\"\n    Calculate the Ridge Regression loss.\n\n    Args:\n        X (np.ndarray): Feature matrix of shape (n_samples, n_features).\n        w (np.ndarray): Coefficients vector of shape (n_features,).\n        y_true (np.ndarray): True labels of shape (n_samples,).\n        alpha (float): Regularization parameter.\n\n    Returns:\n        float: Ridge loss value.\n    \"\"\"\n    y_pred = np.dot(X, w)\n    mse = np.mean((y_true - y_pred) ** 2)\n    regularization_term = alpha * np.sum(w ** 2)\n    total_loss = mse + regularization_term\n    return round(total_loss, 4)"}
{"task_id": 44, "completion_id": 0, "solution": "import math\ndef leaky_relu(z: float, alpha: float=0.01) -> float | int:\n    \"\"\"\n    Applies the Leaky Rectified Linear Unit (Leaky ReLU) activation function to the input z.\n\n    Parameters:\n    - z: A float representing the input value.\n    - alpha: A float representing the slope for negative inputs, with a default value of 0.01.\n\n    Returns:\n    - The result of the Leaky ReLU activation function applied to z.\n    \"\"\"\n    if z < 0:\n        return alpha * z\n    else:\n        return z"}
{"task_id": 45, "completion_id": 0, "solution": "import numpy as np\ndef kernel_function(x1, x2):\n    \"\"\"\n    Compute the linear kernel between two input vectors x1 and x2.\n\n    Parameters:\n    x1 (np.ndarray): First input vector.\n    x2 (np.ndarray): Second input vector.\n\n    Returns:\n    float: The computed linear kernel value.\n    \"\"\"\n    return np.dot(x1, x2)"}
{"task_id": 46, "completion_id": 0, "solution": "import numpy as np\ndef precision(y_true, y_pred):\n    \"\"\"\n    Calculate the precision metric for binary classification.\n\n    Args:\n    y_true (np.ndarray): A 1D numpy array containing the true binary labels.\n    y_pred (np.ndarray): A 1D numpy array containing the predicted binary labels.\n\n    Returns:\n    float: The precision score.\n    \"\"\"\n    tp = np.sum((y_true == 1) & (y_pred == 1))\n    fp = np.sum((y_true == 0) & (y_pred == 1))\n    if tp + fp > 0:\n        precision_score = tp / (tp + fp)\n    else:\n        precision_score = 0\n    return precision_score"}
{"task_id": 47, "completion_id": 0, "solution": "import numpy as np\ndef gradient_descent(X, y, weights, learning_rate, n_iterations, batch_size=1, method='batch'):\n    if method == 'sgd':\n        for _ in range(n_iterations):\n            random_index = np.random.randint(0, len(X))\n            x_batch = X[random_index].reshape(1, -1)\n            y_batch = y[random_index]\n            gradient = 2 * x_batch.T.dot(x_batch.dot(weights) - y_batch) / batch_size\n            weights -= learning_rate * gradient\n    elif method == 'batch':\n        for _ in range(n_iterations):\n            gradient = 2 * X.T.dot(X.dot(weights) - y) / len(X)\n            weights -= learning_rate * gradient\n    elif method == 'mini_batch':\n        for i in range(0, len(X), batch_size):\n            x_batch = X[i:i + batch_size]\n            y_batch = y[i:i + batch_size]\n            gradient = 2 * x_batch.T.dot(x_batch.dot(weights) - y_batch) / batch_size\n            weights -= learning_rate * gradient\n    return weights.tolist()"}
{"task_id": 48, "completion_id": 0, "solution": "import numpy as np\ndef rref(matrix):\n    A = np.array(matrix)\n    rank = np.linalg.matrix_rank(A)\n    A = np.round(A, decimals=6)\n    rref_matrix = np.zeros((rank, A.shape[1]))\n    for i in range(rank):\n        pivot_row = np.argmax(np.abs(A[i:, i])) + i\n        if pivot_row != i:\n            A[[i, pivot_row]] = A[[pivot_row, i]]\n        A[i] /= A[i, i]\n        for j in range(i + 1, rank):\n            factor = A[j, i]\n            A[j] -= factor * A[i]\n    rref_matrix = rref_matrix[:rank, :].tolist()\n    return rref_matrix\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}
{"task_id": 49, "completion_id": 0, "solution": "import numpy as np\ndef adam_optimizer(f, grad, x0, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08, num_iterations=1000):\n    m = np.zeros_like(x0)\n    v = np.zeros_like(x0)\n    for i in range(num_iterations):\n        g = grad(x0)\n        m = beta1 * m + (1 - beta1) * g\n        v = beta2 * v + (1 - beta2) * g ** 2\n        m_hat = m / (1 - beta1 ** (i + 1))\n        v_hat = v / (1 - beta2 ** (i + 1))\n        x0 -= learning_rate * m_hat / (np.sqrt(v_hat) + epsilon)\n    return x0.tolist()"}
{"task_id": 50, "completion_id": 0, "solution": "import numpy as np\ndef l1_regularization_gradient_descent(X: np.array, y: np.array, alpha: float=0.1, learning_rate: float=0.01, max_iter: int=1000, tol: float=0.0001) -> tuple:\n    (n_samples, n_features) = X.shape\n    w = np.zeros(n_features)\n    b = 0\n    for _ in range(max_iter):\n        y_pred = np.dot(X, w) + b\n        dw = np.mean(X.T * (y_pred - y) + alpha * np.sign(w), axis=1)\n        db = np.mean(y_pred - y)\n        w -= learning_rate * dw\n        b -= learning_rate * db\n        loss = np.mean((y_pred - y) ** 2) + alpha * np.sum(np.abs(w))\n        if np.abs(loss - previous_loss) < tol:\n            break\n        previous_loss = loss\n    return (w.tolist(), b.tolist())"}
{"task_id": 51, "completion_id": 0, "solution": "import numpy as np\ndef OSA(source: str, target: str) -> int:\n    (m, n) = (len(source), len(target))\n    dp = np.zeros((m + 1, n + 1), dtype=int)\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if source[i - 1] == target[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    return dp[m][n]\nsource = 'caper'\ntarget = 'acer'"}
{"task_id": 52, "completion_id": 0, "solution": "import numpy as np\ndef recall(y_true, y_pred):\n    \"\"\"\n    Calculate the recall metric in binary classification.\n\n    Parameters:\n    - y_true: List of true binary labels (0 or 1).\n    - y_pred: List of predicted binary labels (0 or 1).\n\n    Returns:\n    - float: The recall value rounded to three decimal places.\n    \"\"\"\n    TP = sum((1 for (t, p) in zip(y_true, y_pred) if t == 1 and p == 1))\n    FN = sum((1 for (t, p) in zip(y_true, y_pred) if t == 1 and p == 0))\n    recall_value = TP / (TP + FN) if TP + FN != 0 else 0.0\n    return round(recall_value, 3)"}
{"task_id": 53, "completion_id": 0, "solution": "import numpy as np\ndef self_attention(X, W_q, W_k, W_v):\n    \"\"\"\n    Implement the self-attention mechanism.\n\n    Args:\n        X (numpy.ndarray): Input data with shape (batch_size, seq_len, embedding_dim).\n        W_q (numpy.ndarray): Query matrix with shape (embedding_dim, hidden_dim).\n        W_k (numpy.ndarray): Key matrix with shape (embedding_dim, hidden_dim).\n        W_v (numpy.ndarray): Value matrix with shape (embedding_dim, hidden_dim).\n\n    Returns:\n        numpy.ndarray: Self-attention output with shape (batch_size, seq_len, hidden_dim).\n    \"\"\"\n    Q = np.dot(X, W_q)\n    K = np.dot(X, W_k)\n    V = np.dot(X, W_v)\n    attn_scores = np.matmul(Q, K.T) / np.sqrt(W_k.shape[1])\n    attn_weights = np.softmax(attn_scores, axis=1)\n    context_vector = np.sum(attn_weights * V, axis=1)\n    return context_vector.tolist()"}
{"task_id": 54, "completion_id": 0, "solution": "import numpy as np\ndef rnn_forward(input_sequence: list[list[float]], initial_hidden_state: list[float], Wx: list[list[float]], Wh: list[list[float]], b: list[float]) -> list[float]:\n    output = []\n    input_sequence_np = np.array(input_sequence)\n    initial_hidden_state_np = np.array(initial_hidden_state)\n    (seq_len, input_dim) = input_sequence_np.shape\n    num_units = len(Wx[0])\n    input_dim = len(Wx)\n    initial_hidden_state_np = np.reshape(initial_hidden_state_np, (1, num_units))\n    for t in range(seq_len):\n        weighted_sum = np.dot(input_sequence_np[t], Wx) + np.dot(initial_hidden_state_np, Wh) + b\n        next_hidden_state = np.tanh(weighted_sum)\n        output.append(next_hidden_state.tolist())\n        initial_hidden_state_np = next_hidden_state_np\n    return output"}
{"task_id": 55, "completion_id": 0, "solution": "import numpy as np\ndef translate_object(points, tx, ty):\n    \"\"\"\n    Applies a 2D translation matrix to a set of points.\n\n    Args:\n    - points (list): A list of [x, y] coordinates.\n    - tx (float): The translation distance in the x direction.\n    - ty (float): The translation distance in the y direction.\n\n    Returns:\n    - list: A new list of points after applying the translation matrix.\n    \"\"\"\n    points_array = np.array(points)\n    translation_matrix = np.array([[1, 0, tx], [0, 1, ty], [0, 0, 1]])\n    translated_points = np.dot(translation_matrix, points_array.T).T\n    return translated_points.tolist()"}
{"task_id": 56, "completion_id": 0, "solution": "import numpy as np\ndef kl_divergence_normal(mu_p, sigma_p, mu_q, sigma_q):\n    \"\"\"\n    Calculate the Kullback-Leibler (KL) divergence between two normal distributions.\n\n    Parameters:\n    - mu_p: Mean of the first normal distribution (float)\n    - sigma_p: Standard deviation of the first normal distribution (float)\n    - mu_q: Mean of the second normal distribution (float)\n    - sigma_q: Standard deviation of the second normal distribution (float)\n\n    Returns:\n    - The KL divergence as a float\n    \"\"\"\n    if sigma_p == 0 or sigma_q == 0:\n        raise ValueError('Both standard deviations must be non-zero.')\n    kl_div = (sigma_p ** 2 + (mu_p - mu_q) ** 2) / (2 * sigma_q ** 2) - 1 / 2\n    return kl_div\nmu_p = 0\nsigma_p = 1\nmu_q = 1\nsigma_q = 2"}
{"task_id": 57, "completion_id": 0, "solution": "import numpy as np\ndef gauss_seidel(A, b, n, x_ini=None):\n    if x_ini is None:\n        x_ini = np.zeros_like(b)\n    A = np.array(A)\n    b = np.array(b)\n    m = A.shape[0]\n    x = x_ini\n    for _ in range(n):\n        for i in range(m):\n            x[i] = (b[i] - np.dot(A[i, :i], x[:i]) + np.dot(A[i, i + 1:], x[i + 1:])) / A[i, i]\n    return x.tolist()\nA = [[3, 2, 1], [1, 4, 2], [2, 1, 3]]\nb = [5, 8, 9]\nn = 100"}
{"task_id": 58, "completion_id": 0, "solution": "import numpy as np\ndef gaussian_elimination(A, b):\n    n = A.shape[0]\n    for i in range(n - 1):\n        max_row_index = i\n        for j in range(i + 1, n):\n            if abs(A[j, i]) > abs(A[max_row_index, i]):\n                max_row_index = j\n        A[[i, max_row_index]] = A[[max_row_index, i]]\n        b[[i, max_row_index]] = b[[max_row_index, i]]\n        A[i, :] /= A[i, i]\n        for j in range(i + 1, n):\n            factor = A[j, i]\n            A[j, :] -= factor * A[i, :]\n            b[j] -= factor * b[i]\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        x[i] = (b[i] - np.dot(A[i, i + 1:], x[i + 1:])) / A[i, i]\n    return [round(val, 4) for val in x.tolist()]\nA = np.array([[3, 2, 1], [1, 4, 5], [6, 7, 8]])\nb = np.array([9, 12, 15])"}
{"task_id": 59, "completion_id": 0, "solution": "import numpy as np\nclass LSTM:\n\n    def __init__(self, input_size, hidden_size):\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n        self.Wf = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wi = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wc = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wo = np.random.randn(hidden_size, input_size + hidden_size)\n        self.bf = np.zeros((hidden_size, 1))\n        self.bi = np.zeros((hidden_size, 1))\n        self.bc = np.zeros((hidden_size, 1))\n        self.bo = np.zeros((hidden_size, 1))\n\n    def forward(self, x, initial_hidden_state, initial_cell_state):\n        \"\"\"\n        Processes a sequence of inputs and returns the hidden states, final hidden state, and final cell state.\n        \"\"\"\n        batch_size = x.shape[0]\n        num_steps = x.shape[1]\n        hidden_states = []\n        cell_states = []\n        h = initial_hidden_state\n        c = initial_cell_state\n        for t in range(num_steps):\n            concat_input = np.hstack((x[t], h))\n            f = sigmoid(concat_input.dot(self.Wf) + self.bf)\n            i = sigmoid(concat_input.dot(self.Wi) + self.bi)\n            g = tanh(concat_input.dot(self.Wc) + self.bc)\n            c = f * c + i * g\n            o = sigmoid(concat_input.dot(self.Wo) + self.bo)\n            h = o * tanh(c)\n            hidden_states.append(h.reshape(-1))\n            cell_states.append(c.reshape(-1))\n        return (hidden_states, h.reshape(-1), c.reshape(-1))\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\ndef tanh(x):\n    return np.tanh(x)\ninput_size = 5\nhidden_size = 3\nnum_steps = 10\nbatch_size = 2\nx = np.random.rand(batch_size, num_steps, input_size)\ninitial_hidden_state = np.zeros((batch_size, hidden_size))\ninitial_cell_state = np.zeros((batch_size, hidden_size))"}
{"task_id": 60, "completion_id": 0, "solution": "import numpy as np\ndef compute_tf_idf(corpus, query):\n    \"\"\"\n    Compute the TF-IDF scores for a query against a given corpus of documents.\n\n    Parameters:\n    - corpus: List of documents, where each document is a list of words.\n    - query: List of words for which you want to compute the TF-IDF scores.\n\n    Returns:\n    - A list of lists containing the TF-IDF scores for the query words in each document,\n      rounded to five decimal places.\n    \"\"\"\n    if not corpus:\n        raise ValueError('Corpus cannot be empty.')\n    df = {}\n    for doc in corpus:\n        for word in doc:\n            if word in df:\n                df[word] += 1\n            else:\n                df[word] = 1\n    num_docs = len(corpus)\n    tf = []\n    for doc in corpus:\n        term_freq = {}\n        for word in doc:\n            if word in term_freq:\n                term_freq[word] += 1\n            else:\n                term_freq[word] = 1\n        tf.append(term_freq)\n    idf = []\n    for (word, count) in df.items():\n        idf.append(np.log(num_docs / count))\n    tfidf_scores = []\n    for (i, doc) in enumerate(tf):\n        doc_tfidf = []\n        for (word, freq) in doc.items():\n            doc_tfidf.append(freq * idf[df.index(word)])\n        tfidf_scores.append(doc_tfidf)\n    tfidf_scores = [[round(score, 5) for score in row] for row in tfidf_scores]\n    return tfidf_scores.tolist()"}
{"task_id": 61, "completion_id": 0, "solution": "import numpy as np\ndef f_score(y_true, y_pred, beta):\n    \"\"\"\n    Calculate F-Score for a binary classification task.\n\n    :param y_true: Numpy array of true labels\n    :param y_pred: Numpy array of predicted labels\n    :param beta: The weight of precision in the harmonic mean\n    :return: F-Score rounded to three decimal places\n    \"\"\"\n    tp = np.sum((y_true == 1) & (y_pred == 1))\n    fp = np.sum((y_true == 0) & (y_pred == 1))\n    fn = np.sum((y_true == 1) & (y_pred == 0))\n    precision = tp / (tp + fp) if tp + fp != 0 else 0\n    recall = tp / (tp + fn) if tp + fn != 0 else 0\n    f_score = (1 + beta ** 2) * (precision * recall) / (beta ** 2 * precision + recall)\n    return round(f_score, 3)"}
{"task_id": 62, "completion_id": 0, "solution": "import numpy as np\nclass SimpleRNN:\n\n    def __init__(self, input_size, hidden_size, output_size):\n        \"\"\"\n        Initializes the RNN with random weights and zero biases.\n        \"\"\"\n        self.hidden_size = hidden_size\n        self.W_xh = np.random.randn(hidden_size, input_size) * 0.01\n        self.W_hh = np.random.randn(hidden_size, hidden_size) * 0.01\n        self.W_hy = np.random.randn(output_size, hidden_size) * 0.01\n        self.b_h = np.zeros((hidden_size, 1))\n        self.b_y = np.zeros((output_size, 1))\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass through the RNN for a given sequence of inputs.\n        \"\"\"\n        h_t = np.zeros((self.hidden_size, 1))\n        y_t = np.zeros((self.output_size, 1))\n        for t in range(x.shape[0]):\n            h_t = np.tanh(np.dot(self.W_xh, x[t]) + np.dot(self.W_hh, h_t) + self.b_h)\n            y_t = np.dot(self.W_hy, h_t) + self.b_y\n        return (y_t, h_t)\n\n    def backward(self, W_xh, W_hh, W_hy, b_h, b_y, hidden_size, input_sequence, expected_output, outputs, last_inputs, last_hiddens, learning_rate):\n        \"\"\"\n        Perform backpropagation through time (BPTT) to adjust the weights based on the loss.\n        \"\"\"\n        dW_xh = np.zeros_like(W_xh)\n        dW_hh = np.zeros_like(W_hh)\n        dW_hy = np.zeros_like(W_hy)\n        db_h = np.zeros_like(b_h)\n        db_y = np.zeros_like(b_y)\n        delta_y = outputs[-1] - expected_output\n        dW_hy += np.dot(delta_y, last_hiddens[-1].T)\n        db_y += delta_y\n        dh_next = np.dot(W_hy.T, delta_y)\n        for t in reversed(range(len(outputs) - 1)):\n            delta_h = dh_next * (1 - outputs[t] ** 2)\n            dW_hh += np.dot(delta_h, last_hiddens[t].T)\n            db_h += delta_h\n            dh_next = np.dot(W_hh.T, delta_h)\n        self.W_xh -= learning_rate * dW_xh\n        self.W_hh -= learning_rate * dW_hh\n        self.W_hy -= learning_rate * dW_hy\n        self.b_h -= learning_rate * db_h\n        self.b_y -= learning_rate * db_y"}
{"task_id": 63, "completion_id": 0, "solution": "import numpy as np\ndef conjugate_gradient(A: np.array, b: np.array, n: int, x0: np.array=None, tol=1e-08):\n    \"\"\"\n    Solve the system Ax = b using the Conjugate Gradient method.\n\n    :param A: Symmetric positive-definite matrix\n    :param b: Right-hand side vector\n    :param n: Maximum number of iterations\n    :param x0: Initial guess for solution (default is zero vector)\n    :param tol: Convergence tolerance\n    :return: Solution vector x\n    \"\"\"\n    if x0 is None:\n        x0 = np.zeros_like(b)\n    r = b - np.dot(A, x0)\n    p = r.copy()\n    rsold = np.dot(r, r)\n    for i in range(n):\n        Ap = np.dot(A, p)\n        alpha = rsold / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = np.dot(r, r)\n        beta = rsnew / rsold\n        p = r + beta * p\n        rsold = rsnew\n        if np.linalg.norm(r) < tol:\n            break\n    return x.tolist()\nA = np.array([[4, 2], [2, 5]])\nb = np.array([3, 7])\nx = conjugate_gradient(A, b, 100)"}
{"task_id": 64, "completion_id": 0, "solution": "import numpy as np\ndef gini_impurity(y: list[int]) -> float:\n    \"\"\"\n    Calculate Gini Impurity for a list of class labels.\n\n    :param y: List of class labels\n    :return: Gini Impurity rounded to three decimal places\n    \"\"\"\n    if not y:\n        return 0.0\n    class_counts = {}\n    for label in y:\n        if label in class_counts:\n            class_counts[label] += 1\n        else:\n            class_counts[label] = 1\n    total_samples = len(y)\n    gini = 1.0\n    for count in class_counts.values():\n        proportion = count / total_samples\n        gini -= proportion ** 2\n    return round(gini, 3)"}
{"task_id": 65, "completion_id": 0, "solution": "def compressed_row_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix to its Compressed Row Sparse (CSR) representation.\n\n    :param dense_matrix: 2D list representing a dense matrix\n    :return: A tuple containing (values array, column indices array, row pointer array)\n    \"\"\"\n    rows = len(dense_matrix)\n    cols = len(dense_matrix[0])\n    values = []\n    column_indices = []\n    row_pointers = [0]\n    for i in range(rows):\n        for j in range(cols):\n            if dense_matrix[i][j] != 0:\n                values.append(dense_matrix[i][j])\n                column_indices.append(j)\n        row_pointers.append(len(values))\n    return (values, column_indices, row_pointers)\ndense_matrix = [[0, 1, 0], [4, 0, 6], [0, 7, 0]]"}
{"task_id": 66, "completion_id": 0, "solution": "import numpy as np\ndef orthogonal_projection(v, L):\n    \"\"\"\n    Compute the orthogonal projection of vector v onto line L.\n\n    :param v: The vector to be projected\n    :param L: The line vector defining the direction of projection\n    :return: List representing the projection of v onto L\n    \"\"\"\n    v = np.array(v)\n    L = np.array(L)\n    dot_product = np.dot(v, L)\n    magnitude_squared_L = np.dot(L, L)\n    scalar_projection = dot_product / magnitude_squared_L\n    projection = scalar_projection * L\n    return [round(x, 3) for x in projection.tolist()]"}
{"task_id": 67, "completion_id": 0, "solution": "def compressed_col_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix into its Compressed Column Sparse (CSC) representation.\n\n    :param dense_matrix: List of lists representing the dense matrix\n    :return: Tuple of (values, row indices, column pointer)\n    \"\"\"\n    rows = len(dense_matrix)\n    cols = len(dense_matrix[0])\n    values = []\n    row_indices = []\n    column_pointer = [0] * cols\n    for i in range(rows):\n        for j in range(cols):\n            if dense_matrix[i][j] != 0:\n                values.append(dense_matrix[i][j])\n                row_indices.append(i)\n                column_pointer[j] += 1\n    for i in range(1, cols):\n        column_pointer[i] += column_pointer[i - 1]\n    return (values, row_indices, column_pointer)"}
{"task_id": 68, "completion_id": 0, "solution": "import numpy as np\ndef matrix_image(A):\n    \"\"\"\n    Calculate the column space of a given matrix A.\n\n    Parameters:\n    A (np.ndarray): The input matrix.\n\n    Returns:\n    list: A list of basis vectors that span the column space of A.\n    \"\"\"\n    R = np.linalg.matrix_rank(A)\n    row_echelon_form = np.array([A[i] for i in range(R)])\n    basis_vectors = row_echelon_form[:, :R]\n    basis_vectors_rounded = [np.round(vec, 8) for vec in basis_vectors.tolist()]\n    return basis_vectors_rounded\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])"}
{"task_id": 69, "completion_id": 0, "solution": "import numpy as np\ndef r_squared(y_true, y_pred):\n    \"\"\"\n    Calculate the R-squared value for a regression analysis.\n\n    Parameters:\n    - y_true (np.array): Array of true values.\n    - y_pred (np.array): Array of predicted values.\n\n    Returns:\n    - float: The R-squared value rounded to three decimal places.\n    \"\"\"\n    mean_y_true = np.mean(y_true)\n    tss = np.sum((y_true - mean_y_true) ** 2)\n    rss = np.sum((y_true - y_pred) ** 2)\n    r_squared_value = 1 - rss / tss\n    return round(r_squared_value, 3)"}
{"task_id": 70, "completion_id": 0, "solution": "import numpy as np\ndef calculate_brightness(img):\n    if not img or len(img) == 0:\n        return -1\n    total_brightness = 0\n    pixel_count = 0\n    for row in img:\n        if len(row) != len(img[0]):\n            return -1\n        for pixel in row:\n            if not 0 <= pixel <= 255:\n                return -1\n            total_brightness += pixel\n            pixel_count += 1\n    average_brightness = round(total_brightness / pixel_count, 2)\n    return average_brightness"}
{"task_id": 71, "completion_id": 0, "solution": "import numpy as np\ndef rmse(y_true, y_pred):\n    \"\"\"\n    Calculate the Root Mean Square Error (RMSE) between the actual values and the predicted values.\n    \n    Parameters:\n    y_true (np.array): Array containing the actual values.\n    y_pred (np.array): Array containing the predicted values.\n    \n    Returns:\n    float: The RMSE value rounded to three decimal places.\n    \n    Raises:\n    ValueError: If the input arrays have different shapes or are empty.\n    TypeError: If the input arrays are not of type np.ndarray.\n    \"\"\"\n    if not isinstance(y_true, np.ndarray) or not isinstance(y_pred, np.ndarray):\n        raise TypeError('Both y_true and y_pred must be of type np.ndarray.')\n    if y_true.shape != y_pred.shape:\n        raise ValueError('Input arrays y_true and y_pred must have the same shape.')\n    if len(y_true) == 0 or len(y_pred) == 0:\n        raise ValueError('Input arrays cannot be empty.')\n    squared_diffs = (y_true - y_pred) ** 2\n    mean_squared_diff = np.mean(squared_diffs)\n    rmse_value = np.sqrt(mean_squared_diff)\n    return round(rmse_value, 3)"}
{"task_id": 72, "completion_id": 0, "solution": "import numpy as np\ndef jaccard_index(y_true, y_pred):\n    \"\"\"\n    Calculate the Jaccard Index for binary classification.\n\n    Parameters:\n    - y_true: numpy.ndarray, binary array of true labels\n    - y_pred: numpy.ndarray, binary array of predicted labels\n\n    Returns:\n    - float, Jaccard Index rounded to three decimal places\n    \"\"\"\n    TP = np.sum(np.logical_and(y_true == 1, y_pred == 1))\n    FN = np.sum(np.logical_and(y_true == 1, y_pred == 0))\n    TN = np.sum(np.logical_and(y_true == 0, y_pred == 0))\n    FP = np.sum(np.logical_and(y_true == 0, y_pred == 1))\n    if TP + FN + TN + FP == 0:\n        return 1.0\n    else:\n        Jaccard = TP / (TP + FN + TN + FP)\n        return round(Jaccard, 3)"}
{"task_id": 73, "completion_id": 0, "solution": "import numpy as np\ndef dice_score(y_true, y_pred):\n    \"\"\"\n    Calculate the Dice Score for binary classification.\n    \n    Args:\n    y_true (np.array): Binary array representing true labels.\n    y_pred (np.array): Binary array representing predicted labels.\n    \n    Returns:\n    float: The Dice Score rounded to 3 decimal places.\n    \"\"\"\n    y_true = np.array(y_true)\n    y_pred = np.array(y_pred)\n    intersection = np.sum(np.logical_and(y_true, y_pred))\n    num_true = np.sum(y_true)\n    num_pred = np.sum(y_pred)\n    if num_true == 0 or num_pred == 0:\n        dice_score = 0.0\n    else:\n        dice_score = 2 * intersection / (num_true + num_pred)\n    return round(dice_score, 3)"}
{"task_id": 74, "completion_id": 0, "solution": "import numpy as np\ndef create_row_hv(row, dim, random_seeds):\n    \"\"\"\n    Generate a composite hypervector for a given dataset row using Hyperdimensional Computing (HDC).\n\n    Parameters:\n    - row: A dictionary representing a dataset row, where keys are feature names and values are their corresponding values.\n    - dim: The dimensionality of the hypervectors.\n    - random_seeds: A dictionary where keys are feature names and values are seeds to ensure reproducibility of hypervectors.\n\n    Returns:\n    - A composite hypervector representing the entire row as a list.\n    \"\"\"\n    composite_hv = []\n    for (feature_name, feature_value) in row.items():\n        feature_seed = random_seeds.get(feature_name)\n        feature_hv = np.random.randn(dim) * feature_seed\n        composite_hv.extend(feature_hv.tolist())\n    return composite_hv"}
{"task_id": 75, "completion_id": 0, "solution": "from collections import Counter\ndef confusion_matrix(data):\n    \"\"\"\n    Generates a confusion matrix for a binary classification problem.\n\n    Args:\n        data (list of lists): Each inner list contains two elements [y_true, y_pred],\n                             representing the true and predicted labels for one observation.\n\n    Returns:\n        list of lists: A 2x2 confusion matrix.\n    \"\"\"\n    tp = sum((1 for (y_true, y_pred) in data if y_true == 1 and y_pred == 1))\n    fp = sum((1 for (y_true, y_pred) in data if y_true == 0 and y_pred == 1))\n    fn = sum((1 for (y_true, y_pred) in data if y_true == 1 and y_pred == 0))\n    tn = sum((1 for (y_true, y_pred) in data if y_true == 0 and y_pred == 0))\n    confusion_mat = [[tn, fp], [fn, tp]]\n    return confusion_mat"}
{"task_id": 76, "completion_id": 0, "solution": "import numpy as np\ndef cosine_similarity(v1, v2):\n    \"\"\"\n    Calculate the cosine similarity between two vectors.\n\n    Args:\n    v1 (np.ndarray): The first vector.\n    v2 (np.ndarray): The second vector.\n\n    Returns:\n    float: The cosine similarity of the two vectors, rounded to three decimal places.\n    \"\"\"\n    if len(v1) != len(v2) or len(v1) == 0:\n        raise ValueError('Vectors must be non-empty and of the same length.')\n    dot_product = np.dot(v1, v2)\n    magnitude_v1 = np.linalg.norm(v1)\n    magnitude_v2 = np.linalg.norm(v2)\n    similarity = dot_product / (magnitude_v1 * magnitude_v2)\n    return round(similarity, 3)"}
{"task_id": 77, "completion_id": 0, "solution": "from collections import Counter\ndef performance_metrics(actual: list[int], predicted: list[int]) -> tuple:\n    \"\"\"\n    Calculate various performance metrics for a binary classification problem.\n\n    Args:\n    actual: List of actual class labels (1 for positive, 0 for negative).\n    predicted: List of predicted class labels from the model.\n\n    Returns:\n    A tuple containing:\n    - confusion_matrix: A 2x2 matrix.\n    - accuracy: A float representing the accuracy of the model.\n    - f1_score: A float representing the F1 score of the model.\n    - specificity: A float representing the specificity of the model.\n    - negative_predictive_value: A float representing the negative predictive value.\n    \"\"\"\n    actual_counter = Counter(actual)\n    predicted_counter = Counter(predicted)\n    confusion_matrix = [[actual_counter.get(1, 0) - predicted_counter.get(1, 0), actual_counter.get(0, 0) + predicted_counter.get(1, 0)], [actual_counter.get(0, 0) - predicted_counter.get(0, 0), actual_counter.get(1, 0) + predicted_counter.get(0, 0)]]\n    total_samples = sum(actual)\n    correct_predictions = sum((actual[i] == predicted[i] for i in range(total_samples)))\n    accuracy = round(correct_predictions / total_samples, 3)\n    precision = round(correct_predictions / sum(predicted if actual else 0), 3)\n    recall = round(correct_predictions / sum(actual), 3)\n    f1_score = round(2 * precision * recall / (precision + recall), 3)\n    true_negatives = sum((not actual[i] and (not predicted[i]) for i in range(total_samples)))\n    specificity = round(true_negatives / sum(not actual), 3)\n    false_positives = sum((actual[i] and (not predicted[i]) for i in range(total_samples)))\n    negative_predictive_value = round(false_positives / sum(not predicted), 3)\n    return (confusion_matrix, accuracy, f1_score, specificity, negative_predictive_value)"}
{"task_id": 78, "completion_id": 0, "solution": "import numpy as np\ndef descriptive_statistics(data):\n    \"\"\"\n    Calculate various descriptive statistics metrics for a given dataset.\n\n    Args:\n    - data: A list or NumPy array of numerical values.\n\n    Returns:\n    A dictionary containing the calculated descriptive statistics metrics.\n    \"\"\"\n    data = np.array(data)\n    mean = np.mean(data)\n    median = np.median(data)\n    try:\n        mode = np.bincount(data).argmax()\n    except ValueError:\n        mode = 'No unique mode'\n    variance = np.var(data)\n    std_dev = np.std(data)\n    percentiles = np.percentile(data, [25, 50, 75])\n    iqr = np.diff(percentiles)\n    return {'mean': round(mean, 4), 'median': round(median, 4), 'mode': mode, 'variance': round(variance, 4), 'standard_deviation': round(std_dev, 4), '25th_percentile': round(percentiles[0], 4), '50th_percentile': round(percentiles[1], 4), '75th_percentile': round(percentiles[2], 4), 'interquartile_range': round(iqr[0], 4)}\ndata = [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]"}
{"task_id": 79, "completion_id": 0, "solution": "import math\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Calculate the probability of achieving exactly k successes in n independent Bernoulli trials,\n    each with probability p of success, using the Binomial distribution formula.\n    :param n: Total number of trials\n    :param k: Number of successes\n    :param p: Probability of success on each trial\n    :return: Probability of k successes in n trials rounded to five decimal places\n    \"\"\"\n    if not (isinstance(n, int) and isinstance(k, int) and isinstance(p, float)):\n        raise ValueError('All inputs must be integers or floats.')\n    if not (0 <= n <= 100 and 0 <= k <= n and (0 <= p <= 1)):\n        raise ValueError('Invalid input values for n, k, and p.')\n    binom_coeff = math.comb(n, k)\n    probability = binom_coeff * p ** k * (1 - p) ** (n - k)\n    return round(probability, 5)"}
{"task_id": 80, "completion_id": 0, "solution": "import math\ndef normal_pdf(x, mean, std_dev):\n    \"\"\"\n    Calculate the probability density function (PDF) of the normal distribution.\n    \n    Args:\n    - x: The value at which the PDF is evaluated.\n    - mean: The mean (\u03bc) of the distribution.\n    - std_dev: The standard deviation (\u03c3) of the distribution.\n    \n    Returns:\n    - The PDF value of the normal distribution for the given x, rounded to 5 decimal places.\n    \"\"\"\n    exponent = -1 / (2 * std_dev ** 2) * (x - mean) ** 2\n    pdf_value = math.exp(exponent) / math.sqrt(2 * math.pi * std_dev ** 2)\n    return round(pdf_value, 5)"}
{"task_id": 81, "completion_id": 0, "solution": "import math\ndef poisson_probability(k, lam):\n    \"\"\"\n    Calculate the probability of observing exactly k events in a fixed interval,\n    given the mean rate of events lam, using the Poisson distribution formula.\n    :param k: Number of events (non-negative integer)\n    :param lam: The average rate (mean) of occurrences in a fixed interval\n    \"\"\"\n    if k < 0 or lam <= 0:\n        raise ValueError('k must be non-negative and lam must be positive.')\n    probability = lam ** k * math.exp(-lam) / math.factorial(k)\n    return round(probability, 5)"}
{"task_id": 82, "completion_id": 0, "solution": "import numpy as np\ndef calculate_contrast(img):\n    \"\"\"\n    Calculate the contrast of a grayscale image.\n    Args:\n        img (numpy.ndarray): 2D array representing a grayscale image with pixel values between 0 and 255.\n    Returns:\n        float: The contrast of the image.\n    \"\"\"\n    if not isinstance(img, np.ndarray) or img.dtype != np.uint8 or img.shape[2] != 1:\n        raise ValueError('Input must be a single-channel uint8 numpy array.')\n    max_val = np.max(img)\n    min_val = np.min(img)\n    if max_val == min_val:\n        return 0\n    contrast = (max_val - min_val) / max_val\n    return contrast"}
{"task_id": 83, "completion_id": 0, "solution": "import numpy as np\ndef calculate_dot_product(vec1, vec2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Args:\n        vec1 (numpy.ndarray): 1D array representing the first vector.\n        vec2 (numpy.ndarray): 1D array representing the second vector.\n    Returns:\n        float: The dot product of the two vectors.\n    \"\"\"\n    if len(vec1) != len(vec2):\n        raise ValueError('Vectors must be of the same length')\n    result = np.dot(vec1, vec2)\n    return result"}
{"task_id": 84, "completion_id": 0, "solution": "import numpy as np\ndef phi_transform(data: list[float], degree: int):\n    \"\"\"\n    Perform a Phi Transformation to map input features into a higher-dimensional space by generating polynomial features.\n\n    Args:\n        data (list[float]): A list of numerical values to transform.\n        degree (int): The degree of the polynomial expansion.\n    \"\"\"\n    if degree < 0:\n        return []\n    transformed_features = []\n    for point in data:\n        poly_features = [point ** i for i in range(degree + 1)]\n        poly_features = [round(feature, 8) for feature in poly_features]\n        transformed_features.append(poly_features)\n    return transformed_features"}
{"task_id": 85, "completion_id": 0, "solution": "import numpy as np\ndef pos_encoding(position: int, d_model: int):\n    \"\"\"\n    Calculate positional encodings for a sequence length (position) and model dimensionality (d_model).\n    \n    Parameters:\n    - position: int, the position in the sequence.\n    - d_model: int, the dimensionality of the model.\n    \n    Returns:\n    - List[np.float16], the calculated positional encodings.\n    \"\"\"\n    if position <= 0 or d_model <= 0:\n        return -1\n    pe = np.zeros((position, d_model), dtype=np.float16)\n    for i in range(0, position // 2):\n        val = 1 / 10000 ** (2 * i / d_model)\n        pe[i] = [val, 0]\n        pe[position - 1 - i] = [-val, 0]\n    for i in range(position // 2, position):\n        val = 1 / 10000 ** (2 * (i - position // 2) / d_model)\n        pe[i] = [np.sin(val), np.cos(val)]\n    return pe.tolist()"}
{"task_id": 86, "completion_id": 0, "solution": "def model_fit_quality(training_accuracy, test_accuracy):\n    \"\"\"\n    Determine if the model is overfitting, underfitting, or a good fit based on training and test accuracy.\n    :param training_accuracy: float, training accuracy of the model (0 <= training_accuracy <= 1)\n    :param test_accuracy: float, test accuracy of the model (0 <= test_accuracy <= 1)\n    :return: int, one of '1', '-1', or '0'.\n    \"\"\"\n    if training_accuracy - test_accuracy > 0.2:\n        return 1\n    elif training_accuracy < 0.7 and test_accuracy < 0.7:\n        return -1\n    else:\n        return 0"}
{"task_id": 87, "completion_id": 0, "solution": "import numpy as np\ndef adam_optimizer(parameter, grad, m, v, t, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08):\n    \"\"\"\n    Update parameters using the Adam optimizer.\n    Adjusts the learning rate based on the moving averages of the gradient and squared gradient.\n    :param parameter: Current parameter value\n    :param grad: Current gradient\n    :param m: First moment estimate\n    :param v: Second moment estimate\n    :param t: Current timestep\n    :param learning_rate: Learning rate (default=0.001)\n    :param beta1: First moment decay rate (default=0.9)\n    :param beta2: Second moment decay rate (default=0.999)\n    :param epsilon: Small constant for numerical stability (default=1e-8)\n    :return: tuple: (updated_parameter, updated_m, updated_v)\n    \"\"\"\n    m = beta1 * m + (1 - beta1) * grad\n    v = beta2 * v + (1 - beta2) * grad ** 2\n    m_corrected = m / (1 - beta1 ** t)\n    v_corrected = v / (1 - beta2 ** t)\n    updated_parameter = parameter - learning_rate * m_corrected\n    return [np.round(updated_parameter, 5).tolist(), np.round(m_corrected, 5).tolist(), np.round(v_corrected, 5).tolist()]\nlearning_rate = 0.01\nbeta1 = 0.9\nbeta2 = 0.999"}
{"task_id": 88, "completion_id": 0, "solution": "import numpy as np\ndef load_encoder_hparams_and_params(model_size: str='124M', models_dir: str='models'):\n\n    class DummyBPE:\n\n        def __init__(self):\n            self.encoder_dict = {'hello': 1, 'world': 2, '<UNK>': 0}\n\n        def encode(self, text: str):\n            tokens = text.strip().split()\n            return [self.encoder_dict.get(token, self.encoder_dict['<UNK>']) for token in tokens]\n\n        def decode(self, token_ids: list):\n            reversed_dict = {v: k for (k, v) in self.encoder_dict.items()}\n            return ' '.join([reversed_dict.get(tok_id, '<UNK>') for tok_id in token_ids])\n    hparams = {'n_ctx': 1024, 'n_head': 12}\n    params = {'wte': np.random.rand(3, 10), 'wpe': np.random.rand(1024, 10), 'blocks': [], 'ln_f': {'g': np.ones(10), 'b': np.zeros(10)}}\n    encoder = DummyBPE()\n    return (encoder, hparams, params)\ndef gen_text(prompt: str, n_tokens_to_generate: int=40):\n    (encoder, hparams, params) = load_encoder_hparams_and_params()\n    prompt_ids = encoder.encode(prompt)\n    hiddens = np.zeros((hparams['n_ctx'], params['wte'].shape[1]))\n    generated_tokens = []\n    for _ in range(n_tokens_to_generate):\n        pos_embeddings = np.expand_dims(np.arange(len(prompt_ids)), axis=1) * np.sqrt(hparams['n_ctx'])\n        combined_embeddings = np.dot(params['wte'][prompt_ids], params['wte'].T) + pos_embeddings + params['wpe']\n        attentions = np.dot(combined_embeddings, params['wte'].T)\n        attentions /= np.linalg.norm(attentions, axis=-1, keepdims=True)\n        attention_weights = np.dot(attns, params['ln_f']['g'] / (np.abs(params['ln_f']['g']) + 1e-08))\n        feed_forward_output = np.maximum(0, np.dot(combined_embeddings, params['wte'].T))\n        final_output = np.dot(feed_forward_output, params['ln_f']['g'] / (np.abs(params['ln_f']['g']) + 1e-08)) + params['ln_f']['b']\n        next_token_index = np.argmax(final_output)\n        next_token_id = prompt_ids[next_token_index]\n        generated_tokens.append(next_token_id)\n        hiddens = np.roll(hiddens, -1, axis=0)\n        hiddens[-1] = final_output\n    generated_text = encoder.decode(generated_tokens)\n    return generated_text"}
{"task_id": 89, "completion_id": 0, "solution": "import numpy as np\ndef pattern_weaver(n, crystal_values, dimension):\n\n    def softmax(values):\n        \"\"\"\n        Compute the softmax function for a given array of values.\n        \n        Args:\n        values (np.array): An array of numerical values.\n        \n        Returns:\n        np.array: An array of softmax probabilities corresponding to the input values.\n        \"\"\"\n        exp_values = np.exp(values)\n        sum_exp_values = np.sum(exp_values)\n        return exp_values / sum_exp_values\n    attention_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i + 1, n):\n            similarity = np.dot(crystal_values[i], crystal_values[j]) / (np.linalg.norm(crystal_values[i]) * np.linalg.norm(crystal_values[j]))\n            attention_matrix[i][j] = softmax(similarity)\n            attention_matrix[j][i] = attention_matrix[i][j]\n    weighted_patterns = []\n    for i in range(n):\n        pattern = np.zeros(dimension)\n        for j in range(n):\n            if attention_matrix[i][j] > 0:\n                pattern += attention_matrix[i][j] * crystal_values[j]\n        weighted_patterns.append(round(np.linalg.norm(pattern), 4))\n    return weighted_patterns\nn = 5\ncrystal_values = np.random.rand(5, 3)\ndimension = 3"}
{"task_id": 90, "completion_id": 0, "solution": "import numpy as np\nfrom collections import Counter\ndef calculate_bm25_scores(corpus, query, k1=1.5, b=0.75):\n    num_docs = len(corpus)\n    total_terms = sum((len(doc) for doc in corpus))\n    term_freqs = {}\n    for (doc_id, doc) in enumerate(corpus):\n        term_freqs[doc_id] = Counter(doc)\n    idf = {}\n    for term in set(query):\n        df = sum((1 for doc in corpus if term in doc))\n        idf[term] = np.log((num_docs - df + 0.5) / (df + 0.5))\n    bm25_scores = []\n    for (doc_id, doc) in enumerate(corpus):\n        score = 0\n        for term in query:\n            tf = term_freqs[doc_id][term]\n            doc_len = len(doc)\n            norm_doc_len = doc_len ** (1 - b) / (1 - b + b * doc_len)\n            score += tf * idf[term] * (k1 + 1) / (tf + k1 * (1 - b + b * doc_len))\n        bm25_scores.append(round(score, 3))\n    return bm25_scores"}
{"task_id": 91, "completion_id": 0, "solution": "from sklearn.metrics import f1_score\ndef calculate_f1_score(y_true, y_pred):\n    \"\"\"\n    Calculate the F1 score based on true and predicted labels.\n\n    Args:\n        y_true (list): True labels (ground truth).\n        y_pred (list): Predicted labels.\n\n    Returns:\n        float: The F1 score rounded to three decimal places.\n    \"\"\"\n    f1 = f1_score(y_true, y_pred, average='weighted')\n    return round(f1, 3)\ny_true = [0, 1, 2, 1, 0, 2, 1]\ny_pred = [0, 2, 2, 2, 0, 2, 1]"}
{"task_id": 92, "completion_id": 0, "solution": "import numpy as np\nfrom scipy.stats import linregress\ndef power_grid_forecast(consumption_data):\n    \"\"\"\n    Calculates the forecasted base power consumption of the Mars colony on day 15,\n    after removing the daily fluctuation and adding a 5% safety margin.\n\n    Parameters:\n    consumption_data (list): A list of integers representing daily power usage measurements.\n\n    Returns:\n    int: The forecasted base power consumption, rounded up to the nearest integer.\n    \"\"\"\n    detrended_data = [consumption - 10 * math.sin(2 * PI * i / 10) for (i, consumption) in enumerate(consumption_data)]\n    (slope, intercept, r_value, p_value, std_err) = linregress(range(len(detrended_data)), detrended_data)\n    predicted_consumption = slope * 14 + intercept\n    forecasted_base_consumption = predicted_consumption + 10 * math.sin(2 * PI * 14 / 10)\n    forecasted_base_consumption = math.ceil(forecasted_base_consumption * 1.05)\n    return forecasted_base_consumption\nconsumption_data = [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]"}
{"task_id": 93, "completion_id": 0, "solution": "import numpy as np\ndef mae(y_true, y_pred):\n    \"\"\"\n    Calculate Mean Absolute Error between two arrays.\n\n    Parameters:\n    y_true (numpy.ndarray): Array of true values\n    y_pred (numpy.ndarray): Array of predicted values\n\n    Returns:\n    float: Mean Absolute Error rounded to 3 decimal places\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError('Input arrays must have the same length.')\n    abs_diff = np.abs(y_true - y_pred)\n    mae_value = np.mean(abs_diff)\n    return round(mae_value, 3)\ny_true = np.array([10, 20, 30, 40, 50])\ny_pred = np.array([9, 21, 31, 39, 51])"}
{"task_id": 94, "completion_id": 0, "solution": "import numpy as np\ndef compute_qkv(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray) -> tuple:\n    \"\"\"\n    Compute query, key, and value matrices for multi-head attention.\n\n    Args:\n    X (np.ndarray): Input data of shape (batch_size, sequence_length, input_dim).\n    W_q (np.ndarray): Query weight matrix of shape (input_dim, head_dim * n_heads).\n    W_k (np.ndarray): Key weight matrix of shape (input_dim, head_dim * n_heads).\n    W_v (np.ndarray): Value weight matrix of shape (input_dim, head_dim * n_heads).\n\n    Returns:\n    tuple: A tuple containing computed query, key, and value matrices of shape (batch_size, sequence_length, head_dim * n_heads).\n    \"\"\"\n    (batch_size, sequence_length, input_dim) = X.shape\n    head_dim = input_dim // n_heads\n    q = np.dot(X, W_q)\n    k = np.dot(X, W_k)\n    v = np.dot(X, W_v)\n    return (q, k, v)\ndef self_attention(q: np.ndarray, k: np.ndarray, v: np.ndarray, mask: np.ndarray=None) -> np.ndarray:\n    \"\"\"\n    Perform self-attention on the input query, key, and value matrices.\n\n    Args:\n    q (np.ndarray): Query matrix of shape (batch_size, sequence_length, head_dim * n_heads).\n    k (np.ndarray): Key matrix of shape (batch_size, sequence_length, head_dim * n_heads).\n    v (np.ndarray): Value matrix of shape (batch_size, sequence_length, head_dim * n_heads).\n    mask (np.ndarray): Masking matrix of shape (batch_size, sequence_length, sequence_length) used to prevent future information from being accessed.\n\n    Returns:\n    np.ndarray: The output of the self-attention operation of shape (batch_size, sequence_length, head_dim * n_heads).\n    \"\"\"\n    scores = np.dot(q, k.T) / np.sqrt(head_dim)\n    if mask is not None:\n        scores = scores - 10000 * mask\n    attention_weights = np.softmax(scores, axis=-1)\n    output = np.dot(attention_weights, v)\n    return output\ndef multi_head_attention(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray, n_heads: int) -> list:\n    \"\"\"\n    Perform multi-head attention on the input data.\n\n    Args:\n    X (np.ndarray): Input data of shape (batch_size, sequence_length, input_dim).\n    W_q (np.ndarray): Query weight matrix of shape (input_dim, head_dim * n_heads).\n    W_k (np.ndarray): Key weight matrix of shape (input_dim, head_dim * n_heads).\n    W_v (np.ndarray): Value weight matrix of shape (input_dim, head_dim * n_heads).\n    n_heads (int): Number of heads for multi-head attention.\n\n    Returns:\n    list: A list containing the output of each head's self-attention operation of shape (batch_size, sequence_length, head_dim).\n    \"\"\"\n    (q, k, v) = compute_qkv(X, W_q, W_k, W_v, n_heads)\n    outputs = [self_attention(q[:, :, i], k[:, :, i], v[:, :, i]) for i in range(n_heads)]\n    outputs = [output.tolist() for output in outputs]\n    return outputs"}
{"task_id": 95, "completion_id": 0, "solution": "from math import sqrt\ndef phi_corr(x: list[int], y: list[int]) -> float:\n    \"\"\"\n    Calculate the Phi coefficient between two binary variables.\n\n    Args:\n    x (list[int]): A list of binary values (0 or 1).\n    y (list[int]): A list of binary values (0 or 1).\n\n    Returns:\n    float: The Phi coefficient rounded to 4 decimal places.\n    \"\"\"\n    n = len(x)\n    tp = sum((xi * yi for (xi, yi) in zip(x, y)))\n    fp = sum((xi * (1 - yi) for (xi, yi) in zip(x, y)))\n    tn = sum(((1 - xi) * (1 - yi) for (xi, yi) in zip(x, y)))\n    fn = sum(((1 - xi) * yi for (xi, yi) in zip(x, y)))\n    E_o = n * (n + 1) / 2\n    O_o = tp + fn + fp + tn\n    phi = (O_o - (tp * tn - fp * fn)) / sqrt(E_o * (E_o - tp) * (E_o - tn) * (E_o - fp))\n    return round(phi, 4)\nx = [1, 0, 1, 1, 0, 1]\ny = [0, 1, 0, 1, 0, 0]"}
{"task_id": 96, "completion_id": 0, "solution": "def hard_sigmoid(x: float) -> float:\n    \"\"\"\n    Implements the Hard Sigmoid activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Hard Sigmoid of the input\n    \"\"\"\n    if x < -2.5:\n        return 0\n    elif x > 2.5:\n        return 1\n    else:\n        return x / 4 + 0.5"}
{"task_id": 97, "completion_id": 0, "solution": "import math\ndef elu(x: float, alpha: float=1.0) -> float:\n    \"\"\"\n    Compute the ELU activation function.\n\n    Args:\n        x (float): Input value\n        alpha (float): ELU parameter for negative values (default: 1.0)\n\n    Returns:\n        float: ELU activation value rounded to the 4th decimal place\n    \"\"\"\n    if x < 0:\n        return alpha * (math.exp(x) - 1)\n    else:\n        return x"}
{"task_id": 98, "completion_id": 0, "solution": "import torch\ndef prelu(x: float, alpha: float=0.25) -> float:\n    \"\"\"\n    Implements the PReLU (Parametric ReLU) activation function.\n\n    Args:\n        x: Input value\n        alpha: Slope parameter for negative values (default: 0.25)\n\n    Returns:\n        float: PReLU activation value\n    \"\"\"\n    if x < 0:\n        return alpha * x\n    else:\n        return x"}
{"task_id": 99, "completion_id": 0, "solution": "import math\ndef softplus(x: float) -> float:\n    \"\"\"\n    Compute the softplus activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The softplus value: log(1 + e^x), rounded to the 4th decimal place\n    \"\"\"\n    if x < -709:\n        return -math.inf\n    elif x > 709:\n        return math.inf\n    else:\n        return round(math.log(1 + math.exp(x)), 4)"}
{"task_id": 100, "completion_id": 0, "solution": "from typing import *\nimport numpy as np\ndef softsign(x: float) -> float:\n    \"\"\"\n    Implements the Softsign activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Softsign of the input, rounded to 4 decimal places\n    \"\"\"\n    return round(np.sign(x) * np.log(1 + np.abs(x)), 4)"}
{"task_id": 101, "completion_id": 0, "solution": "import numpy as np\ndef grpo_objective(rhos, A, pi_theta_old, pi_theta_ref, epsilon=0.2, beta=0.01) -> float:\n    \"\"\"\n    Compute the GRPO objective function.\n\n    Args:\n        rhos: List of likelihood ratios (p_i) = pi_theta(o_i | q) / pi_theta_old(o_i | q).\n        A: List of advantage estimates (A_i).\n        pi_theta_old: List representing the old policy probabilities pi_theta_old(o_i | q).\n        pi_theta_ref: List representing the reference policy probabilities pi_ref(o_i | q).\n        epsilon: Clipping parameter (eps).\n        beta: KL divergence penalty coefficient (beta).\n\n    Returns:\n        The computed GRPO objective value.\n    \"\"\"\n    rho_clipped = [min(1.0, max(epsilon, r)) for r in rhos]\n    kl_divergence_gradient = np.sum(pi_theta_old * np.log(pi_theta_old / pi_theta_ref))\n    grpo_objective_value = -np.mean(rho_clipped * A + beta * kl_divergence_gradient)\n    return round(grpo_objective_value, 6)\nrhos = [0.85, 0.75, 0.9, 0.8]\nA = [0.2, 0.3, 0.4, 0.5]\npi_theta_old = [0.1, 0.2, 0.3, 0.4]\npi_theta_ref = [0.05, 0.1, 0.15, 0.2]"}
{"task_id": 102, "completion_id": 0, "solution": "import math\nimport numpy as np\ndef swish(x: float) -> float:\n    \"\"\"\n    Implements the Swish activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The Swish activation value rounded to the nearest 4th decimal\n    \"\"\"\n    return x * np.tanh(math.log(1 + x))"}
{"task_id": 103, "completion_id": 0, "solution": "import math\nimport numpy as np\ndef selu(x: float) -> float:\n    \"\"\"\n    Implements the SELU (Scaled Exponential Linear Unit) activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        SELU activation value rounded to the nearest 4th decimal\n    \"\"\"\n    alpha = 1.6732632423543772\n    scale = 1.0507009873554805\n    return round(scale * (math.exp(x) - alpha if x > 0 else scale * x), 4)"}
{"task_id": 104, "completion_id": 0, "solution": "import numpy as np\ndef predict_logistic(X: np.ndarray, weights: np.ndarray, bias: float) -> list:\n    \"\"\"\n    Implements binary classification prediction using Logistic Regression.\n\n    Args:\n        X: Input feature matrix (shape: N \u00c3\\x97 D)\n        weights: Model weights (shape: D)\n        bias: Model bias\n\n    Returns:\n        Binary predictions (0 or 1)\n    \"\"\"\n    scores = np.dot(X, weights) + bias\n    probabilities = 1 / (1 + np.exp(-scores))\n    binary_predictions = (probabilities >= 0.5).astype(int)\n    return binary_predictions.tolist()"}
{"task_id": 105, "completion_id": 0, "solution": "import numpy as np\ndef train_softmaxreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for Softmax regression, optimizing parameters with Cross Entropy loss.\n\n    Returns:\n        B : list[float], CxM updated parameter vector rounded to 4 floating points\n        losses : list[float], collected values of a Cross Entropy rounded to 4 floating points\n    \"\"\"\n    (m, n) = X.shape\n    C = len(np.unique(y))\n    B = np.zeros((C, n))\n    losses = []\n    for _ in range(iterations):\n        scores = np.dot(B, X.T)\n        exp_scores = np.exp(scores)\n        probabilities = exp_scores / np.sum(exp_scores, axis=1, keepdims=True)\n        cross_entropy_loss = -np.mean(y * np.log(probabilities))\n        losses.append(round(cross_entropy_loss, 4))\n        grad_B = (probabilities - y).T @ X\n        B -= learning_rate * grad_B\n    return (B.tolist(), losses)"}
{"task_id": 106, "completion_id": 0, "solution": "import numpy as np\ndef train_logreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for logistic regression, optimizing parameters with Binary Cross Entropy loss.\n    \n    Parameters:\n    X (np.ndarray): Feature matrix of shape (n_samples, n_features)\n    y (np.ndarray): Target vector of shape (n_samples,)\n    learning_rate (float): Learning rate for gradient descent\n    iterations (int): Number of iterations for training\n    \n    Returns:\n    tuple[list[float], ...]: A tuple containing two lists: \n        - Coefficients of the logistic regression model\n        - Loss values at each iteration\n    \"\"\"\n    (n_samples, n_features) = X.shape\n    weights = np.random.randn(n_features + 1)\n    losses = []\n    for _ in range(iterations):\n        X_with_bias = np.hstack((X, np.ones((n_samples, 1))))\n        predictions = sigmoid(np.dot(X_with_bias, weights))\n        loss = binary_cross_entropy(y, predictions)\n        losses.append(loss)\n        dw = 1 / n_samples * np.dot(X_with_bias.T, predictions - y)\n        weights -= learning_rate * dw\n    return (weights.tolist(), losses)\ndef sigmoid(z):\n    \"\"\"\n    Sigmoid function used in logistic regression.\n    \"\"\"\n    return 1 / (1 + np.exp(-z))\ndef binary_cross_entropy(y_true, y_pred):\n    \"\"\"\n    Binary cross-entropy loss function.\n    \"\"\"\n    return -np.mean(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred))\nX = np.array([[0, 1], [1, 0], [1, 1]])\ny = np.array([0, 1, 1])\nlearning_rate = 0.01\niterations = 1000"}
{"task_id": 107, "completion_id": 0, "solution": "import numpy as np\ndef masked_attention(Q: np.ndarray, K: np.ndarray, V: np.ndarray, mask: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute masked self-attention.\n    \"\"\"\n    Q_reshaped = Q.reshape(-1, Q.shape[-1])\n    K_reshaped = K.reshape(-1, K.shape[-1])\n    V_reshaped = V.reshape(-1, V.shape[-1])\n    masked_QK = Q_reshaped * mask\n    attn_weights = np.dot(masked_QK, K_reshaped.T)\n    attn_weights /= np.sqrt(K_reshaped.shape[1])\n    context_vector = np.dot(attn_weights, V_reshaped)\n    context_vector_reshaped = context_vector.reshape(Q.shape[:2], -1)\n    return context_vector_reshaped.tolist()"}
{"task_id": 108, "completion_id": 0, "solution": "from typing import List\ndef disorder(apples: List[int]) -> float:\n    \"\"\"\n    Calculates a measure of disorder in a basket of apples based on their colors.\n    \n    :param apples: A list of integers representing the colors of the apples.\n    :return: A float value representing the disorder of the apples.\n    \"\"\"\n    if not apples:\n        return 0.0\n    color_counts = {}\n    for color in apples:\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n    total_apples = len(apples)\n    disorder = (total_apples - max(color_counts.values())) / total_apples\n    return round(disorder, 4)"}
{"task_id": 109, "completion_id": 0, "solution": "import numpy as np\ndef layer_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float=1e-05) -> list:\n    \"\"\"\n    Perform Layer Normalization on an input tensor.\n\n    Args:\n    - X (np.ndarray): A 3D array of shape (batch_size, seq_length, num_features).\n    - gamma (np.ndarray): Scaling parameter of shape (num_features,).\n    - beta (np.ndarray): Shifting parameter of shape (num_features,).\n    - epsilon (float): Small value to prevent division by zero.\n\n    Returns:\n    - list: The normalized tensor rounded to 5 decimal places and converted to a list.\n    \"\"\"\n    mean = np.mean(X, axis=-1, keepdims=True)\n    variance = np.var(X, axis=-1, keepdims=True)\n    normalized_X = (X - mean) / np.sqrt(variance + epsilon)\n    normalized_X = normalized_X * gamma + beta\n    return normalized_X.tolist()"}
{"task_id": 110, "completion_id": 0, "solution": "import numpy as np\nfrom collections import Counter\ndef meteor_score(reference, candidate, alpha=0.9, beta=3, gamma=0.5):\n    \"\"\"\n    Calculate the METEOR (Modification of the Error Rate) score for evaluating machine translation quality.\n\n    Args:\n    - reference (str): The reference translation.\n    - candidate (str): The candidate translation.\n    - alpha (float): The alpha parameter for the penalty calculation.\n    - beta (float): The beta parameter for the penalty calculation.\n    - gamma (float): The gamma parameter for the penalty calculation.\n\n    Returns:\n    - float: The METEOR score rounded to 3 decimal places.\n    \"\"\"\n    ref_words = reference.split()\n    cand_words = candidate.split()\n    ref_counts = Counter(ref_words)\n    cand_counts = Counter(cand_words)\n    common_words = set(ref_words).intersection(set(cand_words))\n    num_unique_ref = len(ref_counts)\n    num_unique_cand = len(cand_counts)\n    num_common_unique = len(common_words)\n    total_words = num_unique_ref + num_unique_cand - num_common_unique\n    if total_words == 0:\n        precision = 0\n    else:\n        precision = num_common_unique / total_words\n    if num_unique_cand == 0:\n        recall = 0\n    else:\n        recall = num_common_unique / num_unique_cand\n    f_measure = 2 * (precision * recall) / (precision + recall)\n    penalty = alpha * (1 - num_unique_cand / num_unique_ref)\n    meteor_score = f_measure - penalty\n    return round(meteor_score, 3)"}
{"task_id": 111, "completion_id": 0, "solution": "import numpy as np\ndef compute_pmi(joint_counts, total_counts_x, total_counts_y, total_samples):\n    \"\"\"\n    Calculate the Pointwise Mutual Information (PMI) between two events.\n\n    Parameters:\n    - joint_counts (int): The count of occurrences of both events together.\n    - total_counts_x (int): The total count of event X.\n    - total_counts_y (int): The total count of event Y.\n    - total_samples (int): The total number of samples.\n\n    Returns:\n    - float: The PMI value rounded to 3 decimal places.\n    \"\"\"\n    p_xy = joint_counts / total_samples\n    p_x = total_counts_x / total_samples\n    p_y = total_counts_y / total_samples\n    if p_x * p_y == 0:\n        pmi = 0\n    else:\n        pmi = np.log2(p_xy / (p_x * p_y))\n    return round(pmi, 3)"}
{"task_id": 112, "completion_id": 0, "solution": "from typing import List\ndef min_max(x: List[int]) -> List[float]:\n    \"\"\"\n    Perform Min-Max Normalization on a list of integers.\n\n    Args:\n    x (List[int]): A list of integers to be normalized.\n\n    Returns:\n    List[float]: A list of normalized floating-point numbers, each scaled between 0 and 1.\n    \"\"\"\n    min_val = min(x)\n    max_val = max(x)\n    diff = max_val - min_val\n    normalized_values = [(val - min_val) / diff for val in x]\n    return [round(val, 4) for val in normalized_values]"}
{"task_id": 113, "completion_id": 0, "solution": "import numpy as np\ndef residual_block(x: np.ndarray, w1: np.ndarray, w2: np.ndarray):\n    \"\"\"\n    Create a simple residual block using NumPy.\n\n    Parameters:\n    x (np.ndarray): Input 1D array of shape (n,)\n    w1 (np.ndarray): Weight matrix for the first layer, shape (n, n)\n    w2 (np.ndarray): Weight matrix for the second layer, shape (n, n)\n\n    Returns:\n    list: List containing the processed input after the residual block, rounded to 4 decimal places.\n    \"\"\"\n    z = np.dot(x, w1) + np.dot(z, w2)\n    z = np.maximum(0, z)\n    z += x\n    z = np.maximum(0, z)\n    return round(list(z), 4)\nx = np.array([1.0, 2.0, 3.0])\nw1 = np.array([[1.5, -0.5], [-0.5, 1.5]])\nw2 = np.array([[0.5, 0.5], [0.5, 0.5]])"}
{"task_id": 114, "completion_id": 0, "solution": "import numpy as np\ndef global_avg_pool(x: np.ndarray):\n    \"\"\"\n    Perform Global Average Pooling on a 3D NumPy array.\n\n    Parameters:\n    x (np.ndarray): A 3D NumPy array of shape (height, width, channels), representing feature maps from a convolutional layer.\n\n    Returns:\n    np.ndarray: A 1D NumPy array of shape (channels,), where each element is the average of all values in the corresponding feature map.\n    \"\"\"\n    pooled = np.mean(x, axis=(0, 1))\n    return pooled"}
{"task_id": 115, "completion_id": 0, "solution": "import numpy as np\ndef batch_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float=1e-05):\n    \"\"\"\n    Performs Batch Normalization on a 4D NumPy array representing a batch of feature maps in the BCHW format.\n    \n    Parameters:\n    X (np.ndarray): Input tensor of shape (batch, channels, height, width).\n    gamma (np.ndarray): Scale parameter tensor of shape (channels,).\n    beta (np.ndarray): Shift parameter tensor of shape (channels,).\n    epsilon (float): Epsilon value for numerical stability.\n    \n    Returns:\n    np.ndarray: Normalized tensor of shape (batch, channels, height, width).\n    \"\"\"\n    mean = np.mean(X, axis=(0, 2, 3), keepdims=True)\n    var = np.var(X, axis=(0, 2, 3), keepdims=True)\n    std = np.sqrt(var + epsilon)\n    normalized_X = (X - mean) / std\n    output = normalized_X * gamma + beta\n    return output.tolist()"}
{"task_id": 116, "completion_id": 0, "solution": "def poly_term_derivative(c: float, x: float, n: float) -> float:\n    \"\"\"\n    Compute the derivative of a polynomial term of the form c * x^n at a given point x.\n\n    Parameters:\n    - c (float): Coefficient of the term.\n    - x (float): Point at which to evaluate the derivative.\n    - n (float): Exponent of the term.\n\n    Returns:\n    - float: The value of the derivative, rounded to 4 decimal places.\n    \"\"\"\n    derivative = c * n * x ** (n - 1)\n    return round(derivative, 4)"}
{"task_id": 117, "completion_id": 0, "solution": "import numpy as np\ndef orthonormal_basis(vectors: list[list[float]], tol: float=1e-10):\n    \"\"\"\n    Computes an orthonormal basis for the subspace spanned by a list of 2D vectors.\n\n    Args:\n        vectors: A list of 2D vectors represented as lists of floats.\n        tol: Tolerance value for determining linear independence.\n\n    Returns:\n        A list of orthonormal vectors (unit length and orthogonal to each other).\n    \"\"\"\n    basis = [vectors[0] / np.linalg.norm(vectors[0])]\n    for v in vectors[1:]:\n        projection = sum([np.dot(v, b) * b for b in basis])\n        orthogonal_vector = v - projection\n        normalized_vector = orthogonal_vector / np.linalg.norm(orthogonal_vector)\n        basis.append(normalized_vector)\n    orthonormal_vectors = [np.round(vec, 4).tolist() for vec in basis]\n    return orthonormal_vectors\nvectors = [[1, 0], [0, 1], [1, 1]]\nbasis = orthonormal_basis(vectors)"}
{"task_id": 118, "completion_id": 0, "solution": "import numpy as np\ndef cross_product(a, b):\n    \"\"\"\n    Computes the cross product of two 3D vectors.\n\n    Parameters:\n    a (list): A list of three numbers representing the first vector.\n    b (list): A list of three numbers representing the second vector.\n\n    Returns:\n    list: A list containing the components of the cross product vector, rounded to 4 decimal places.\n    \"\"\"\n    vec_a = np.array(a)\n    vec_b = np.array(b)\n    result_vector = np.cross(vec_a, vec_b)\n    rounded_result = result_vector.round(4).tolist()\n    return rounded_result"}
{"task_id": 119, "completion_id": 0, "solution": "import numpy as np\ndef cramers_rule(A, b):\n    if len(A) != len(b):\n        raise ValueError('The number of rows in A must match the length of b.')\n    n = len(A)\n    det_A = np.linalg.det(A)\n    if det_A == 0:\n        return -1\n    C = np.column_stack((A, b))\n    x = [np.linalg.det(C[:, i]) / det_A for i in range(n)]\n    return np.round(x, 4).tolist()\nA = np.array([[2, 3], [4, 5]])\nb = np.array([6, 7])"}
{"task_id": 120, "completion_id": 0, "solution": "import numpy as np\ndef bhattacharyya_distance(p: list[float], q: list[float]) -> float:\n    if len(p) != len(q):\n        return 0.0\n    p = np.array(p)\n    q = np.array(q)\n    Bhattacharyya_dist = -np.sum(np.log2(p * q))\n    return round(Bhattacharyya_dist, 4)"}
{"task_id": 121, "completion_id": 0, "solution": "from typing import List, Union\ndef vector_sum(a: List[Union[int, float]], b: List[Union[int, float]]) -> List[Union[int, float]]:\n    if len(a) != len(b):\n        return -1\n    result = [a[i] + b[i] for i in range(len(a))]\n    return result"}
{"task_id": 122, "completion_id": 0, "solution": "import numpy as np\ndef compute_policy_gradient(theta: np.ndarray, episodes: list[list[tuple[int, int, float]]]):\n    \"\"\"\n    Compute the policy gradient using the REINFORCE algorithm.\n\n    Args:\n        theta: A 2D NumPy array of shape (num_states, num_actions) representing the policy parameters.\n        episodes: A list of episodes, where each episode is a list of (state, action, reward) tuples.\n\n    Returns:\n        A list containing the average gradient of the log-policy multiplied by the return at each time step.\n    \"\"\"\n    num_states = theta.shape[0]\n    num_actions = theta.shape[1]\n    gradients = np.zeros(num_states * num_actions)\n    for episode in episodes:\n        total_return = 0\n        prev_state = None\n        for (state, action, reward) in episode:\n            if prev_state is not None:\n                log_prob = np.log(np.sum(np.exp(theta[state, :])))\n                total_return += reward + gamma * np.max(np.exp(theta[next_state, :]))\n            gradients += log_prob * total_return\n            prev_state = state\n    gradients /= len(episodes)\n    return gradients.tolist()"}
{"task_id": 123, "completion_id": 0, "solution": "import math\ndef compute_efficiency(n_experts, k_active, d_in, d_out):\n    fops_dense = n_experts * k_active * d_in * d_out\n    fops_moe = n_experts * k_active * d_in + n_experts * d_out * d_out\n    flops_savings_percentage = (flops_dense - flops_moe) / flops_dense * 100\n    return round(flops_savings_percentage, 1)"}
{"task_id": 124, "completion_id": 0, "solution": "import numpy as np\ndef noisy_topk_gating(X: np.ndarray, W_g: np.ndarray, W_noise: np.ndarray, N: np.ndarray, k: int):\n    \"\"\"\n    Compute the final gating probabilities matrix for Noisy Top-K gating.\n\n    Args:\n    - X: Input data of shape (n_samples, n_features).\n    - W_g: Weight matrix for gating, of shape (n_experts, n_features).\n    - W_noise: Noise matrix for gating, of shape (n_experts, n_features).\n    - N: Pre-sampled noise matrix, of shape (n_samples, n_experts).\n    - k: Number of experts to consider.\n\n    Returns:\n    - A numpy array representing the final gating probabilities, of shape (n_samples, n_experts), rounded to 4th decimal.\n    \"\"\"\n    gating_scores = np.dot(X, W_g)\n    noisy_scores = gating_scores + W_noise * N\n    sorted_indices = np.argsort(noisy_scores, axis=1)[::-1]\n    top_k_scores = noisy_scores[np.arange(X.shape[0]), sorted_indices[:, :k]]\n    normalized_scores = top_k_scores / np.sum(top_k_scores, axis=1, keepdims=True)\n    final_gate_probs = normalized_scores.reshape(X.shape)\n    return final_gate_probs.tolist()"}
{"task_id": 125, "completion_id": 0, "solution": "import numpy as np\ndef moe(x: np.ndarray, We: np.ndarray, Wg: np.ndarray, n_experts: int, top_k: int):\n    \"\"\"\n    Compute the final MoE output by selecting the top-k experts per token,\n    applying their transformations, and aggregating the results weighted by the normalized gating probabilities.\n\n    :param x: Input tensor shape (batch_size, sequence_length)\n    :param We: Expert weight matrices shape (n_experts, embedding_dim)\n    :param Wg: Gating weight matrix shape (1, embedding_dim)\n    :param n_experts: Number of experts\n    :param top_k: Top-k value for selecting experts\n    :return: Final MoE output shape (batch_size, sequence_length)\n    \"\"\"\n    g = np.dot(Wg, x)\n    g = np.exp(g) / np.sum(np.exp(g), axis=1, keepdims=True)\n    selected_experts = np.argsort(-g, axis=1)[:, :top_k]\n    transformed_experts = np.array([We[i] @ x[:, j] for i in range(n_experts) for j in selected_experts[:, i]])\n    aggregated_output = np.sum(transformed_experts * g[:, :, np.newaxis], axis=0)\n    return aggregated_output.tolist()"}
{"task_id": 126, "completion_id": 0, "solution": "import numpy as np\ndef group_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, num_groups: int, epsilon: float=1e-05):\n    (batch_size, channels, height, width) = X.shape\n    X_reshaped = X.reshape(batch_size * height * width, channels // num_groups)\n    mean = np.mean(X_reshaped, axis=0)\n    var = np.var(X_reshaped, axis=0)\n    var += epsilon\n    std = np.sqrt(var)\n    normalized_data = (X_reshaped - mean) / std\n    normalized_data_reshaped = normalized_data.reshape(batch_size, height, width, channels)\n    output = normalized_data_reshaped * gamma + beta\n    return output.tolist()\nX = np.random.rand(32, 64, 16, 16)\ngamma = np.random.rand(64)\nbeta = np.random.rand(64)\nnum_groups = 8\noutput = group_normalization(X, gamma, beta, num_groups)"}
{"task_id": 127, "completion_id": 0, "solution": "import numpy as np\ndef find_treasure(start_x: float, learning_rate: float=0.1, tolerance: float=1e-06, max_iters: int=10000) -> float:\n    current_x = start_x\n    for _ in range(max_iters):\n        derivative = 4 * current_x ** 3 - 9 * current_x ** 2\n        current_x -= learning_rate * derivative\n        if abs(derivative) < tolerance:\n            break\n    return round(current_x, 4)\nstart_x = 1.0"}
{"task_id": 128, "completion_id": 0, "solution": "import numpy as np\ndef dynamic_tanh(x: np.ndarray, alpha: float, gamma: float, beta: float) -> list[float]:\n    \"\"\"\n    Applies the Dynamic Tanh activation function to the input array x.\n\n    Args:\n        x (np.ndarray): The input array of shape (n_samples, n_features).\n        alpha (float): Scaling factor for the Tanh function.\n        gamma (float): Shift factor for the Tanh function.\n        beta (float): Offset factor for the Tanh function.\n\n    Returns:\n        list[float]: A list containing the transformed values of x.\n    \"\"\"\n    dyt_values = alpha * np.tanh(gamma * x + beta)\n    dyt_rounded = [round(value, 4) for value in dyt_values]\n    return dyt_rounded"}
