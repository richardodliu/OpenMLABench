{"task_id": 16, "completion_id": 0, "passed": true, "result": "passed", "solution": "\nfrom typing import Any, Iterable, List, Tuple\ndef ngrams(sequence: Iterable[Any], N: int) -> List[Tuple[Any, ...]]:\n    if N == 0:\n        return []\n    L = len(sequence)\n    if N > L:\n        return []\n    ngrams = []\n    for i in range(L - N + 1):\n        window = sequence[i:i + N]\n        ngrams.append(tuple(window))\n    return ngrams\nassert ngrams([1, 2, 3, 4, 5], 2) == [(1, 2), (2, 3), (3, 4), (4, 5)], \"Test 1 failed: ngrams([1, 2, 3, 4, 5], 2)\"\nassert ngrams([1], 1) == [(1,)], \"Test 2 failed: ngrams([1], 1)\"\nassert ngrams([1], 2) == [], \"Test 3 failed: ngrams([1], 2)\"\nassert ngrams(\"hello\", 2) == [('h', 'e'), ('e', 'l'), ('l', 'l'), ('l', 'o')], \"Test 4 failed: ngrams('hello', 2)\"\nassert ngrams((1, 2, 3, 4), 3) == [(1, 2, 3), (2, 3, 4)], \"Test 5 failed: ngrams((1,2,3,4), 3)\"\nassert ngrams(range(6), 4) == [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5)], \"Test 6 failed: ngrams(range(6), 4)\"\nassert ngrams(['I', 'love', 'AI'], 2) == [('I', 'love'), ('love', 'AI')], \"Test 7 failed: ngrams(['I','love','AI'],2)\"\nassert ngrams([True, False, True, False], 3) == [(True, False, True), (False, True, False)], \"Test 8 failed: ngrams([True,False,True,False],3)\"\nassert ngrams([1, 1, 1, 1], 2) == [(1, 1), (1, 1), (1, 1)], \"Test 9 failed: ngrams([1,1,1,1],2)\"\nassert ngrams([7, 8, 9], 3) == [(7, 8, 9)], \"Test 10 failed: ngrams([7,8,9],3)\""}
{"task_id": 18, "completion_id": 0, "passed": false, "result": "failed: name 'zero' is not defined", "solution": "import numpy as np\n\nassert zero(5).shape == (5,), \"test case failed: zero(5) shape incorrect\"\nassert np.array_equal(zero(5), np.zeros(5)), \"test case failed: zero(5) values incorrect\"\nassert zero((2, 3)).shape == (2, 3), \"test case failed: zero((2, 3)) shape incorrect\"\nassert np.array_equal(zero((2, 3)), np.zeros((2, 3))), \"test case failed: zero((2, 3)) values incorrect\"\nassert zero((2, 3), dtype=int).dtype == np.int_, \"test case failed: dtype=int not respected\"\nassert zero((1, 1, 1)).shape == (1, 1, 1), \"test case failed: triple-dim shape\"\nassert zero((4,)).ndim == 1, \"test case failed: ndim for 1-tuple shape\"\nassert zero(()).shape == (), \"test case failed: zero-dimensional array shape\"\nassert zero(0).size == 0, \"test case failed: zero length vector size\"\nassert zero((2, 0, 3)).size == 0, \"test case failed: array with a zero axis size\""}
{"task_id": 71, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef label_uniq_cnt(data: list[list]) -> dict:\n    if not data:\n        return {}\n    counts = {}\n    for sample in data:\n        label = sample[-1]\n        if label in counts:\n            counts[label] += 1\n        else:\n            counts[label] = 1\n    return counts\nassert label_uniq_cnt([[1, 2, 'A'], [3, 5, 'B'], [7, 1, 'A']]) == {'A': 2, 'B': 1}, \"test case failed: multiple labels\"\nassert label_uniq_cnt([[0, 'cat'], [4, 'dog'], [9, 'dog'], [3, 'cat'], [1, 'cat']]) == {'cat': 3, 'dog': 2}, \"test case failed: string labels\"\nassert label_uniq_cnt([[0.2, 5.1, 1], [1.3, 3.3, 1], [9.0, 2.2, 2]]) == {1: 2, 2: 1}, \"test case failed: numeric labels\"\nassert label_uniq_cnt([[42, 'single']]) == {'single': 1}, \"test case failed: single sample\"\nassert label_uniq_cnt([[5, 7, 'same'], [1, 2, 'same'], [3, 4, 'same']]) == {'same': 3}, \"test case failed: all same label\"\nassert label_uniq_cnt([]) == {}, \"test case failed: empty data set\"\nassert label_uniq_cnt([[1,2,3,'x'],[2,3,4,'y'],[3,4,5,'x'],[4,5,6,'z']]) == {'x':2,'y':1,'z':1}, \"test case failed: longer samples\"\nassert label_uniq_cnt([[True, False, True, 'yes'], [False, True, False, 'no'], [True, True, True, 'yes']]) == {'yes':2,'no':1}, \"test case failed: boolean features\"\nassert label_uniq_cnt([[('tuple',1), 'T'], [('tuple',2), 'T'], [('tuple',3), 'S']]) == {'T':2,'S':1}, \"test case failed: tuple feature\"\nassert label_uniq_cnt([[1,'A'],[2,'B'],[3,'C'],[4,'D']]) == {'A':1,'B':1,'C':1,'D':1}, \"test case failed: all unique labels\""}
{"task_id": 87, "completion_id": 0, "passed": true, "result": "passed", "solution": "import numpy as np\nimport numpy as np\ndef layer_sizes(X: np.ndarray, Y: np.ndarray) -> tuple[int, int, int]:\n    n_x = X.shape[0]\n    n_y = Y.shape[0]\n    n_h = 10\n    return (n_x, n_h, n_y)\nassert layer_sizes(np.zeros((3, 5)), np.zeros((1, 5))) == (3, 10, 1), \"failed on (3x5,1x5)\"\nassert layer_sizes(np.zeros((1, 10)), np.zeros((1, 10))) == (1, 10, 1), \"failed on (1x10,1x10)\"\nassert layer_sizes(np.zeros((8, 2)), np.zeros((4, 2))) == (8, 10, 4), \"failed on (8x2,4x2)\"\nassert layer_sizes(np.zeros((6, 9)), np.zeros((3, 9))) == (6, 10, 3), \"failed on (6x9,3x9)\"\nassert layer_sizes(np.zeros((10, 1)), np.zeros((5, 1))) == (10, 10, 5), \"failed on (10x1,5x1)\"\nassert layer_sizes(np.zeros((2, 7)), np.zeros((2, 7))) == (2, 10, 2), \"failed on (2x7,2x7)\"\nassert layer_sizes(np.zeros((4, 4)), np.zeros((6, 4))) == (4, 10, 6), \"failed on (4x4,6x4)\"\nassert layer_sizes(np.zeros((9, 3)), np.zeros((3, 3))) == (9, 10, 3), \"failed on (9x3,3x3)\"\nassert layer_sizes(np.zeros((12, 6)), np.zeros((2, 6))) == (12, 10, 2), \"failed on (12x6,2x6)\"\nassert layer_sizes(np.zeros((5, 20)), np.zeros((8, 20))) == (5, 10, 8), \"failed on (5x20,8x20)\""}
{"task_id": 91, "completion_id": 0, "passed": false, "result": "failed: name 'relu_backward' is not defined", "solution": "import numpy as np\n\nassert relu_backward([[-1, 2], [3, -4]], [[1, -2], [0, 5]]) == [[-1, 0], [0, -4]], \"failed on mixed signs\"\nassert relu_backward([[1, 2], [3, 4]], [[5, 6], [7, 8]]) == [[1, 2], [3, 4]], \"failed on all positive Z\"\nassert relu_backward([[1, 2], [3, 4]], [[-5, -6], [-7, -8]]) == [[0, 0], [0, 0]], \"failed on all negative Z\"\nassert relu_backward([[0.5, -1.2, 3.0], [4.1, -2.2, 0.0], [7.7, 8.8, -9.9]], [[1, -1, 0], [2, 0, -2], [-3, 3, 4]]) == [[0.5, 0.0, 0.0], [4.1, 0.0, 0.0], [0.0, 8.8, -9.9]], \"failed on 3x3 mixed\"\nassert relu_backward([[1, 2, 3, 4]], [[-1, 0, 2, -3]]) == [[0, 0, 3, 0]], \"failed on 1x4 vector\"\nassert relu_backward([[1.5, -2.5], [3.5, -4.5]], [[0.0, 2.0], [0.0, -2.0]]) == [[0.0, -2.5], [0.0, 0.0]], \"failed on zeros in Z\"\nassert relu_backward([[1, 2], [3, 4]], [[1, 2], [3, 4]]) == [[1, 2], [3, 4]], \"failed when gradients passthrough\"\nassert relu_backward([[10, -10], [5, -5]], [[-1, 1], [-1, 1]]) == [[0, -10], [0, -5]], \"failed on alternating Z\"\nassert relu_backward([[3]], [[-7]]) == [[0]], \"failed on single negative element\"\nassert relu_backward([[3]], [[7]]) == [[3]], \"failed on single positive element\""}
{"task_id": 92, "completion_id": 0, "passed": true, "result": "passed", "solution": "import numbers\nimport numbers\ndef is_number(a) -> bool:\n    return isinstance(a, numbers.Number) and (not isinstance(a, bool))\nassert is_number(10) is True, \"test case failed: is_number(10)\"\nassert is_number(3.14) is True, \"test case failed: is_number(3.14)\"\nassert is_number(1+2j) is True, \"test case failed: is_number(1+2j)\"\nassert is_number(\"5\") is False, \"test case failed: is_number('5')\"\nassert is_number([1,2]) is False, \"test case failed: is_number([1,2])\"\nassert is_number(True) is False, \"test case failed: is_number(True)\"\nassert is_number(None) is False, \"test case failed: is_number(None)\"\nassert is_number(-7) is True, \"test case failed: is_number(-7)\"\nassert is_number(float('nan')) is True, \"test case failed: is_number(float('nan'))\"\nassert is_number({'num': 5}) is False, \"test case failed: is_number({'num': 5})\""}
{"task_id": 94, "completion_id": 0, "passed": true, "result": "passed", "solution": "from collections import Counter\nfrom collections import Counter\ndef knn_majority_vote(neighbors_targets: list[str | int]) -> str | int:\n    counts = Counter(neighbors_targets)\n    sorted_items = sorted(counts.items(), key=lambda x: (-x[1], x[0]))\n    return sorted_items[0][0]\nassert knn_majority_vote(['cat', 'dog', 'cat', 'bird']) == 'cat', \"failed on ['cat', 'dog', 'cat', 'bird']\"\nassert knn_majority_vote([1, 2, 2, 3, 1, 2]) == 2, \"failed on [1, 2, 2, 3, 1, 2]\"\nassert knn_majority_vote(['apple', 'banana', 'apple', 'banana']) == 'apple', \"failed on ['apple', 'banana', 'apple', 'banana']\"\nassert knn_majority_vote([42]) == 42, \"failed on [42]\"\nassert knn_majority_vote(['a', 'b', 'c']) == 'a', \"failed on ['a', 'b', 'c']\"\nassert knn_majority_vote([3, 3, 2, 2]) == 2, \"failed on [3, 3, 2, 2]\"\nassert knn_majority_vote([5, 4, 5, 4, 4, 5]) == 4, \"failed on [5, 4, 5, 4, 4, 5]\"\nassert knn_majority_vote(['x', 'y', 'y', 'x', 'z', 'z']) == 'x', \"failed on ['x', 'y', 'y', 'x', 'z', 'z']\"\nassert knn_majority_vote(list('aabbccd')) == 'a', \"failed on list('aabbccd')\"\nassert knn_majority_vote([0, 0, 1]) == 0, \"failed on [0, 0, 1]\""}
{"task_id": 113, "completion_id": 0, "passed": false, "result": "failed: name 'run_example' is not defined", "solution": "\ndef run_examples(model, input_vocabulary, inv_output_vocabulary, examples=None):\n    if examples is None:\n        examples = globalConstant\n    predictions = []\n    for example in examples:\n        output = run_example(model, input_vocabulary, inv_output_vocabulary, example)\n        predictions.append(''.join(output))\n        print(f'Input: {example}, Output: {output}')\n    return predictions\nassert run_examples(lambda s: s[::-1], None, None, [\"abc\"]) == [\"cba\"], \"test case failed: single example reversal\"\nassert run_examples(lambda s: s.upper(), None, None, [\"hello\", \"world\"]) == [\"HELLO\", \"WORLD\"], \"test case failed: uppercase mapping\"\nassert run_examples(lambda s: s, None, None, []) == [], \"test case failed: empty example list\"\nassert run_examples(lambda s: s[::-1], None, None, [\"\", \"a\"]) == [\"\", \"a\"], \"test case failed: empty and single char strings\"\nassert run_examples(lambda s: s*2, None, None, [\"cat\"]) == [\"catcat\"], \"test case failed: duplication model\"\nassert run_examples(lambda s: ''.join(sorted(s)), None, None, [\"cba\", \"fed\"] ) == [\"abc\", \"def\"], \"test case failed: sort characters\"\nassert run_examples(lambda s: ''.join(chr(ord(c)+1) for c in s), None, None, [\"abc\"]) == [\"bcd\"], \"test case failed: shift characters\"\nassert run_examples(lambda s: s[::-1].upper(), None, None, [\"Python\", \"AI\"]) == [\"NOHTYP\", \"IA\"], \"test case failed: reverse and uppercase\"\nassert run_examples(lambda s: ''.join('*' for _ in s), None, None, [\"mask\"]) == [\"****\"], \"test case failed: masking model\"\nassert run_examples(lambda s: s.strip(), None, None, [\"  spaced  \"]) == [\"spaced\"], \"test case failed: strip whitespaces\""}
{"task_id": 119, "completion_id": 0, "passed": false, "result": "failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()", "solution": "import numpy as np\nimport numpy as np\ndef sgd_update(params: list, grads: list, alpha: float=0.01) -> list:\n    if len(params) == 0 or len(grads) == 0 or len(params) != len(grads):\n        return []\n    new_params = [np.round(p - alpha * g, 4) for (p, g) in zip(params, grads)]\n    return [list(p) for p in new_params]\nassert sgd_update([np.array([1.0, 2.0, 3.0])], [np.array([0.1, -0.2, 0.3])], 0.1) == [[0.99, 2.02, 2.97]], \"failed on basic vector update\"\nassert sgd_update([np.array([[1.5, -2.0], [3.0, 4.0]])], [np.array([[0.5, 0.5], [1.0, -1.0]])], 0.2) == [[ [1.4, -2.1], [2.8, 4.2] ]], \"failed on matrix update\"\nassert sgd_update([], [], 0.1) == [], \"failed on empty input\"\nassert sgd_update([np.array(5.0)], [np.array(2.0)], 0.5) == [4.0], \"failed on scalar update\"\nassert sgd_update([np.array([0.0, 0.0])], [np.array([0.0, 0.0])], 10.0) == [[0.0, 0.0]], \"failed on zero gradients\"\nassert sgd_update([np.array([1.0, 1.0])], [np.array([1.0, 1.0])], 1.0) == [[0.0, 0.0]], \"failed on alpha=1\"\nassert sgd_update([np.array([-1.0, -2.0])], [np.array([-0.5, 0.5])], 0.4) == [[-0.8, -2.2]], \"failed on negative params/gradients\"\nassert sgd_update([np.array([[2.0, 3.0, 4.0]])], [np.array([[1.0, 1.0, 1.0]])], 0.25) == [[[1.75, 2.75, 3.75]]], \"failed on 1xN matrix\""}
{"task_id": 129, "completion_id": 0, "passed": true, "result": "passed", "solution": "from itertools import islice, cycle\nfrom itertools import cycle\ndef cycle_sequence(sequence: list, samples: int) -> list:\n    \"\"\"Return the first `samples` items from an infinite cycle over `sequence`.\n\n    Args:\n        sequence (list | tuple): Finite input sequence.\n        samples (int): Number of items to return from the infinite cycle.\n\n    Returns:\n        list: A list containing `samples` items collected by looping over\n              `sequence` repeatedly. If `sequence` is empty or `samples`\n              is not positive, an empty list is returned.\n    \"\"\"\n    if not sequence or samples <= 0:\n        return []\n    iterator = cycle(sequence)\n    return list(islice(iterator, samples))\nassert cycle_sequence([1,2,3], 8) == [1,2,3,1,2,3,1,2], \"failed on cycle_sequence([1,2,3], 8)\"\nassert cycle_sequence(['x'], 4) == ['x','x','x','x'], \"failed on single-element sequence\"\nassert cycle_sequence([], 5) == [], \"failed on empty sequence\"\nassert cycle_sequence([0,1], 0) == [], \"failed on zero samples\"\nassert cycle_sequence([0,1], -3) == [], \"failed on negative samples\"\nassert cycle_sequence(['a','b','c'], 1) == ['a'], \"failed on one sample\"\nassert cycle_sequence(['a','b','c'], 2) == ['a','b'], \"failed on two samples\"\nassert cycle_sequence(['a','b','c'], 3) == ['a','b','c'], \"failed on exactly full length\"\nassert cycle_sequence(['a','b','c'], 4) == ['a','b','c','a'], \"failed on length+1 samples\"\nassert cycle_sequence([True, False], 7) == [True, False, True, False, True, False, True], \"failed on boolean sequence\""}
{"task_id": 134, "completion_id": 0, "passed": false, "result": "failed: name 'best_arm' is not defined", "solution": "import numpy as np\n\nassert best_arm([0.15, 0.6, 0.35]) == (0.6, 1), \"failed on [0.15, 0.6, 0.35]\"\nassert best_arm([0.8, 0.8, 0.5]) == (0.8, 0), \"failed on tie with first max\"\nassert best_arm([0.0, 0.0, 0.0]) == (0.0, 0), \"failed on all zeros\"\nassert best_arm([1.0]) == (1.0, 0), \"failed on single arm\"\nassert best_arm([]) == (-1.0, -1), \"failed on empty list\"\nassert best_arm([0.2, -0.1, 0.3]) == (-1.0, -1), \"failed on probability < 0\"\nassert best_arm([0.2, 1.1, 0.3]) == (-1.0, -1), \"failed on probability > 1\"\nassert best_arm([0.333, 0.333, 0.3329]) == (0.333, 0), \"failed on close tie\"\nassert best_arm([0.25, 0.5, 0.75, 0.74]) == (0.75, 2), \"failed on normal case\"\nassert best_arm([0.9, 0.1]) == (0.9, 0), \"failed on two arms\""}
{"task_id": 173, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef alphabetical_distance(candidate: str, target: str) -> int:\n    if len(candidate) != len(target):\n        return -1\n    total = 0\n    for (c1, c2) in zip(candidate, target):\n        total += abs(ord(c1) - ord(c2))\n    return total\nassert alphabetical_distance(\"HELLO\", \"WORLD\") == 42, \"Test 1 failed: alphabetical_distance('HELLO', 'WORLD')\"\nassert alphabetical_distance(\"ABC\", \"ABC\") == 0, \"Test 2 failed: alphabetical_distance('ABC', 'ABC')\"\nassert alphabetical_distance(\"aaaa\", \"bbbb\") == 4, \"Test 3 failed: alphabetical_distance('aaaa', 'bbbb')\"\nassert alphabetical_distance(\"abcd\", \"dcba\") == 8, \"Test 4 failed: alphabetical_distance('abcd', 'dcba')\"\nassert alphabetical_distance(\"HI\", \"HI\") == 0, \"Test 5 failed: alphabetical_distance('HI', 'HI')\"\nassert alphabetical_distance(\"AZ\", \"ZA\") == 50, \"Test 6 failed: alphabetical_distance('AZ', 'ZA')\"\nassert alphabetical_distance(\"\", \"\") == 0, \"Test 7 failed: alphabetical_distance('', '')\"\nassert alphabetical_distance(\"Genetic\", \"Algorithm\") == -1, \"Test 8 failed: alphabetical_distance('Genetic', 'Algorithm')\"\nassert alphabetical_distance(\"2023\", \"2024\") == 1, \"Test 9 failed: alphabetical_distance('2023', '2024')\"\nassert alphabetical_distance(\"Python3\", \"Python3\") == 0, \"Test 10 failed: alphabetical_distance('Python3', 'Python3')\""}
{"task_id": 199, "completion_id": 0, "passed": true, "result": "passed", "solution": "import numpy as np\nimport numpy as np\ndef split(X: np.ndarray, y: np.ndarray, value: float) -> tuple[list[int | float], list[int | float]]:\n    y_left = []\n    y_right = []\n    for i in range(len(y)):\n        if X[i] < value:\n            y_left.append(y[i])\n        else:\n            y_right.append(y[i])\n    return (y_left, y_right)\nassert split(np.array([2,3,1,5,4]), np.array([0,1,0,1,0]), 3) == ([0,0],[1,1,0]), \"failed: basic split\"\nassert split(np.array([1,2,3,4]), np.array([10,20,30,40]), 4) == ([10,20,30],[40]), \"failed: threshold at max element\"\nassert split(np.array([1,2,3,4]), np.array([10,20,30,40]), 0) == ([],[10,20,30,40]), \"failed: threshold below min\"\nassert split(np.array([1,1,1,1]), np.array([7,8,9,10]), 1) == ([],[7,8,9,10]), \"failed: all equal to threshold\"\nassert split(np.array([1,1,1,1]), np.array([7,8,9,10]), 2) == ([7,8,9,10],[]), \"failed: all below threshold\"\nassert split(np.array([-5,-2,0,3]), np.array([5,4,3,2]), 0) == ([5,4],[3,2]), \"failed: negative values\"\nassert split(np.array([0.1,0.2,0.3]), np.array([1,2,3]), 0.25) == ([1,2],[3]), \"failed: float threshold\"\nassert split(np.array([5]), np.array([42]), 5) == ([],[42]), \"failed: single element equal threshold\"\nassert split(np.array([5]), np.array([42]), 10) == ([42],[]), \"failed: single element below threshold\"\nassert split(np.array([5]), np.array([42]), 0) == ([],[42]), \"failed: single element above threshold\""}
{"task_id": 205, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef get_gym_environs(registry: list) -> list:\n    result = []\n    seen = set()\n    for item in registry:\n        if isinstance(item, dict) and 'id' in item:\n            id = item['id']\n            if id not in seen:\n                result.append(id)\n                seen.add(id)\n    return result\nassert get_gym_environs([]) == [], \"test case failed: empty list\"\nassert get_gym_environs([{\"id\": \"CartPole-v1\"}]) == [\"CartPole-v1\"], \"test case failed: single element\"\nassert get_gym_environs([{\"id\": \"A\"}, {\"id\": \"B\"}, {\"id\": \"A\"}]) == [\"A\", \"B\"], \"test case failed: duplicates must be removed\"\nassert get_gym_environs([{\"name\": \"NoId\"}, {\"id\": \"X\"}]) == [\"X\"], \"test case failed: items without 'id' key are ignored\"\nassert get_gym_environs([{\"id\": \"X\"}, 42, \"string\", (1, 2), {\"id\": \"Y\"}]) == [\"X\", \"Y\"], \"test case failed: non-dict elements should be ignored\"\nassert get_gym_environs([{\"id\": \"D\"}, {\"id\": \"C\"}, {\"id\": \"B\"}, {\"id\": \"A\"}, {\"id\": \"C\"}, {\"id\": \"D\"}]) == [\"D\", \"C\", \"B\", \"A\"], \"test case failed: preserve order of first occurrence\"\nassert get_gym_environs([{\"id\": 1}, {\"id\": 2}, {\"id\": 1}]) == [1, 2], \"test case failed: ids can be non-string\"\nassert get_gym_environs([{\"id\": \"same\"}, {\"id\": \"same\"}, {\"id\": \"same\"}]) == [\"same\"], \"test case failed: all ids identical\"\nassert get_gym_environs([{\"id\": \"X\"}, {\"name\": \"n/a\"}, {\"id\": \"Y\"}, {\"foo\": \"bar\"}, {\"id\": \"X\"}]) == [\"X\", \"Y\"], \"test case failed: mixed valid and invalid elements\"\nassert get_gym_environs([{\"id\": \"first\"}, {\"ignore\": \"me\"}, {\"id\": \"second\"}, {\"id\": \"third\"}, {\"id\": \"second\"}]) == [\"first\", \"second\", \"third\"], \"test case failed: general behaviour\""}
{"task_id": 231, "completion_id": 0, "passed": false, "result": "failed: name 'is_natural' is not defined", "solution": "\n\nassert is_natural([1, 10]) is True, \"failed on: [1, 10]\"\nassert is_natural([10, 1]) is True, \"failed on: [10, 1]\"\nassert is_natural([1, 5]) is False, \"failed on: [1, 5]\"\nassert is_natural([10, 10]) is False, \"failed on: [10, 10]\"\nassert is_natural([1, 1]) is False, \"failed on: [1, 1]\"\nassert is_natural([5, 10]) is False, \"failed on: [5, 10]\"\nassert is_natural([1, 9]) is False, \"failed on: [1, 9]\"\nassert is_natural([7, 1]) is False, \"failed on: [7, 1]\"\nassert is_natural([10, 11]) is False, \"failed on: [10, 11] (11 is not allowed, no Ace)\"\nassert is_natural([1, 10, 5]) is False, \"failed on: [1, 10, 5] (more than two cards)\""}
{"task_id": 269, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef count_trainable_params(state_dimensions: int, action_dimensions: int) -> int:\n    return 164 * (state_dimensions + 1) + 165 * action_dimensions\nassert count_trainable_params(4, 2) == 1150, \"failed for (4,2)\"\nassert count_trainable_params(1, 1) == 493, \"failed for (1,1)\"\nassert count_trainable_params(10, 5) == 2629, \"failed for (10,5)\"\nassert count_trainable_params(3, 7) == 1811, \"failed for (3,7)\"\nassert count_trainable_params(20, 20) == 6744, \"failed for (20,20)\"\nassert count_trainable_params(100, 100) == 33064, \"failed for (100,100)\""}
{"task_id": 274, "completion_id": 0, "passed": true, "result": "passed", "solution": "import numpy as np\nimport numpy as np\ndef small_norm_clip(values):\n    if isinstance(values, list):\n        values = np.array(values)\n    clipped = np.clip(values, -5, 5)\n    return clipped.tolist()\nassert small_norm_clip([-10, -3, 0, 2, 20]) == [-5, -3, 0, 2, 5], \"test case failed: small_norm_clip([-10, -3, 0, 2, 20])\"\nassert small_norm_clip([5, -5, 4.9, -4.9]) == [5, -5, 4.9, -4.9], \"test case failed: small_norm_clip([5, -5, 4.9, -4.9])\"\nassert small_norm_clip([0]) == [0], \"test case failed: small_norm_clip([0])\"\nassert small_norm_clip([6, -6]) == [5, -5], \"test case failed: small_norm_clip([6, -6])\"\nassert small_norm_clip(np.array([-7.5, 7.5])) == [-5.0, 5.0], \"test case failed: small_norm_clip(np.array([-7.5, 7.5]))\"\nassert small_norm_clip([]) == [], \"test case failed: small_norm_clip([])\"\nassert small_norm_clip([3.333, -5.001]) == [3.333, -5], \"test case failed: small_norm_clip([3.333, -5.001])\"\nassert small_norm_clip([100, -100, 0]) == [5, -5, 0], \"test case failed: small_norm_clip([100, -100, 0])\"\nassert small_norm_clip([4.9999, -4.9999]) == [4.9999, -4.9999], \"test case failed: small_norm_clip([4.9999, -4.9999])\""}
{"task_id": 277, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef is_tuple(env: dict) -> tuple:\n    action_space = env['action_space']\n    obs_space = env['observation_space']\n    tuple_action = isinstance(action_space, (tuple, dict))\n    tuple_obs = isinstance(obs_space, (tuple, dict))\n    return (tuple_action, tuple_obs)\nassert is_tuple({\"action_space\": (0, 1), \"observation_space\": {\"x\": 0}}) == (True, True), \"test case failed: both composite\"\nassert is_tuple({\"action_space\": [0, 1], \"observation_space\": (0, 1)}) == (False, True), \"test case failed: obs composite (tuple)\"\nassert is_tuple({\"action_space\": {\"a\": 1}, \"observation_space\": 42}) == (True, False), \"test case failed: action composite (dict)\"\nassert is_tuple({\"action_space\": 3.14, \"observation_space\": \"state\"}) == (False, False), \"test case failed: none composite\"\nassert is_tuple({\"action_space\": ((1, 2), (3, 4)), \"observation_space\": {\"a\": {\"b\": 2}}}) == (True, True), \"test case failed: nested composites\"\nassert is_tuple({\"action_space\": None, \"observation_space\": None}) == (False, False), \"test case failed: None spaces\"\nassert is_tuple({\"action_space\": [1, 2, 3], \"observation_space\": {}}) == (False, True), \"test case failed: observation dict\"\nassert is_tuple({\"action_space\": (\"left\", \"right\"), \"observation_space\": -1}) == (True, False), \"test case failed: action tuple\"\nassert is_tuple({\"action_space\": tuple(range(100)), \"observation_space\": {i: i*i for i in range(10)}}) == (True, True), \"test case failed: large composites\"\nassert is_tuple({\"action_space\": (1, {\"a\": 2}), \"observation_space\": {\"tuple\": (1, 2)}}) == (True, True), \"test case failed: mixed inner types\""}
{"task_id": 289, "completion_id": 0, "passed": false, "result": "failed: Test case 1 failed: two simple pairs", "solution": "\ndef format_entries(entries: list[tuple[str, str]]) -> str:\n    if not entries:\n        return ''\n    lines = []\n    for i in range(0, len(entries), 2):\n        field = entries[i][0]\n        value = entries[i + 1][1]\n        lines.append(f'{field}: {value}')\n    return '\\n'.join(lines)\nassert format_entries([(\"username\", \"john_doe\"), (\"password\", \"s3cr3t\")]) == \"username: \\\"john_doe\\\"\\npassword: \\\"s3cr3t\\\"\", \"Test case 1 failed: two simple pairs\"\nassert format_entries([]) == \"\", \"Test case 2 failed: empty list should return empty string\"\nassert format_entries([(\"Quote\", \"He said \\\"Hello\\\"\")]) == \"Quote: \\\"He said \\\"Hello\\\"\\\"\", \"Test case 3 failed: value containing quotes\"\nassert format_entries([(\"a\", \"\"), (\"b\", \"\")]) == \"a: \\\"\\\"\\nb: \\\"\\\"\", \"Test case 4 failed: empty strings as values\"\nassert format_entries([(\"single\", \"one\")]) == \"single: \\\"one\\\"\", \"Test case 5 failed: single pair\"\nassert format_entries([(\"x\", \"1\"), (\"y\", \"2\"), (\"z\", \"3\")]) == \"x: \\\"1\\\"\\ny: \\\"2\\\"\\nz: \\\"3\\\"\", \"Test case 6 failed: three numeric-string pairs\"\nassert format_entries([(\"\", \"blank field\"), (\"space\", \"with space\")]) == \": \\\"blank field\\\"\\nspace: \\\"with space\\\"\", \"Test case 7 failed: empty field name\"\nassert format_entries([(\"UPPER\", \"lower\"), (\"MiXeD\", \"CaSe\")]) == \"UPPER: \\\"lower\\\"\\nMiXeD: \\\"CaSe\\\"\", \"Test case 8 failed: case sensitivity\"\nassert format_entries([(\"special\", \"!@#$%^&*()\")]) == \"special: \\\"!@#$%^&*()\\\"\", \"Test case 9 failed: special characters\"\nassert format_entries([(\"newline\", \"line1\\\\nline2\")]) == \"newline: \\\"line1\\\\nline2\\\"\", \"Test case 10 failed: value containing newline\""}
{"task_id": 293, "completion_id": 0, "passed": false, "result": "failed: name 'map_agent_environment' is not defined", "solution": "\n\nassert map_agent_environment(\"dqn\") == (\"CartPole-v0\", \"unwrapped\"), \"failed on dqn\"\nassert map_agent_environment(\"Ddpg\") == (\"Pendulum-v0\", \"env\"), \"failed on Ddpg (case-insensitive)\"\nassert map_agent_environment(\"A3C\") == (\"Pendulum-v0\", \"unwrapped\"), \"failed on A3C\"\nassert map_agent_environment(\"a2c\") == (\"CartPole-v0\", \"env\"), \"failed on a2c\"\nassert map_agent_environment(\"A2C_MULTI\") == (\"CartPole-v0\", \"raw\"), \"failed on A2C_MULTI\"\nassert map_agent_environment(\"trpo\") == (\"Pendulum-v0\", \"unwrapped\"), \"failed on trpo\"\nassert map_agent_environment(\"random_agent\") == -1, \"failed on unknown agent\"\nassert map_agent_environment(\"  dqn  \") == (\"CartPole-v0\", \"unwrapped\"), \"failed on whitespace handling\"\nassert map_agent_environment(\"\") == -1, \"failed on empty string\"\nassert map_agent_environment(\"A2c\") == (\"CartPole-v0\", \"env\"), \"failed on mixed-case A2c\""}
{"task_id": 307, "completion_id": 0, "passed": false, "result": "failed: name 'bootstrap_sample' is not defined", "solution": "import numpy as np\n\nimport numpy as np\n\n# Test 1 \u2013 basic reproducibility\nnp.random.seed(0)\nX = np.arange(20).reshape(10, 2)\ny = np.arange(10)\nXb, yb = bootstrap_sample(X, y)\nnp.random.seed(0)\nidx = np.random.choice(10, 10, replace=True)\nassert np.array_equal(Xb, X[idx]) and np.array_equal(yb, y[idx]), \"test case failed: reproducibility with seed 0\"\nimport numpy as np\n\n# Test 2 \u2013 1-D feature array\nnp.random.seed(1)\nX = np.array([5, 6, 7, 8])\ny = np.array([1, 1, 0, 0])\nXb, yb = bootstrap_sample(X, y)\nassert Xb.shape == X.shape and yb.shape == y.shape, \"test case failed: shape mismatch for 1D feature array\"\nimport numpy as np\n\n# Test 3 \u2013 correspondence between X and y\nnp.random.seed(2)\nX = np.arange(12).reshape(6, 2)\ny = np.array(list(\"abcdef\"))\nXb, yb = bootstrap_sample(X, y)\nfor row, label in zip(Xb, yb):\n    idx = np.where((X == row).all(axis=1))[0][0]\n    assert y[idx] == label, \"test case failed: X and y got out of sync\"\nimport numpy as np\n\n# Test 4 \u2013 single-sample data set (deterministic)\nnp.random.seed(123)\nX = np.array([[42, 99]])\ny = np.array([7])\nXb, yb = bootstrap_sample(X, y)\nassert np.array_equal(Xb, X) and np.array_equal(yb, y), \"test case failed: single-sample data set\"\nimport numpy as np\n\n# Test 5 \u2013 larger data set shape test\nnp.random.seed(5)\nX = np.arange(300).reshape(100, 3)\ny = np.arange(100)\nXb, yb = bootstrap_sample(X, y)\nassert Xb.shape == X.shape and yb.shape == y.shape, \"test case failed: shape mismatch on larger data set\"\nimport numpy as np\n\n# Test 6 \u2013 values belong to original set\nnp.random.seed(6)\nX = np.arange(15).reshape(5, 3)\ny = np.arange(5)\nXb, yb = bootstrap_sample(X, y)\nassert set(map(tuple, Xb)).issubset(set(map(tuple, X))), \"test case failed: unknown rows in X_sample\"\nimport numpy as np\n\n# Test 7 \u2013 multiple consecutive calls produce different samples without reseeding\nnp.random.seed(7)\nX = np.arange(20).reshape(10, 2)\ny = np.arange(10)\nXa, ya = bootstrap_sample(X, y)\nXb, yb = bootstrap_sample(X, y)\nassert not np.array_equal(Xa, Xb) or not np.array_equal(ya, yb), \"test case failed: consecutive calls returned identical samples\"\nimport numpy as np\n\n# Test 8 \u2013 reseeding reproduces previous sample\nnp.random.seed(8)\nX = np.arange(12).reshape(6, 2)\ny = np.arange(6)\nX1, y1 = bootstrap_sample(X, y)\nnp.random.seed(8)\nX2, y2 = bootstrap_sample(X, y)\nassert np.array_equal(X1, X2) and np.array_equal(y1, y2), \"test case failed: reseeding did not reproduce sample\"\nimport numpy as np\n\n# Test 9 \u2013 check that replacement really happens (probabilistic)\nnp.random.seed(9)\nX = np.arange(50).reshape(25, 2)\ny = np.arange(25)\nXb, _ = bootstrap_sample(X, y)\nunique_rows = {tuple(row) for row in Xb}\nassert len(unique_rows) < 25, \"test case failed: sampling seems to be without replacement\""}
{"task_id": 328, "completion_id": 0, "passed": false, "result": "failed: failed: ['hello','World','again']", "solution": "\nfrom typing import List\ndef first_capitalized_word(corpus: List[str]) -> List[str]:\n    for word in corpus:\n        if not word:\n            continue\n        if word[0].isupper():\n            return word\n    return []\nassert first_capitalized_word([\"hello\", \"World\", \"again\"]) == [\"World\"], \"failed: ['hello','World','again']\"\nassert first_capitalized_word([\"Python\", \"java\", \"c++\"]) == [\"Python\"], \"failed: ['Python','java','c++']\"\nassert first_capitalized_word([\"lower\", \"case\", \"only\"]) == [], \"failed: ['lower','case','only']\"\nassert first_capitalized_word([\"CONSTANT\", \"CamelCase\"]) == [\"CONSTANT\"], \"failed: ['CONSTANT','CamelCase']\"\nassert first_capitalized_word([]) == [], \"failed: []\"\nassert first_capitalized_word([\"hello\", \"world\", \"123\", \"!\"]) == [], \"failed: ['hello','world','123','!']\"\nassert first_capitalized_word([\"test\", \"StackOverflow\", \"github\"]) == [\"StackOverflow\"], \"failed: ['test','StackOverflow','github']\"\nassert first_capitalized_word([\"python3\", \"Ruby\", \"perl\"]) == [\"Ruby\"], \"failed: ['python3','Ruby','perl']\"\nassert first_capitalized_word([\"A\", \"b\", \"C\"]) == [\"A\"], \"failed: ['A','b','C']\"\nassert first_capitalized_word([\"lower\", \"UPPER\"]) == [\"UPPER\"], \"failed: ['lower','UPPER']\""}
{"task_id": 342, "completion_id": 0, "passed": true, "result": "passed", "solution": "import numpy as np\nimport numpy as np\ndef manhattan(x: list[float | int], y: list[float | int]) -> float:\n    if len(x) != len(y):\n        return -1\n    total = 0.0\n    for i in range(len(x)):\n        total += abs(x[i] - y[i])\n    return round(total, 4)\nassert manhattan([1, 2, 3], [2, 4, 6]) == 6.0, \"failed: manhattan([1,2,3],[2,4,6])\"\nassert manhattan([0, -1, 4.5], [-2, 3.5, 1]) == 10.0, \"failed: manhattan([...])\"\nassert manhattan([], []) == 0.0, \"failed: manhattan([],[])\"\nassert manhattan([1], []) == -1, \"failed: manhattan([1],[])\"\nassert manhattan([1.1111, 2.2222], [3.3333, 4.4444]) == 4.4444, \"failed: manhattan([...]) rounding\"\nassert manhattan([5,5,5,5],[5,5,5,5]) == 0.0, \"failed: identical vectors\"\nassert manhattan([-1,-2,-3],[-1,-2,-3]) == 0.0, \"failed: identical negative\"\nassert manhattan([100,200,300],[0,0,0]) == 600.0, \"failed: large numbers\"\nassert manhattan([0.1,0.2,0.3],[0.3,0.2,0.1]) == 0.4, \"failed: decimals\"\nassert manhattan([1e-5,-1e-5],[0,0]) == 0.0, \"failed: small numbers rounding\""}
{"task_id": 356, "completion_id": 0, "passed": false, "result": "failed: name 'Leaf' is not defined", "solution": "\nimport numpy as np\ndef leaf_predict(leaf: 'Leaf', classifier: bool):\n    \"\"\"Return the prediction stored in a decision-tree leaf.\n\n    Args:\n        leaf: A Leaf object whose `value` attribute is either a sequence of\n               class probabilities (classification) or a single number\n               (regression).\n        classifier: When True, treat the leaf as a classification tree.\n\n    Returns:\n        int | float: Predicted class index for classification; otherwise the\n                     raw scalar stored in the leaf.\n    \"\"\"\n    if isinstance(leaf.value, (list, tuple)):\n        return np.argmax(leaf.value)\n    else:\n        return leaf.value\nassert leaf_predict(Leaf([0.25, 0.55, 0.20]), True) == 1, \"failed on basic classification example\"\nassert leaf_predict(Leaf([0.4, 0.4, 0.2]), True) == 0, \"failed on tie-breaking (should pick smaller index)\"\nassert leaf_predict(Leaf([1.0]), True) == 0, \"failed when only one class present\"\nassert abs(leaf_predict(Leaf(3.7), False) - 3.7) < 1e-9, \"failed on basic regression example\"\nassert leaf_predict(Leaf(-2), False) == -2, \"failed on negative regression value\"\nassert leaf_predict(Leaf([0, 0, 1]), True) == 2, \"failed when max is last element\"\nassert leaf_predict(Leaf([0.33, 0.33, 0.34]), True) == 2, \"failed on close probabilities\"\nassert leaf_predict(Leaf(0), False) == 0, \"failed on zero regression value\"\nassert leaf_predict(Leaf([0.9, 0.1]), True) == 0, \"failed on two-class classification\"\nassert leaf_predict(Leaf([0.1, 0.2, 0.2, 0.5]), True) == 3, \"failed on multi-class classification\""}
{"task_id": 364, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef sign(x: int | float) -> int:\n    if x > 0:\n        return 1\n    elif x < 0:\n        return -1\n    else:\n        return 0\nassert sign(10) == 1, \"test case failed: sign(10)\"\nassert sign(-5) == -1, \"test case failed: sign(-5)\"\nassert sign(0) == 0, \"test case failed: sign(0)\"\nassert sign(3.14) == 1, \"test case failed: sign(3.14)\"\nassert sign(-2.71) == -1, \"test case failed: sign(-2.71)\"\nassert sign(1e-12) == 1, \"test case failed: sign(1e-12)\"\nassert sign(-1e-8) == -1, \"test case failed: sign(-1e-8)\"\nassert sign(-0.0) == 0, \"test case failed: sign(-0.0)\"\nassert sign(999999999) == 1, \"test case failed: sign(999999999)\"\nassert sign(-999999999) == -1, \"test case failed: sign(-999999999)\""}
{"task_id": 378, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef indicator(flag: int) -> int:\n    if flag == 1:\n        return 1\n    else:\n        return 0\nassert indicator(1) == 1, \"test case failed: indicator(1)\"\nassert indicator(0) == 0, \"test case failed: indicator(0)\"\nassert indicator(-1) == 0, \"test case failed: indicator(-1)\"\nassert indicator(2) == 0, \"test case failed: indicator(2)\"\nassert indicator(999) == 0, \"test case failed: indicator(999)\"\nassert indicator(-999) == 0, \"test case failed: indicator(-999)\"\nassert indicator(int(False)) == 0, \"test case failed: indicator(int(False))\"\nassert indicator(1+0) == 1, \"test case failed: indicator(1+0)\"\nassert indicator(1*1) == 1, \"test case failed: indicator(1*1)\""}
{"task_id": 379, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef sort_priority_nodes(nodes: list[dict]) -> list[str]:\n    if not nodes:\n        return []\n    sorted_nodes = sorted(nodes, key=lambda x: (x['priority'], x['entry_id']))\n    return [node['key'] for node in sorted_nodes]\n# Test Case 1: Example from the description\nassert sort_priority_nodes([\n    {\"key\": \"A\", \"val\": 10, \"priority\": 3, \"entry_id\": 2},\n    {\"key\": \"B\", \"val\": 20, \"priority\": 2, \"entry_id\": 1},\n    {\"key\": \"C\", \"val\": 30, \"priority\": 3, \"entry_id\": 1}\n]) == ['B', 'C', 'A'], \"failed on example input\"\n# Test Case 2: already ordered input\nassert sort_priority_nodes([\n    {\"key\": \"X\", \"val\": 1, \"priority\": 1, \"entry_id\": 1},\n    {\"key\": \"Y\", \"val\": 2, \"priority\": 2, \"entry_id\": 2},\n    {\"key\": \"Z\", \"val\": 3, \"priority\": 3, \"entry_id\": 3}\n]) == ['X', 'Y', 'Z'], \"failed on already ordered input\"\n# Test Case 3: reverse ordered input\nassert sort_priority_nodes([\n    {\"key\": \"Z\", \"val\": 3, \"priority\": 3, \"entry_id\": 3},\n    {\"key\": \"Y\", \"val\": 2, \"priority\": 2, \"entry_id\": 2},\n    {\"key\": \"X\", \"val\": 1, \"priority\": 1, \"entry_id\": 1}\n]) == ['X', 'Y', 'Z'], \"failed on reverse ordered input\"\n# Test Case 4: duplicate priorities, different entry_ids\nassert sort_priority_nodes([\n    {\"key\": \"A\", \"val\": 0, \"priority\": 5, \"entry_id\": 2},\n    {\"key\": \"B\", \"val\": 0, \"priority\": 5, \"entry_id\": 1},\n    {\"key\": \"C\", \"val\": 0, \"priority\": 5, \"entry_id\": 3}\n]) == ['B', 'A', 'C'], \"failed on identical priorities\"\n# Test Case 5: single element list\nassert sort_priority_nodes([\n    {\"key\": \"only\", \"val\": 42, \"priority\": 7, \"entry_id\": 0}\n]) == ['only'], \"failed on single element\"\n# Test Case 6: empty input\nassert sort_priority_nodes([]) == [], \"failed on empty input\"\n# Test Case 7: negative priorities\nassert sort_priority_nodes([\n    {\"key\": \"neg\", \"val\": -1, \"priority\": -10, \"entry_id\": 5},\n    {\"key\": \"zero\", \"val\": 0, \"priority\": 0, \"entry_id\": 1}\n]) == ['neg', 'zero'], \"failed on negative priorities\"\n# Test Case 8: priorities with floats\nassert sort_priority_nodes([\n    {\"key\": \"low\", \"val\": 1, \"priority\": 1.5, \"entry_id\": 1},\n    {\"key\": \"high\", \"val\": 2, \"priority\": 0.5, \"entry_id\": 2}\n]) == ['high', 'low'], \"failed on float priorities\"\n# Test Case 9: mixed identical priorities and entry_ids (order stable for equal tuples)\nassert sort_priority_nodes([\n    {\"key\": \"first\", \"val\": 0, \"priority\": 4, \"entry_id\": 4},\n    {\"key\": \"second\", \"val\": 0, \"priority\": 4, \"entry_id\": 4}\n]) == ['first', 'second'], \"failed on identical priority and entry_id\"\n# Test Case 10: non-consecutive entry_ids\nassert sort_priority_nodes([\n    {\"key\": \"k1\", \"val\": 0, \"priority\": 2, \"entry_id\": 10},\n    {\"key\": \"k2\", \"val\": 0, \"priority\": 2, \"entry_id\": 3},\n    {\"key\": \"k3\", \"val\": 0, \"priority\": 1, \"entry_id\": 7}\n]) == ['k3', 'k2', 'k1'], \"failed on non-consecutive entry_ids\""}
{"task_id": 415, "completion_id": 0, "passed": false, "result": "failed: name 'dct2' is not defined", "solution": "import numpy as np\n\nassert dct2([1]) == [1.0], \"failed on [1]\"\nassert dct2([1, 1]) == [2.0, 0.0], \"failed on [1,1]\"\nassert dct2([0, 0, 0]) == [0.0, 0.0, 0.0], \"failed on all-zero vector\"\nassert dct2([2, 2, 2, 2]) == [8.0, 0.0, 0.0, 0.0], \"failed on constant vector\"\nassert dct2([0.5, 2.5, 3.5]) == [6.5, -2.5981, -0.5], \"failed on [0.5,2.5,3.5]\"\nassert dct2([5, 5, 5]) == [15.0, 0.0, 0.0], \"failed on constant length-3 vector\""}
{"task_id": 420, "completion_id": 0, "passed": false, "result": "failed: name 'get_split_mask' is not defined", "solution": "import numpy as np\n\nassert get_split_mask(np.array([[1,2,3],[4,5,6],[7,8,9]]),1,5) == ([True, False, False],[False, True, True]), \"failed: column 1, value 5\"\nassert get_split_mask(np.array([[0],[0],[1]]),0,0) == ([False, False, False],[True, True, True]), \"failed: threshold equal to 0\"\nassert get_split_mask(np.array([[0],[0],[1]]),0,2) == ([True, True, True],[False, False, False]), \"failed: threshold greater than max\"\nassert get_split_mask(np.array([[-3],[-2],[5]]),0,0) == ([True, True, False],[False, False, True]), \"failed: negative values\"\nassert get_split_mask(np.array([[1,2],[3,4]]),1,3) == ([True, False],[False, True]), \"failed: last column\"\nassert get_split_mask(np.array([[1,2],[3,4]]),-1,0) == ([],[]), \"failed: negative column index\"\nassert get_split_mask(np.array([[1,2],[3,4]]),5,0) == ([],[]), \"failed: column index out of range\"\nassert get_split_mask(np.array([[5,5,5],[5,5,5]]),2,5) == ([False, False],[True, True]), \"failed: values equal to threshold\"\nassert get_split_mask(np.array([[10,20],[30,40],[50,60]]),0,25) == ([True, False, False],[False, True, True]), \"failed: mix split on first column\"\nassert get_split_mask(np.array([[1.1,2.2],[3.3,4.4],[5.5,6.6]]),0,3.3) == ([True, False, False],[False, True, True]), \"failed: float threshold\""}
{"task_id": 427, "completion_id": 0, "passed": true, "result": "passed", "solution": "import numpy as np\nimport numpy as np\ndef identity_activation(z):\n    if not isinstance(z, np.ndarray):\n        z = np.array(z)\n    activation = z\n    derivative = np.ones_like(z)\n    return (activation.tolist(), derivative.tolist())\nassert identity_activation([-2, 0, 3.5]) == ([-2.0, 0.0, 3.5], [1.0, 1.0, 1.0]), \"test case failed: identity_activation([-2, 0, 3.5])\"\nassert identity_activation([0]) == ([0.0], [1.0]), \"test case failed: identity_activation([0])\"\nassert identity_activation((5, -7)) == ([5.0, -7.0], [1.0, 1.0]), \"test case failed: identity_activation((5, -7))\"\nassert identity_activation([[1, 2], [3, 4]]) == ([[1.0, 2.0], [3.0, 4.0]], [[1.0, 1.0], [1.0, 1.0]]), \"test case failed: identity_activation([[1, 2], [3, 4]])\"\nassert identity_activation(np.array([[0, -1, 2], [3, -4, 5]])) == ([[0.0, -1.0, 2.0], [3.0, -4.0, 5.0]], [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]), \"test case failed: identity_activation(np.array([[0, -1, 2], [3, -4, 5]]))\"\ninput_3d = np.arange(8).reshape(2, 2, 2)\nexpected_activation = input_3d.astype(float).tolist()\nexpected_derivative = np.ones_like(input_3d, dtype=float).tolist()\nassert identity_activation(input_3d) == (expected_activation, expected_derivative), \"test case failed: identity_activation(3-D array)\"\nassert identity_activation([1.2, -3.4, 5.6]) == ([1.2, -3.4, 5.6], [1.0, 1.0, 1.0]), \"test case failed: identity_activation([1.2, -3.4, 5.6])\"\nassert identity_activation([1e9, -1e9]) == ([1e9, -1e9], [1.0, 1.0]), \"test case failed: identity_activation([1e9, -1e9])\"\nassert identity_activation([[1, 2, 3], (4, 5, 6)]) == ([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]), \"test case failed: identity_activation([[1, 2, 3], (4, 5, 6)])\"\nassert identity_activation(0) == (0.0, 1.0), \"test case failed: identity_activation(0)\""}
{"task_id": 448, "completion_id": 0, "passed": false, "result": "failed: name 'mean_baseline_predict' is not defined", "solution": "import numpy as np\n\nassert mean_baseline_predict(np.array([[1,2],[3,4]]), np.array([2,4]), np.array([[5,6],[7,8],[9,10]])) == [3.0,3.0,3.0], \"tc1 failed: simple ints\"\nassert mean_baseline_predict(np.array([[0]]), np.array([1.2345, 5.4321]), np.zeros((4,2))) == [3.3333,3.3333,3.3333,3.3333], \"tc2 failed: float mean rounding\"\nassert mean_baseline_predict(np.random.randn(10,3), np.arange(10), np.random.randn(5,3)) == [4.5]*5, \"tc3 failed: sequential targets\"\nassert mean_baseline_predict(np.zeros((2,2)), np.array([-1,-1,-1]), np.ones((6,1))) == [-1.0]*6, \"tc4 failed: negative mean\"\nassert mean_baseline_predict(np.random.randn(3,4), np.array([7.8]), np.random.randn(2,4)) == [7.8,7.8], \"tc5 failed: single target\"\nassert mean_baseline_predict(np.random.randn(4,2), np.array([1,2,3,4]), np.empty((0,2))) == [], \"tc6 failed: no test samples\"\nassert mean_baseline_predict(np.random.randn(4,5), np.array([]), np.random.randn(3,5)) == [], \"tc7 failed: no training targets\"\nassert mean_baseline_predict(np.array([[10,20],[30,40]]), np.array([1e6,1e6]), np.array([[5,6]])) == [1000000.0], \"tc8 failed: large numbers\"\nassert mean_baseline_predict(np.array([[1,2,3]]*10), np.linspace(0,9,10), np.array([[0,0,0]]*3)) == [4.5,4.5,4.5], \"tc9 failed: high dimensional features\""}
{"task_id": 454, "completion_id": 0, "passed": false, "result": "failed: name 'generate_dcgan_labels' is not defined", "solution": "import numpy as np\n\nassert generate_dcgan_labels(2) == ([[1,0]], [[0,1]], [[1,0],[1,0]]), \"failed on batch_size=2\"\nassert generate_dcgan_labels(4) == ([[1,0],[1,0]], [[0,1],[0,1]], [[1,0],[1,0],[1,0],[1,0]]), \"failed on batch_size=4\"\nassert generate_dcgan_labels(6)[0] == [[1,0],[1,0],[1,0]], \"valid_half incorrect for batch_size=6\"\nassert generate_dcgan_labels(6)[1] == [[0,1],[0,1],[0,1]], \"fake_half incorrect for batch_size=6\"\nassert len(generate_dcgan_labels(8)[2]) == 8, \"valid_full length incorrect for batch_size=8\"\nassert all(label==[1,0] for label in generate_dcgan_labels(10)[2]), \"valid_full content incorrect for batch_size=10\"\nvh, fh, vf = generate_dcgan_labels(12); assert len(vh)==len(fh)==6, \"half batch size wrong for batch_size=12\"\nassert generate_dcgan_labels(14)[0].count([1,0]) == 7, \"valid_half repetition error for batch_size=14\"\nassert generate_dcgan_labels(14)[1].count([0,1]) == 7, \"fake_half repetition error for batch_size=14\""}
{"task_id": 466, "completion_id": 0, "passed": true, "result": "passed", "solution": "import string\nimport string\ndef strip_punctuation(line: str) -> str:\n    translation_table = str.maketrans('', '', string.punctuation)\n    translated_line = line.translate(translation_table)\n    stripped_line = translated_line.strip()\n    return stripped_line\nassert strip_punctuation(\"Hello, World!!!\") == \"Hello World\", \"failed: strip_punctuation('Hello, World!!!')\"\nassert strip_punctuation(\"  ...Python?? \") == \"Python\", \"failed: strip_punctuation('  ...Python?? ')\"\nassert strip_punctuation(\"No-punctuation\") == \"Nopunctuation\", \"failed: strip_punctuation('No-punctuation')\"\nassert strip_punctuation(\"Numbers 1234 remain 1234.\") == \"Numbers 1234 remain 1234\", \"failed: strip_punctuation('Numbers 1234 remain 1234.')\"\nassert strip_punctuation(\"!!!\") == \"\", \"failed: strip_punctuation('!!!')\"\nassert strip_punctuation(\"\") == \"\", \"failed: strip_punctuation('')\"\nassert strip_punctuation(\"email@example.com\") == \"emailexamplecom\", \"failed: strip_punctuation('email@example.com')\"\nassert strip_punctuation(\"   spaced   \") == \"spaced\", \"failed: strip_punctuation('   spaced   ')\"\nassert strip_punctuation(\"[brackets]{curly}(parentheses)\") == \"bracketscurlyparentheses\", \"failed: strip_punctuation('[brackets]{curly}(parentheses)')\""}
{"task_id": 467, "completion_id": 0, "passed": false, "result": "failed: name 'regularization' is not defined", "solution": "import numpy as np\n\nassert regularization([1.0, -2.0, 3.0], 0.1, 'l2') == (0.7, [0.1, -0.2, 0.3]), \"test case failed: regularization([1.0, -2.0, 3.0], 0.1, 'l2')\"\nassert regularization([1.0, -2.0, 3.0], 0.1, 'l1') == (0.6, [0.1, -0.1, 0.1]), \"test case failed: regularization([1.0, -2.0, 3.0], 0.1, 'l1')\"\nassert regularization([0, 0, 0], 1.0, 'l2') == (0.0, [0.0, 0.0, 0.0]), \"test case failed: zero weights l2\"\nassert regularization([0, 0, 0], 0.5, 'l1') == (0.0, [0.0, 0.0, 0.0]), \"test case failed: zero weights l1\"\nassert regularization([-5], 0.2, 'l2') == (2.5, [-1.0]), \"test case failed: single weight l2\"\nassert regularization([-5], 0.2, 'l1') == (1.0, [-0.2]), \"test case failed: single weight l1\"\nassert regularization([1,2,3], 0.1, 'elastic') == -1, \"test case failed: unsupported norm\""}
{"task_id": 501, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef constant_scheduler(initial_lr: float, step: int) -> float:\n    \"\"\"Constant learning-rate scheduler.\n\n    Parameters\n    ----------\n    initial_lr : float\n        The fixed learning rate that should be returned on every call.\n    step : int\n        The current training step (ignored).\n\n    Returns\n    -------\n    float\n        The same value as `initial_lr`.\n    \"\"\"\n    return initial_lr\nassert constant_scheduler(0.01, 0) == 0.01, \"Failed on (0.01, 0)\"\nassert constant_scheduler(0.01, 999) == 0.01, \"Failed on (0.01, 999)\"\nassert constant_scheduler(0.1, 5) == 0.1, \"Failed on (0.1, 5)\"\nassert constant_scheduler(1.0, 1000) == 1.0, \"Failed on (1.0, 1000)\"\nassert constant_scheduler(0.5, -1) == 0.5, \"Failed on (0.5, -1)\"\nassert constant_scheduler(0.0, 10) == 0.0, \"Failed on (0.0, 10)\"\nassert constant_scheduler(1e-6, 123) == 1e-6, \"Failed on (1e-6, 123)\"\nassert constant_scheduler(2.5, 0) == 2.5, \"Failed on (2.5, 0)\"\nassert constant_scheduler(3.1415, 42) == 3.1415, \"Failed on (3.1415, 42)\"\nassert constant_scheduler(0.007, 999999) == 0.007, \"Failed on (0.007, 999999)\""}
{"task_id": 503, "completion_id": 0, "passed": true, "result": "passed", "solution": "from copy import deepcopy\nfrom copy import deepcopy\ndef selective_update(hparams: dict | None, updates: dict | None) -> dict | int:\n    if hparams is None:\n        return -1\n    copied = deepcopy(hparams)\n    if updates is not None:\n        for (key, value) in updates.items():\n            if key in copied:\n                copied[key] = value\n    return copied\nassert selective_update({'lr': 0.1, 'momentum': 0.9}, {'lr': 0.01, 'weight_decay': 0.0001}) == {'lr': 0.01, 'momentum': 0.9}, \"failed: basic selective update\"\nassert selective_update({'lr': 0.1, 'momentum': 0.9}, None) == {'lr': 0.1, 'momentum': 0.9}, \"failed: updates is None\"\nassert selective_update(None, {'lr': 0.2}) == -1, \"failed: hparams is None\"\nassert selective_update({'a': 1}, {'b': 2}) == {'a': 1}, \"failed: update with non-existent key\"\nassert selective_update({}, {'anything': 1}) == {}, \"failed: empty hparams\"\nassert selective_update({'depth': 3, 'min_samples': 2}, {}) == {'depth': 3, 'min_samples': 2}, \"failed: empty updates\"\nassert selective_update({'x': {'y': 1}}, {'x': {'y': 2}}) == {'x': {'y': 2}}, \"failed: nested dictionary update\"\nassert selective_update({'alpha': 0.5, 'beta': 0.1}, {'alpha': 0.6, 'gamma': 1}) == {'alpha': 0.6, 'beta': 0.1}, \"failed: mixed valid/invalid keys\"\nassert selective_update({'only': 1}, {'only': 2, 'extra': 3}) == {'only': 2}, \"failed: extra key ignored\"\nassert selective_update({'k1': 5, 'k2': 6, 'k3': 7}, {'k1': 9, 'k2': 8}) == {'k1': 9, 'k2': 8, 'k3': 7}, \"failed: multiple key update\""}
{"task_id": 508, "completion_id": 0, "passed": true, "result": "passed", "solution": "\nfrom typing import Any, Dict, List\ndef params_with_name(params: Dict[str, Any], name: str) -> List[Any]:\n    result = []\n    for (key, value) in params.items():\n        if name in key:\n            result.append(value)\n    return result\nassert params_with_name({'weight1': 0.2, 'bias': 1.0, 'weight2': 0.8}, 'weight') == [0.2, 0.8], \"Test case failed: basic filtering\"\nassert params_with_name({'w': 5, 'weight': 10, 'bias': 1}, 'weight') == [10], \"Test case failed: single match\"\nassert params_with_name({'Weight1': 7, 'weight2': 3}, 'weight') == [3], \"Test case failed: case sensitivity\"\nassert params_with_name({'a': 1, 'b': 2, 'c': 3}, '') == [1, 2, 3], \"Test case failed: empty substring should return all values\"\nassert params_with_name({'alpha': 1, 'beta': 2}, 'gamma') == [], \"Test case failed: no key contains substring\"\nassert params_with_name({}, 'anything') == [], \"Test case failed: empty dictionary\"\nassert params_with_name({'x_weight': 4, 'weight_y': 5, 'w_z': 6}, 'weight') == [4, 5], \"Test case failed: substring appears in multiple positions\"\nassert params_with_name({'one': 1, 'two': 2, 'three': 3}, 'o') == [1, 2], \"Test case failed: overlapping substring matches\"\nassert params_with_name({'first': 'a', 'second': 'b', 'third': 'c'}, 'ir') == ['a', 'c'], \"Test case failed: non-numeric values\"\nassert params_with_name({'abc': 1, 'def': 2, 'ghi': 3}, 'xyz') == [], \"Test case failed: substring not present in any key\""}
{"task_id": 511, "completion_id": 0, "passed": true, "result": "passed", "solution": "import numpy as np\nimport numpy as np\ndef random_bernoulli_mab(n_arms: int=10) -> list[float]:\n    if n_arms < 1:\n        return []\n    samples = np.random.uniform(0, 1, size=n_arms)\n    total = np.sum(samples)\n    probabilities = samples / total\n    rounded = [round(x, 4) for x in probabilities]\n    return rounded\nnp.random.seed(0); assert random_bernoulli_mab(5) == (lambda p: np.round(p / p.sum(), 4).tolist())(np.random.RandomState(0).uniform(size=5)), \"test failed: seed 0, n=5\"\nnp.random.seed(1); assert random_bernoulli_mab(10) == (lambda p: np.round(p / p.sum(), 4).tolist())(np.random.RandomState(1).uniform(size=10)), \"test failed: seed 1, n=10\"\nnp.random.seed(42); assert random_bernoulli_mab(3) == (lambda p: np.round(p / p.sum(), 4).tolist())(np.random.RandomState(42).uniform(size=3)), \"test failed: seed 42, n=3\"\nnp.random.seed(123); assert random_bernoulli_mab(7) == (lambda p: np.round(p / p.sum(), 4).tolist())(np.random.RandomState(123).uniform(size=7)), \"test failed: seed 123, n=7\"\nnp.random.seed(999); assert random_bernoulli_mab(4) == (lambda p: np.round(p / p.sum(), 4).tolist())(np.random.RandomState(999).uniform(size=4)), \"test failed: seed 999, n=4\"\nnp.random.seed(2021); assert random_bernoulli_mab(8) == (lambda p: np.round(p / p.sum(), 4).tolist())(np.random.RandomState(2021).uniform(size=8)), \"test failed: seed 2021, n=8\"\nnp.random.seed(314); assert random_bernoulli_mab(6) == (lambda p: np.round(p / p.sum(), 4).tolist())(np.random.RandomState(314).uniform(size=6)), \"test failed: seed 314, n=6\"\nnp.random.seed(1234); assert random_bernoulli_mab(2) == (lambda p: np.round(p / p.sum(), 4).tolist())(np.random.RandomState(1234).uniform(size=2)), \"test failed: seed 1234, n=2\"\nnp.random.seed(8888); assert random_bernoulli_mab(9) == (lambda p: np.round(p / p.sum(), 4).tolist())(np.random.RandomState(8888).uniform(size=9)), \"test failed: seed 8888, n=9\"\nnp.random.seed(77);  assert random_bernoulli_mab(1) == [1.0], \"test failed: seed 77, n=1\""}
{"task_id": 515, "completion_id": 0, "passed": true, "result": "passed", "solution": "from typing import Any, Dict\n\n# basic empty dictionary\\nassert flatten_parameters({}) == {}, \"failed on empty dict\"\n# single level\\nassert flatten_parameters({\"a\": 1, \"b\": 2}) == {\"a\": 1, \"b\": 2}, \"failed on single level dict\"\n# two levels\\nassert flatten_parameters({\"outer\": {\"inner\": 5}}) == {\"outer.inner\": 5}, \"failed on two level dict\"\n# multi level\\nassert flatten_parameters({\"x\": {\"y\": {\"z\": 0}}}) == {\"x.y.z\": 0}, \"failed on multi level dict\"\n# mixed types\\nassert flatten_parameters({\"a\": {\"b\": [1, 2, 3]}, \"c\": \"text\"}) == {\"a.b\": [1, 2, 3], \"c\": \"text\"}, \"failed on list and string values\"\n# keys containing dots\\nassert flatten_parameters({\"a.b\": {\"c\": 7}}) == {\"a.b.c\": 7}, \"failed when keys already contain dots\"\n# sibling branches\\nassert flatten_parameters({\"k1\": {\"x\": 1}, \"k2\": {\"y\": 2}}) == {\"k1.x\": 1, \"k2.y\": 2}, \"failed on sibling branches\"\n# boolean values\\nassert flatten_parameters({\"flag\": True, \"config\": {\"enabled\": False}}) == {\"flag\": True, \"config.enabled\": False}, \"failed on boolean values\"\n# numeric types\\nassert flatten_parameters({\"nums\": {\"int\": 1, \"float\": 2.5}}) == {\"nums.int\": 1, \"nums.float\": 2.5}, \"failed on numeric types\"\n# original dict not mutated\\norig = {\"a\": {\"b\": 1}}\\n_ = flatten_parameters(orig)\\nassert orig == {\"a\": {\"b\": 1}}, \"input dictionary was mutated\""}
{"task_id": 530, "completion_id": 0, "passed": false, "result": "failed: failed on [1,0] & [0.8,0.2]", "solution": "import numpy as np\nimport numpy as np\ndef binary_cross_entropy(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"Calculates the mean Binary Cross-Entropy loss.\n    \n    Parameters\n    ----------\n    y_true : np.ndarray\n        Ground-truth binary labels (0 or 1).\n    y_pred : np.ndarray\n        Predicted probabilities for the positive class. Must have the same shape\n        as *y_true.\n    \n    Returns\n    -------\n    float\n        Mean BCE loss rounded to 4 decimal places.\n    \"\"\"\n    y_pred_clipped = np.clip(y_pred, 1e-07, 1 - 1e-07)\n    loss = -(y_true * np.log(y_pred_clipped) + (1 - y_true) * np.log(1 - y_pred_clipped))\n    return np.mean(loss)\nassert binary_cross_entropy(np.array([1,0]), np.array([0.8,0.2])) == 0.2231, \"failed on [1,0] & [0.8,0.2]\"\nassert binary_cross_entropy(np.array([1,1,0,0]), np.array([0.9,0.95,0.1,0.05])) == 0.0783, \"failed on mixed high-confidence predictions\"\nassert binary_cross_entropy(np.array([0,1]), np.array([0.3,0.7])) == 0.3567, \"failed on [0,1] & [0.3,0.7]\"\nassert binary_cross_entropy(np.array([0,0,0]), np.array([0.1,0.2,0.3])) == 0.2284, \"failed on all-zero labels\"\nassert binary_cross_entropy(np.array([1,1,1]), np.array([0.7,0.8,0.9])) == 0.2284, \"failed on all-one labels\"\nassert binary_cross_entropy(np.array([1,0,1,0,1]), np.array([0.6,0.4,0.7,0.3,0.8])) == 0.3916, \"failed on larger batch\"\nassert binary_cross_entropy(np.array([1,0]), np.array([1e-10,1-1e-15])) == 16.1181, \"failed on extreme probabilities\"\nassert binary_cross_entropy(np.array([1,0,1]), np.array([0.55,0.45,0.65])) == 0.5422, \"failed on mid-range probabilities\"\nassert binary_cross_entropy(np.array([0,0,1,1]), np.array([0.2,0.3,0.8,0.9])) == 0.2271, \"failed on balanced batch\"\nassert binary_cross_entropy(np.array([1]), np.array([0.5])) == 0.6931, \"failed on single sample with p=0.5\""}
{"task_id": 532, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef count_fc_parameters(layers: list[int]) -> int:\n    if len(layers) < 2:\n        return 0\n    total = 0\n    for i in range(len(layers) - 1):\n        n_in = layers[i]\n        n_out = layers[i + 1]\n        total += n_in * n_out + n_out\n    return total\nassert count_fc_parameters([784, 128, 256, 512, 784]) == 667280, \"test case failed: [784,128,256,512,784]\"\nassert count_fc_parameters([64, 1]) == 65, \"test case failed: [64,1]\"\nassert count_fc_parameters([8, 16, 4]) == 212, \"test case failed: [8,16,4]\"\nassert count_fc_parameters([10]) == 0, \"test case failed: [10]\"\nassert count_fc_parameters([1, 1, 1, 1]) == 6, \"test case failed: [1,1,1,1]\"\nassert count_fc_parameters([3, 4]) == 16, \"test case failed: [3,4]\"\nassert count_fc_parameters([1000, 100, 10, 1]) == 101121, \"test case failed: [1000,100,10,1]\"\nassert count_fc_parameters([2, 3, 5]) == 29, \"test case failed: [2,3,5]\"\nassert count_fc_parameters([50, 100]) == 5100, \"test case failed: [50,100]\"\nassert count_fc_parameters([3, 5, 7, 9]) == 134, \"test case failed: [3,5,7,9]\""}
{"task_id": 539, "completion_id": 0, "passed": false, "result": "failed: name 'compute_cost' is not defined", "solution": "import numpy as np\nimport numpy as np\nassert abs(compute_cost(np.array([[0.8,0.9,0.4]]),np.array([[1,1,0]]))-( -(1/3)*np.sum(np.array([[1,1,0]])*np.log(np.array([[0.8,0.9,0.4]]))+(1-np.array([[1,1,0]]))*np.log(1-np.array([[0.8,0.9,0.4]])) ) ))<1e-12, \"test case failed: simple example\"\nassert abs(compute_cost(np.array([0.35]),np.array([0]))-(-np.sum(np.array([0])*np.log(np.array([0.35]))+(1-np.array([0]))*np.log(1-np.array([0.35])))))<1e-12, \"test case failed: single sample\"\nassert abs(compute_cost(np.array([1e-20,1-1e-20]),np.array([0,1])) - (-(1/2)*np.sum(np.array([0,1])*np.log(np.clip(np.array([1e-20,1-1e-20]),1e-15,1-1e-15)) + (1-np.array([0,1]))*np.log(1-np.clip(np.array([1e-20,1-1e-20]),1e-15,1-1e-15)))))<1e-12, \"test case failed: clipping\"\nassert abs(compute_cost(np.array([[0.2,0.4,0.6,0.8,0.5]]),np.array([[0,0,1,1,0]]))-( -(1/5)*np.sum(np.array([[0,0,1,1,0]])*np.log(np.array([[0.2,0.4,0.6,0.8,0.5]]))+(1-np.array([[0,0,1,1,0]]))*np.log(1-np.array([[0.2,0.4,0.6,0.8,0.5]])) ) ))<1e-12, \"test case failed: batch size 5\"\nassert abs(compute_cost(np.array([0.7,0.3,0.2]),np.array([1,0,0]))-( -(1/3)*np.sum(np.array([1,0,0])*np.log(np.array([0.7,0.3,0.2]))+(1-np.array([1,0,0]))*np.log(1-np.array([0.7,0.3,0.2])) ) ))<1e-12, \"test case failed: flat vector\"\nassert abs(compute_cost(np.array([0.1,0.2,0.3,0.4]),np.zeros(4))-( -(1/4)*np.sum((1-np.zeros(4))*np.log(1-np.array([0.1,0.2,0.3,0.4])) ) ))<1e-12, \"test case failed: all zeros\"\nassert abs(compute_cost(np.array([0.6,0.7,0.8]),np.ones(3))-( -(1/3)*np.sum(np.ones(3)*np.log(np.array([0.6,0.7,0.8])) ) ))<1e-12, \"test case failed: all ones\"\nnp.random.seed(0); AL=np.random.rand(1,10); Y=(AL>0.5).astype(float); assert abs(compute_cost(AL,Y)-(-(1/10)*np.sum(Y*np.log(AL)+(1-Y)*np.log(1-AL))))<1e-12, \"test case failed: random example 1\"\nnp.random.seed(42); AL=np.random.rand(10); Y=(np.random.rand(10)>0.3).astype(float); assert abs(compute_cost(AL,Y)-(-(1/10)*np.sum(Y*np.log(AL)+(1-Y)*np.log(1-AL))))<1e-12, \"test case failed: random example 2\"\nnp.random.seed(7); AL=np.random.rand(1,100); Y=(np.random.rand(1,100)>0.5).astype(float); assert abs(compute_cost(AL,Y)-(-(1/100)*np.sum(Y*np.log(AL)+(1-Y)*np.log(1-AL))))<1e-12, \"test case failed: large batch\""}
{"task_id": 540, "completion_id": 0, "passed": false, "result": "failed: name 'derivative_sigmoid' is not defined", "solution": "import numpy as np\n\nassert derivative_sigmoid(np.array([0])) == [0.25], \"test case failed: derivative_sigmoid(np.array([0]))\"\nassert derivative_sigmoid(np.array([1])) == [0.1966], \"test case failed: derivative_sigmoid(np.array([1]))\"\nassert derivative_sigmoid(np.array([-1])) == [0.1966], \"test case failed: derivative_sigmoid(np.array([-1]))\"\nassert derivative_sigmoid(np.array([2.0, -2.0])) == [0.105, 0.105], \"test case failed: derivative_sigmoid(np.array([2.0, -2.0]))\"\nassert derivative_sigmoid(np.array([5, -5])) == [0.0066, 0.0066], \"test case failed: derivative_sigmoid(np.array([5, -5]))\"\nassert derivative_sigmoid(np.array([10, -10])) == [0.0, 0.0], \"test case failed: derivative_sigmoid(np.array([10, -10]))\"\nassert derivative_sigmoid(np.array([[0, 1], [-1, -2]])) == [[0.25, 0.1966], [0.1966, 0.105]], \"test case failed: derivative_sigmoid(np.array([[0, 1], [-1, -2]]))\"\nassert derivative_sigmoid(np.array([3])) == [0.0452], \"test case failed: derivative_sigmoid(np.array([3]))\"\nassert derivative_sigmoid(np.array([-3])) == [0.0452], \"test case failed: derivative_sigmoid(np.array([-3]))\"\nassert derivative_sigmoid(np.array([0, 2, -2])) == [0.25, 0.105, 0.105], \"test case failed: derivative_sigmoid(np.array([0, 2, -2]))\""}
{"task_id": 541, "completion_id": 0, "passed": false, "result": "failed: unsupported operand type(s) for -: 'list' and 'list'", "solution": "import numpy as np\nimport numpy as np\ndef return_input_grads(y, y_hat):\n    gradient = y_hat - y\n    gradient_rounded = np.round(gradient, 4)\n    return gradient_rounded.tolist()\nassert return_input_grads([1, 0, 1], [0.8, 0.2, 0.6]) == [-0.2, 0.2, -0.4], \"test case failed: return_input_grads([1,0,1],[0.8,0.2,0.6])\"\nassert return_input_grads([0, 1], [0.1, 0.9]) == [0.1, -0.1], \"test case failed: return_input_grads([0,1],[0.1,0.9])\"\nassert return_input_grads([1, 1, 1], [0.99, 0.5, 0.01]) == [-0.01, -0.5, -0.99], \"test case failed: return_input_grads([1,1,1],[0.99,0.5,0.01])\"\nassert return_input_grads([[1, 0], [0, 1]], [[0.5, 0.5], [0.1, 0.9]]) == [[-0.5, 0.5], [0.1, -0.1]], \"test case failed: 2D example\"\nassert return_input_grads([1], [0.7]) == [-0.3], \"test case failed: single element (1)\"\nassert return_input_grads([0], [0.25]) == [0.25], \"test case failed: single element (0)\"\nassert return_input_grads([[1, 1], [1, 1]], [[1, 1], [1, 1]]) == [[0.0, 0.0], [0.0, 0.0]], \"test case failed: perfect predictions\"\nassert return_input_grads([0, 0, 0], [0.3, 0.4, 0.9]) == [0.3, 0.4, 0.9], \"test case failed: all zeros labels\"\nassert return_input_grads([1, 0, 1, 0], [0, 1, 0, 1]) == [-1.0, 1.0, -1.0, 1.0], \"test case failed: extreme predictions\"\nassert return_input_grads([1, 0, 0, 1, 1], [0.2, 0.2, 0.8, 0.8, 0.5]) == [-0.8, 0.2, 0.8, -0.2, -0.5], \"test case failed: mixed batch\""}
{"task_id": 543, "completion_id": 0, "passed": false, "result": "failed: failed on ['A','B','B','B','C']", "solution": "from collections import Counter\nfrom collections import Counter\ndef cal_gini_index(data: list) -> float:\n    if not data:\n        return\nassert cal_gini_index([\"A\", \"B\", \"B\", \"B\", \"C\"]) == 0.56, \"failed on ['A','B','B','B','C']\"\nassert cal_gini_index([1, 1, 1, 1]) == 0.0, \"failed on [1,1,1,1]\"\nassert cal_gini_index([\"yes\", \"no\"]) == 0.5, \"failed on ['yes','no']\"\nassert cal_gini_index([]) == 0.0, \"failed on []\"\nassert cal_gini_index([\"a\", \"b\", \"c\", \"d\"]) == 0.75, \"failed on ['a','b','c','d']\"\nassert cal_gini_index([0, 0, 0, 1, 1]) == 0.48, \"failed on [0,0,0,1,1]\"\nassert cal_gini_index([1]) == 0.0, \"failed on [1]\"\nassert cal_gini_index(list(range(10))) == 0.9, \"failed on range(10)\"\nassert cal_gini_index([1, 2, 3]) == 0.6667, \"failed on [1,2,3]\"\nassert cal_gini_index([1, 1, 2, 2, 3, 3]) == 0.6667, \"failed on [1,1,2,2,3,3]\""}
{"task_id": 544, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef split_tree(data: list, fea: int, value: float):\n    set1 = []\n    set2 = []\n    for (i, s) in enumerate(data):\n        if s[fea] >= value:\n            set1.append(s)\n        else:\n            set2.append(s)\n    return (set1, set2)\nassert split_tree([[5, 2], [3, 4], [7, 1], [2, 2]], 0, 4) == ([[5, 2], [7, 1]], [[3, 4], [2, 2]]), \"test case failed: basic example\"\nassert split_tree([[1], [2], [3]], 0, 5) == ([], [[1], [2], [3]]), \"test case failed: threshold larger than all samples\"\nassert split_tree([[10], [12], [20]], 0, 5) == ([[10], [12], [20]], []), \"test case failed: threshold smaller than all samples\"\nassert split_tree([[1, 5], [2, 3], [3, 7], [4, 1]], 1, 4) == ([[1, 5], [3, 7]], [[2, 3], [4, 1]]), \"test case failed: second feature split\"\nassert split_tree([[1.5, 2.2], [2.3, 3.9], [1.0, 4.1]], 1, 3.0) == ([[2.3, 3.9], [1.0, 4.1]], [[1.5, 2.2]]), \"test case failed: float values\"\nassert split_tree([[-3], [-1], [2]], 0, 0) == ([[2]], [[-3], [-1]]), \"test case failed: negative threshold\"\nassert split_tree([[4], [4], [4]], 0, 4) == ([[4], [4], [4]], []), \"test case failed: all equal to threshold\"\nassert split_tree([[1], [2], [2], [3]], 0, 2) == ([[2], [2], [3]], [[1]]), \"test case failed: duplicates with equality\"\nassert split_tree([[6, 1]], 0, 6) == ([[6, 1]], []), \"test case failed: single sample\"\nassert split_tree([], 0, 0) == ([], []), \"test case failed: empty data set\""}
{"task_id": 559, "completion_id": 0, "passed": false, "result": "failed: name 'leaf_values' is not defined", "solution": "from typing import List, Optional\n\nassert leaf_values(None) == [], \"failed on empty tree\"\nassert leaf_values(Node(val=5)) == [5], \"failed on single-node tree\"\nroot = Node(left=Node(val=1), right=Node(left=Node(val=2), right=Node(val=3)))\nassert leaf_values(root) == [1, 2, 3], \"failed on complete tree\"\nroot = Node(left=Node(left=Node(val=42)))\nassert leaf_values(root) == [42], \"failed on left-skewed tree\"\nroot = Node(right=Node(right=Node(val=7)))\nassert leaf_values(root) == [7], \"failed on right-skewed tree\"\nroot = Node(left=Node(val=10), right=Node(left=Node(val=20), right=Node(right=Node(val=30))))\nassert leaf_values(root) == [10, 20, 30], \"failed on mixed structure 1\"\nroot = Node(val=None, left=Node(val=None, left=Node(val=1), right=Node(val=2)), right=Node(val=None, left=Node(val=3)))\nassert leaf_values(root) == [1, 2, 3], \"failed when internal nodes hold values\"\nleft_sub = Node(left=Node(val=4), right=Node(val=5))\nright_sub = Node(left=Node(val=6), right=Node(val=7))\nroot = Node(left=left_sub, right=right_sub)\nassert leaf_values(root) == [4, 5, 6, 7], \"failed on large balanced tree\"\nroot = Node(left=Node(val=1), right=Node(val=1))\nassert leaf_values(root) == [1, 1], \"failed on repeating leaf values\"\nroot = Node(left=Node(right=Node(left=Node(right=Node(val=99)))))\nassert leaf_values(root) == [99], \"failed on deep alternating tree\""}
{"task_id": 578, "completion_id": 0, "passed": true, "result": "passed", "solution": "from typing import List, Tuple\nfrom typing import List, Tuple\ndef make_pairs(corpus: list) -> list[tuple]:\n    if len(corpus) < 2:\n        return []\n    result = []\n    for i in range(len(corpus) - 1):\n        result.append((corpus[i], corpus[i + 1]))\n    return result\nassert make_pairs([1, 2, 3, 4]) == [(1, 2), (2, 3), (3, 4)], \"test case failed: make_pairs([1, 2, 3, 4])\"\nassert make_pairs([\"hello\", \"world\"]) == [(\"hello\", \"world\")], \"test case failed: make_pairs(['hello', 'world'])\"\nassert make_pairs([]) == [], \"test case failed: make_pairs([])\"\nassert make_pairs([42]) == [], \"test case failed: make_pairs([42])\"\nassert make_pairs([\"a\", \"a\", \"b\"]) == [(\"a\", \"a\"), (\"a\", \"b\")], \"test case failed: make_pairs(['a','a','b'])\"\nassert make_pairs(list(\"abc\")) == [(\"a\", \"b\"), (\"b\", \"c\")], \"test case failed: make_pairs(list('abc'))\"\nassert make_pairs([True, False, True]) == [(True, False), (False, True)], \"test case failed: make_pairs([True, False, True])\"\nassert make_pairs([0.1, 0.2, 0.3]) == [(0.1, 0.2), (0.2, 0.3)], \"test case failed: make_pairs([0.1, 0.2, 0.3])\"\nassert make_pairs([\"x\", 1, 2.5]) == [(\"x\", 1), (1, 2.5)], \"test case failed: make_pairs(['x', 1, 2.5])\"\nassert make_pairs([None, None, None]) == [(None, None), (None, None)], \"test case failed: make_pairs([None, None, None])\""}
{"task_id": 585, "completion_id": 0, "passed": true, "result": "passed", "solution": "\ndef cmp(a, b):\n    if a > b:\n        return 1\n    elif a < b:\n        return -1\n    else:\n        return 0\nassert cmp(5, 3) == 1, \"test case failed: cmp(5, 3)\"\nassert cmp(3, 5) == -1, \"test case failed: cmp(3, 5)\"\nassert cmp(7, 7) == 0, \"test case failed: cmp(7, 7)\"\nassert cmp(-1, -5) == 1, \"test case failed: cmp(-1, -5)\"\nassert cmp(-10, -2) == -1, \"test case failed: cmp(-10, -2)\"\nassert cmp(3.14, 3.14) == 0, \"test case failed: cmp(3.14, 3.14)\"\nassert cmp(\"apple\", \"banana\") == -1, \"test case failed: cmp('apple', 'banana')\"\nassert cmp(\"zebra\", \"alpha\") == 1, \"test case failed: cmp('zebra', 'alpha')\"\nassert cmp([1, 2], [1, 2]) == 0, \"test case failed: cmp([1, 2], [1, 2])\"\nassert cmp((1, 3), (1, 2)) == 1, \"test case failed: cmp((1, 3), (1, 2))\""}
{"task_id": 588, "completion_id": 0, "passed": true, "result": "passed", "solution": "from typing import Optional\nfrom typing import Optional\nfrom typing import Optional\nclass Node:\n    \"\"\"A simple binary tree node.\"\"\"\n\n    def __init__(self, data=None, split_variable=None, split_variable_value=None, left: Optional['Node']=None, right: Optional['Node']=None, depth: int=0, criterion_value=None):\n        self.data = data\n        self.split_variable = split_variable\n        self.split_variable_value = split_variable_value\n        self.left = left\n        self.right = right\n        self.depth = depth\n        self.criterion_value = criterion_value\ndef tree_max_depth(root: Optional[Node]) -> int:\n    \"\"\"Computes the maximum depth of a binary tree.\n\n    The depth of the root node is defined to be 0.  The depth of an empty\n    tree is defined to be -1.\n\n    Args:\n        root: The root of the binary tree (Node or None).\n\n    Returns:\n        The maximum depth as an integer.\n    \"\"\"\n    if root is None:\n        return -1\n    else:\n        left_depth = tree_max_depth(root.left)\n        right_depth = tree_max_depth(root.right)\n        return 1 + max(left_depth, right_depth)\nassert tree_max_depth(None) == -1, \"test case failed: tree_max_depth(None)\"\nsingle = Node(1)\nassert tree_max_depth(single) == 0, \"test case failed: single node depth\"\nroot2 = Node(1)\nroot2.left = Node(2)\nroot2.right = Node(3)\nassert tree_max_depth(root2) == 1, \"test case failed: two-level balanced\"\nleft_skew = Node(0)\ncurrent = left_skew\nfor i in range(4):\n    current.left = Node(i)\n    current = current.left\nassert tree_max_depth(left_skew) == 4, \"test case failed: left-skewed depth 4\"\nright_skew = Node(0)\ncurrent = right_skew\nfor i in range(3):\n    current.right = Node(i)\n    current = current.right\nassert tree_max_depth(right_skew) == 3, \"test case failed: right-skewed depth 3\"\nroot3 = Node(10)\nroot3.left = Node(5)\nroot3.right = Node(20)\nroot3.left.left = Node(3)\nroot3.left.right = Node(7)\nroot3.right.left = Node(15)\nroot3.right.right = Node(25)\nassert tree_max_depth(root3) == 2, \"test case failed: balanced depth 2\"\nunbalanced1 = Node(1)\nunbalanced1.left = Node(2)\nunbalanced1.left.left = Node(3)\nunbalanced1.right = Node(4)\nassert tree_max_depth(unbalanced1) == 2, \"test case failed: unbalanced left deeper\"\nunbalanced2 = Node(1)\nunbalanced2.right = Node(2)\nunbalanced2.right.right = Node(3)\nunbalanced2.right.right.right = Node(4)\nassert tree_max_depth(unbalanced2) == 3, \"test case failed: unbalanced right deeper\"\ncomplex_root = Node(0)\ncomplex_root.left = Node(1)\ncomplex_root.right = Node(2)\ncomplex_root.left.right = Node(3)\ncomplex_root.left.right.left = Node(4)\ncomplex_root.right.left = Node(5)\nassert tree_max_depth(complex_root) == 3, \"test case failed: complex tree depth 3\"\nroot_one_child = Node(9)\nroot_one_child.right = Node(10)\nassert tree_max_depth(root_one_child) == 1, \"test case failed: root with one child\""}
