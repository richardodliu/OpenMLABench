{"task_id": 0, "completion_id": 0, "solution": ""}
{"task_id": 1, "completion_id": 0, "solution": ""}
{"task_id": 2, "completion_id": 0, "solution": ""}
{"task_id": 3, "completion_id": 0, "solution": ""}
{"task_id": 7, "completion_id": 0, "solution": ""}
{"task_id": 11, "completion_id": 0, "solution": ""}
{"task_id": 13, "completion_id": 0, "solution": ""}
{"task_id": 19, "completion_id": 0, "solution": ""}
{"task_id": 20, "completion_id": 0, "solution": ""}
{"task_id": 21, "completion_id": 0, "solution": ""}
{"task_id": 25, "completion_id": 0, "solution": ""}
{"task_id": 28, "completion_id": 0, "solution": ""}
{"task_id": 29, "completion_id": 0, "solution": ""}
{"task_id": 34, "completion_id": 0, "solution": ""}
{"task_id": 39, "completion_id": 0, "solution": ""}
{"task_id": 40, "completion_id": 0, "solution": ""}
{"task_id": 48, "completion_id": 0, "solution": ""}
{"task_id": 55, "completion_id": 0, "solution": ""}
{"task_id": 56, "completion_id": 0, "solution": ""}
{"task_id": 58, "completion_id": 0, "solution": ""}
{"task_id": 62, "completion_id": 0, "solution": ""}
{"task_id": 63, "completion_id": 0, "solution": ""}
{"task_id": 65, "completion_id": 0, "solution": ""}
{"task_id": 69, "completion_id": 0, "solution": ""}
{"task_id": 70, "completion_id": 0, "solution": ""}
{"task_id": 75, "completion_id": 0, "solution": ""}
{"task_id": 76, "completion_id": 0, "solution": ""}
{"task_id": 77, "completion_id": 0, "solution": ""}
{"task_id": 81, "completion_id": 0, "solution": ""}
{"task_id": 82, "completion_id": 0, "solution": ""}
{"task_id": 86, "completion_id": 0, "solution": ""}
{"task_id": 88, "completion_id": 0, "solution": ""}
{"task_id": 90, "completion_id": 0, "solution": ""}
{"task_id": 96, "completion_id": 0, "solution": ""}
{"task_id": 108, "completion_id": 0, "solution": ""}
{"task_id": 109, "completion_id": 0, "solution": ""}
{"task_id": 111, "completion_id": 0, "solution": ""}
{"task_id": 113, "completion_id": 0, "solution": ""}
{"task_id": 115, "completion_id": 0, "solution": ""}
{"task_id": 118, "completion_id": 0, "solution": ""}
{"task_id": 128, "completion_id": 0, "solution": ""}
{"task_id": 140, "completion_id": 0, "solution": ""}
{"task_id": 141, "completion_id": 0, "solution": ""}
{"task_id": 146, "completion_id": 0, "solution": ""}
{"task_id": 155, "completion_id": 0, "solution": ""}
{"task_id": 160, "completion_id": 0, "solution": "import numpy as np\ndef fit_lasso(X: np.ndarray, y: np.ndarray, lambda_param: float=1.0, max_iters: int=100, fit_intercept: bool=True) -> tuple[list[float], float]:\n    \"\"\"Fit Lasso (L1-regularised) linear regression using coordinate descent.\n\n    The function should learn a weight vector and optional intercept that\n    minimise squared loss + \u03bb\\u2006\u00b7\\u2006L1-norm.  **Do not** use scikit-learn; rely\n    solely on NumPy and the algorithm described in the task description.\n\n    Args:\n        X:   2-D array of shape (m, n) \u2013 feature matrix.\n        y:   1-D array of length m \u2013 target values.\n        lambda_param: Regularisation strength \u03bb (non-negative).\n        max_iters: Number of full passes over the coordinates.\n        fit_intercept: Whether to fit an intercept term.\n\n    Returns:\n        Tuple (weights, bias) where `weights` is a list of length n and `bias`\n        is a float.  Round all returned numbers to 4 decimal places.\n    \"\"\"\n    (m, n) = X.shape\n    if fit_intercept:\n        X = np.hstack([np.ones((m, 1)), X])\n    else:\n        X = np.hstack([np.zeros((m, 1)), X])\n    w = np.zeros(n + 1)\n    sum_sq = np.sum(X ** 2, axis=0)\n    for _ in range(max_iters):\n        if fit_intercept:\n            w[0] = np.mean(y - X[:, 1:] @ w[1:])\n        for j in range(1, n + 1):\n            old_wj = w[j]\n            w[j] = 0\n            r_j = y - X @ w\n            w[j] = np.sign(np.dot(X[:, j], r_j)) * max(abs(np.dot(X[:, j], r_j)) - lambda_param * m, 0) / sum_sq[j]\n    bias = round(w[0], 4) if fit_intercept else 0.0\n    weights = [round(weight, 4) for weight in w[1:]]\n    return (weights, bias)"}
{"task_id": 165, "completion_id": 0, "solution": ""}
{"task_id": 169, "completion_id": 0, "solution": ""}
{"task_id": 171, "completion_id": 0, "solution": ""}
{"task_id": 176, "completion_id": 0, "solution": ""}
{"task_id": 178, "completion_id": 0, "solution": ""}
{"task_id": 180, "completion_id": 0, "solution": ""}
{"task_id": 184, "completion_id": 0, "solution": ""}
{"task_id": 190, "completion_id": 0, "solution": ""}
{"task_id": 191, "completion_id": 0, "solution": ""}
{"task_id": 197, "completion_id": 0, "solution": ""}
{"task_id": 198, "completion_id": 0, "solution": ""}
{"task_id": 202, "completion_id": 0, "solution": ""}
{"task_id": 216, "completion_id": 0, "solution": ""}
{"task_id": 217, "completion_id": 0, "solution": ""}
{"task_id": 218, "completion_id": 0, "solution": ""}
{"task_id": 221, "completion_id": 0, "solution": ""}
{"task_id": 222, "completion_id": 0, "solution": ""}
{"task_id": 224, "completion_id": 0, "solution": ""}
{"task_id": 226, "completion_id": 0, "solution": ""}
{"task_id": 241, "completion_id": 0, "solution": ""}
{"task_id": 243, "completion_id": 0, "solution": ""}
{"task_id": 249, "completion_id": 0, "solution": ""}
{"task_id": 253, "completion_id": 0, "solution": ""}
{"task_id": 256, "completion_id": 0, "solution": ""}
{"task_id": 257, "completion_id": 0, "solution": ""}
{"task_id": 261, "completion_id": 0, "solution": ""}
{"task_id": 266, "completion_id": 0, "solution": ""}
{"task_id": 267, "completion_id": 0, "solution": ""}
{"task_id": 273, "completion_id": 0, "solution": ""}
{"task_id": 286, "completion_id": 0, "solution": ""}
{"task_id": 287, "completion_id": 0, "solution": ""}
{"task_id": 290, "completion_id": 0, "solution": ""}
{"task_id": 292, "completion_id": 0, "solution": ""}
{"task_id": 294, "completion_id": 0, "solution": ""}
{"task_id": 296, "completion_id": 0, "solution": ""}
{"task_id": 298, "completion_id": 0, "solution": ""}
{"task_id": 302, "completion_id": 0, "solution": ""}
{"task_id": 303, "completion_id": 0, "solution": ""}
{"task_id": 304, "completion_id": 0, "solution": ""}
{"task_id": 308, "completion_id": 0, "solution": ""}
{"task_id": 312, "completion_id": 0, "solution": ""}
{"task_id": 313, "completion_id": 0, "solution": ""}
{"task_id": 317, "completion_id": 0, "solution": ""}
{"task_id": 318, "completion_id": 0, "solution": ""}
{"task_id": 329, "completion_id": 0, "solution": ""}
{"task_id": 331, "completion_id": 0, "solution": ""}
{"task_id": 332, "completion_id": 0, "solution": ""}
{"task_id": 336, "completion_id": 0, "solution": ""}
{"task_id": 340, "completion_id": 0, "solution": ""}
{"task_id": 343, "completion_id": 0, "solution": ""}
{"task_id": 353, "completion_id": 0, "solution": ""}
{"task_id": 354, "completion_id": 0, "solution": "import numpy as np\ndef conv2D(X: 'np.ndarray', W: 'np.ndarray', stride: int, pad, dilation: int=0):\n    \"\"\"Performs a 2-D convolution (cross-correlation).\n\n    Args:\n        X: NumPy array of shape ``(n_ex, in_rows, in_cols, in_ch)`` representing the input batch.\n        W: NumPy array of shape ``(kernel_rows, kernel_cols, in_ch, out_ch)`` containing the kernels.\n        stride: Stride of the convolution.\n        pad: Padding specification \u2013 integer, tuple or the string ``'same'``.\n        dilation: Optional dilation factor. ``0`` corresponds to a normal convolution.\n\n    Returns:\n        The convolution result **as a Python list** obtained through ``numpy.ndarray.tolist()``.\n    \"\"\"\n    (n_ex, in_rows, in_cols, in_ch) = X.shape\n    (kernel_rows, kernel_cols, _, out_ch) = W.shape\n    if isinstance(pad, int):\n        pad = (pad, pad, pad, pad)\n    elif isinstance(pad, tuple) and len(pad) == 2:\n        (pr, pc) = pad\n        pad = (pr, pr, pc, pc)\n    elif isinstance(pad, tuple) and len(pad) == 4:\n        (pr1, pr2, pc1, pc2) = pad\n        pad = (pr1, pr2, pc1, pc2)\n    elif pad == 'same':\n        pr1 = (out_rows - 1) * stride + kernel_rows - in_rows\n        pc1 = (out_cols - 1) * stride + kernel_cols - in_cols\n        pr2 = pr1 + (1 if pr1 % 2 else 0)\n        pc2 = pc1 + (1 if pc1 % 2 else 0)\n        pad = (pr1 // 2, pr2 // 2, pc1 // 2, pc2 // 2)\n    out_rows = in_rows + pad[0] + pad[1] - (kernel_rows + (kernel_rows - 1) * dilation) // stride + 1\n    out_cols = in_cols + pad[2] + pad[3] - (kernel_cols + (kernel_cols - 1) * dilation) // stride + 1\n    X_padded = np.pad(X, ((0, 0), (pad[0], pad[1]), (pad[2], pad[3]), (0, 0)), mode='constant', constant_values=0)\n    (H_f, W_f, _, _) = W.shape\n    H_out = (X_padded.shape[1] - (H_f - 1) * dilation - 1) // stride + 1\n    W_out = (X_padded.shape[2] - (W_f - 1) * dilation - 1) // stride + 1\n    X_col = np.zeros((H_f * W_f * in_ch, H_out * W_out * n_ex))\n    for ex in range(n_ex):\n        col_idx = 0\n        for i in range(0, X_padded.shape[1] - (H_f - 1) * dilation - 1 + 1, stride):\n            for j in range(0, X_padded.shape[2] - (W_f - 1) * dilation - 1 + 1, stride):\n                x_col_vec = X_padded[ex, i:i + H_f * dilation + 1:dilation, j:j + W_f * dilation + 1:dilation, :].flatten()\n                X_col[:, col_idx] = x_col_vec\n                col_idx += 1\n    W_col = W.reshape(H_f * W_f * in_ch, out_ch)\n    out_col = W_col.T @ X_col\n    out = out_col.reshape(out_ch, out_rows, out_cols, n_ex).transpose(3, 1, 2, 0)\n    return out.tolist()"}
{"task_id": 355, "completion_id": 0, "solution": ""}
{"task_id": 356, "completion_id": 0, "solution": "def leaf_predict(leaf: 'Leaf', classifier: bool):\n    \"\"\"Return the prediction stored in a decision-tree leaf.\n\n    Args:\n        leaf: A `Leaf` object whose `value` attribute is either a sequence of\n              class probabilities (classification) or a single number\n              (regression).\n        classifier: When *True* treat the leaf as belonging to a\n                     classification tree; otherwise treat it as regression.\n\n    Returns:\n        int | float: Predicted class index for classification; otherwise the\n                     raw scalar stored in the leaf.\n    \"\"\"\n    if classifier:\n        return leaf.value.index(max(leaf.value))\n    else:\n        return leaf.value"}
{"task_id": 357, "completion_id": 0, "solution": ""}
{"task_id": 362, "completion_id": 0, "solution": ""}
{"task_id": 363, "completion_id": 0, "solution": ""}
{"task_id": 369, "completion_id": 0, "solution": ""}
{"task_id": 371, "completion_id": 0, "solution": ""}
{"task_id": 373, "completion_id": 0, "solution": ""}
{"task_id": 374, "completion_id": 0, "solution": ""}
{"task_id": 376, "completion_id": 0, "solution": ""}
{"task_id": 377, "completion_id": 0, "solution": ""}
{"task_id": 380, "completion_id": 0, "solution": ""}
{"task_id": 387, "completion_id": 0, "solution": ""}
{"task_id": 394, "completion_id": 0, "solution": ""}
{"task_id": 398, "completion_id": 0, "solution": ""}
{"task_id": 411, "completion_id": 0, "solution": ""}
{"task_id": 413, "completion_id": 0, "solution": ""}
{"task_id": 416, "completion_id": 0, "solution": ""}
{"task_id": 419, "completion_id": 0, "solution": ""}
{"task_id": 423, "completion_id": 0, "solution": ""}
{"task_id": 428, "completion_id": 0, "solution": ""}
{"task_id": 433, "completion_id": 0, "solution": ""}
{"task_id": 435, "completion_id": 0, "solution": ""}
{"task_id": 437, "completion_id": 0, "solution": ""}
{"task_id": 438, "completion_id": 0, "solution": ""}
{"task_id": 439, "completion_id": 0, "solution": ""}
{"task_id": 440, "completion_id": 0, "solution": ""}
{"task_id": 444, "completion_id": 0, "solution": ""}
{"task_id": 446, "completion_id": 0, "solution": ""}
{"task_id": 452, "completion_id": 0, "solution": ""}
{"task_id": 453, "completion_id": 0, "solution": ""}
{"task_id": 458, "completion_id": 0, "solution": ""}
{"task_id": 461, "completion_id": 0, "solution": ""}
{"task_id": 471, "completion_id": 0, "solution": ""}
{"task_id": 474, "completion_id": 0, "solution": ""}
{"task_id": 475, "completion_id": 0, "solution": ""}
{"task_id": 479, "completion_id": 0, "solution": ""}
{"task_id": 481, "completion_id": 0, "solution": ""}
{"task_id": 482, "completion_id": 0, "solution": ""}
{"task_id": 485, "completion_id": 0, "solution": ""}
{"task_id": 490, "completion_id": 0, "solution": ""}
{"task_id": 491, "completion_id": 0, "solution": ""}
{"task_id": 492, "completion_id": 0, "solution": ""}
{"task_id": 493, "completion_id": 0, "solution": ""}
{"task_id": 496, "completion_id": 0, "solution": ""}
{"task_id": 499, "completion_id": 0, "solution": ""}
{"task_id": 500, "completion_id": 0, "solution": ""}
{"task_id": 505, "completion_id": 0, "solution": ""}
{"task_id": 509, "completion_id": 0, "solution": ""}
{"task_id": 510, "completion_id": 0, "solution": ""}
{"task_id": 513, "completion_id": 0, "solution": ""}
{"task_id": 517, "completion_id": 0, "solution": ""}
{"task_id": 518, "completion_id": 0, "solution": ""}
{"task_id": 520, "completion_id": 0, "solution": ""}
{"task_id": 528, "completion_id": 0, "solution": ""}
{"task_id": 537, "completion_id": 0, "solution": ""}
{"task_id": 539, "completion_id": 0, "solution": ""}
{"task_id": 552, "completion_id": 0, "solution": ""}
{"task_id": 555, "completion_id": 0, "solution": ""}
{"task_id": 561, "completion_id": 0, "solution": ""}
{"task_id": 562, "completion_id": 0, "solution": ""}
{"task_id": 563, "completion_id": 0, "solution": ""}
{"task_id": 564, "completion_id": 0, "solution": ""}
{"task_id": 565, "completion_id": 0, "solution": ""}
{"task_id": 566, "completion_id": 0, "solution": ""}
{"task_id": 568, "completion_id": 0, "solution": ""}
{"task_id": 569, "completion_id": 0, "solution": ""}
{"task_id": 571, "completion_id": 0, "solution": ""}
{"task_id": 572, "completion_id": 0, "solution": ""}
{"task_id": 574, "completion_id": 0, "solution": ""}
{"task_id": 579, "completion_id": 0, "solution": ""}
{"task_id": 581, "completion_id": 0, "solution": ""}
{"task_id": 591, "completion_id": 0, "solution": ""}
{"task_id": 595, "completion_id": 0, "solution": ""}
