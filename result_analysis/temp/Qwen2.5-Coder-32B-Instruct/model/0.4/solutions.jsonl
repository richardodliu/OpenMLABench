{"task_id": 0, "completion_id": 0, "solution": ""}
{"task_id": 1, "completion_id": 0, "solution": ""}
{"task_id": 2, "completion_id": 0, "solution": ""}
{"task_id": 3, "completion_id": 0, "solution": ""}
{"task_id": 7, "completion_id": 0, "solution": ""}
{"task_id": 11, "completion_id": 0, "solution": ""}
{"task_id": 13, "completion_id": 0, "solution": ""}
{"task_id": 19, "completion_id": 0, "solution": ""}
{"task_id": 20, "completion_id": 0, "solution": ""}
{"task_id": 21, "completion_id": 0, "solution": ""}
{"task_id": 25, "completion_id": 0, "solution": ""}
{"task_id": 28, "completion_id": 0, "solution": ""}
{"task_id": 29, "completion_id": 0, "solution": ""}
{"task_id": 34, "completion_id": 0, "solution": ""}
{"task_id": 39, "completion_id": 0, "solution": ""}
{"task_id": 40, "completion_id": 0, "solution": ""}
{"task_id": 48, "completion_id": 0, "solution": ""}
{"task_id": 55, "completion_id": 0, "solution": ""}
{"task_id": 56, "completion_id": 0, "solution": ""}
{"task_id": 58, "completion_id": 0, "solution": ""}
{"task_id": 62, "completion_id": 0, "solution": ""}
{"task_id": 63, "completion_id": 0, "solution": ""}
{"task_id": 65, "completion_id": 0, "solution": ""}
{"task_id": 69, "completion_id": 0, "solution": ""}
{"task_id": 70, "completion_id": 0, "solution": ""}
{"task_id": 75, "completion_id": 0, "solution": ""}
{"task_id": 76, "completion_id": 0, "solution": ""}
{"task_id": 77, "completion_id": 0, "solution": ""}
{"task_id": 81, "completion_id": 0, "solution": ""}
{"task_id": 82, "completion_id": 0, "solution": ""}
{"task_id": 86, "completion_id": 0, "solution": ""}
{"task_id": 88, "completion_id": 0, "solution": ""}
{"task_id": 90, "completion_id": 0, "solution": ""}
{"task_id": 96, "completion_id": 0, "solution": ""}
{"task_id": 108, "completion_id": 0, "solution": ""}
{"task_id": 109, "completion_id": 0, "solution": ""}
{"task_id": 111, "completion_id": 0, "solution": ""}
{"task_id": 113, "completion_id": 0, "solution": ""}
{"task_id": 115, "completion_id": 0, "solution": ""}
{"task_id": 118, "completion_id": 0, "solution": ""}
{"task_id": 128, "completion_id": 0, "solution": ""}
{"task_id": 140, "completion_id": 0, "solution": ""}
{"task_id": 141, "completion_id": 0, "solution": ""}
{"task_id": 146, "completion_id": 0, "solution": ""}
{"task_id": 155, "completion_id": 0, "solution": ""}
{"task_id": 160, "completion_id": 0, "solution": ""}
{"task_id": 165, "completion_id": 0, "solution": ""}
{"task_id": 169, "completion_id": 0, "solution": ""}
{"task_id": 171, "completion_id": 0, "solution": ""}
{"task_id": 176, "completion_id": 0, "solution": ""}
{"task_id": 178, "completion_id": 0, "solution": ""}
{"task_id": 180, "completion_id": 0, "solution": ""}
{"task_id": 184, "completion_id": 0, "solution": ""}
{"task_id": 190, "completion_id": 0, "solution": ""}
{"task_id": 191, "completion_id": 0, "solution": ""}
{"task_id": 197, "completion_id": 0, "solution": ""}
{"task_id": 198, "completion_id": 0, "solution": ""}
{"task_id": 202, "completion_id": 0, "solution": ""}
{"task_id": 216, "completion_id": 0, "solution": ""}
{"task_id": 217, "completion_id": 0, "solution": ""}
{"task_id": 218, "completion_id": 0, "solution": ""}
{"task_id": 221, "completion_id": 0, "solution": ""}
{"task_id": 222, "completion_id": 0, "solution": ""}
{"task_id": 224, "completion_id": 0, "solution": ""}
{"task_id": 226, "completion_id": 0, "solution": ""}
{"task_id": 241, "completion_id": 0, "solution": ""}
{"task_id": 243, "completion_id": 0, "solution": ""}
{"task_id": 249, "completion_id": 0, "solution": ""}
{"task_id": 253, "completion_id": 0, "solution": ""}
{"task_id": 256, "completion_id": 0, "solution": ""}
{"task_id": 257, "completion_id": 0, "solution": ""}
{"task_id": 261, "completion_id": 0, "solution": ""}
{"task_id": 266, "completion_id": 0, "solution": ""}
{"task_id": 267, "completion_id": 0, "solution": ""}
{"task_id": 273, "completion_id": 0, "solution": ""}
{"task_id": 286, "completion_id": 0, "solution": ""}
{"task_id": 287, "completion_id": 0, "solution": ""}
{"task_id": 290, "completion_id": 0, "solution": ""}
{"task_id": 292, "completion_id": 0, "solution": ""}
{"task_id": 294, "completion_id": 0, "solution": ""}
{"task_id": 296, "completion_id": 0, "solution": ""}
{"task_id": 298, "completion_id": 0, "solution": ""}
{"task_id": 302, "completion_id": 0, "solution": ""}
{"task_id": 303, "completion_id": 0, "solution": ""}
{"task_id": 304, "completion_id": 0, "solution": ""}
{"task_id": 308, "completion_id": 0, "solution": ""}
{"task_id": 312, "completion_id": 0, "solution": ""}
{"task_id": 313, "completion_id": 0, "solution": ""}
{"task_id": 317, "completion_id": 0, "solution": ""}
{"task_id": 318, "completion_id": 0, "solution": ""}
{"task_id": 329, "completion_id": 0, "solution": ""}
{"task_id": 331, "completion_id": 0, "solution": ""}
{"task_id": 332, "completion_id": 0, "solution": ""}
{"task_id": 336, "completion_id": 0, "solution": ""}
{"task_id": 340, "completion_id": 0, "solution": ""}
{"task_id": 343, "completion_id": 0, "solution": ""}
{"task_id": 353, "completion_id": 0, "solution": ""}
{"task_id": 354, "completion_id": 0, "solution": "import numpy as np\ndef conv2D(X: 'np.ndarray', W: 'np.ndarray', stride: int, pad, dilation: int=0):\n    \"\"\"Performs a 2-D convolution (cross-correlation).\n\n    Args:\n        X: NumPy array of shape ``(n_ex, in_rows, in_cols, in_ch)`` representing the input batch.\n        W: NumPy array of shape ``(kernel_rows, kernel_cols, in_ch, out_ch)`` containing the kernels.\n        stride: Stride of the convolution.\n        pad: Padding specification \u2013 integer, tuple or the string ``'same'``.\n        dilation: Optional dilation factor. ``0`` corresponds to a normal convolution.\n\n    Returns:\n        The convolution result **as a Python list** obtained through ``numpy.ndarray.tolist()``.\n    \"\"\"\n    (n_ex, in_rows, in_cols, in_ch) = X.shape\n    (kernel_rows, kernel_cols, _, out_ch) = W.shape\n    if isinstance(pad, int):\n        pad = (pad, pad, pad, pad)\n    elif isinstance(pad, tuple) and len(pad) == 2:\n        pad = (pad[0], pad[0], pad[1], pad[1])\n    elif isinstance(pad, tuple) and len(pad) == 4:\n        pass\n    elif pad == 'same':\n        pr1 = (kernel_rows - 1) * dilation // 2\n        pr2 = (kernel_rows - 1) * dilation // 2\n        pc1 = (kernel_cols - 1) * dilation // 2\n        pc2 = (kernel_cols - 1) * dilation // 2\n        pad = (pr1, pr2, pc1, pc2)\n    else:\n        return []\n    X_padded = np.pad(X, ((0, 0), (pad[0], pad[1]), (pad[2], pad[3]), (0, 0)), mode='constant')\n    out_rows = (in_rows + pad[0] + pad[1] - (kernel_rows - 1) * dilation - 1) // stride + 1\n    out_cols = (in_cols + pad[2] + pad[3] - (kernel_cols - 1) * dilation - 1) // stride + 1\n    X_col = np.zeros((kernel_rows * kernel_cols * in_ch, out_rows * out_cols * n_ex))\n    for ex in range(n_ex):\n        for row in range(out_rows):\n            for col in range(out_cols):\n                r_start = row * stride\n                c_start = col * stride\n                r_end = r_start + kernel_rows * (dilation + 1) - dilation\n                c_end = c_start + kernel_cols * (dilation + 1) - dilation\n                X_col[:, row * out_cols * n_ex + col * n_ex + ex] = X_padded[ex, r_start:r_end:dilation, c_start:c_end:dilation, :].flatten()\n    W_col = W.reshape(kernel_rows * kernel_cols * in_ch, out_ch)\n    out_col = W_col.T @ X_col\n    out = out_col.reshape(out_ch, out_rows, out_cols, n_ex).transpose(3, 1, 2, 0)\n    return out.tolist()"}
{"task_id": 355, "completion_id": 0, "solution": ""}
{"task_id": 356, "completion_id": 0, "solution": ""}
{"task_id": 357, "completion_id": 0, "solution": ""}
{"task_id": 362, "completion_id": 0, "solution": ""}
{"task_id": 363, "completion_id": 0, "solution": ""}
{"task_id": 369, "completion_id": 0, "solution": ""}
{"task_id": 371, "completion_id": 0, "solution": ""}
{"task_id": 373, "completion_id": 0, "solution": ""}
{"task_id": 374, "completion_id": 0, "solution": ""}
{"task_id": 376, "completion_id": 0, "solution": ""}
{"task_id": 377, "completion_id": 0, "solution": ""}
{"task_id": 380, "completion_id": 0, "solution": ""}
{"task_id": 387, "completion_id": 0, "solution": ""}
{"task_id": 394, "completion_id": 0, "solution": ""}
{"task_id": 398, "completion_id": 0, "solution": ""}
{"task_id": 411, "completion_id": 0, "solution": ""}
{"task_id": 413, "completion_id": 0, "solution": ""}
{"task_id": 416, "completion_id": 0, "solution": ""}
{"task_id": 419, "completion_id": 0, "solution": ""}
{"task_id": 423, "completion_id": 0, "solution": ""}
{"task_id": 428, "completion_id": 0, "solution": ""}
{"task_id": 433, "completion_id": 0, "solution": ""}
{"task_id": 435, "completion_id": 0, "solution": ""}
{"task_id": 437, "completion_id": 0, "solution": ""}
{"task_id": 438, "completion_id": 0, "solution": ""}
{"task_id": 439, "completion_id": 0, "solution": ""}
{"task_id": 440, "completion_id": 0, "solution": ""}
{"task_id": 444, "completion_id": 0, "solution": ""}
{"task_id": 446, "completion_id": 0, "solution": ""}
{"task_id": 452, "completion_id": 0, "solution": ""}
{"task_id": 453, "completion_id": 0, "solution": ""}
{"task_id": 458, "completion_id": 0, "solution": ""}
{"task_id": 461, "completion_id": 0, "solution": ""}
{"task_id": 471, "completion_id": 0, "solution": ""}
{"task_id": 474, "completion_id": 0, "solution": ""}
{"task_id": 475, "completion_id": 0, "solution": ""}
{"task_id": 479, "completion_id": 0, "solution": ""}
{"task_id": 481, "completion_id": 0, "solution": ""}
{"task_id": 482, "completion_id": 0, "solution": ""}
{"task_id": 485, "completion_id": 0, "solution": ""}
{"task_id": 490, "completion_id": 0, "solution": ""}
{"task_id": 491, "completion_id": 0, "solution": ""}
{"task_id": 492, "completion_id": 0, "solution": ""}
{"task_id": 493, "completion_id": 0, "solution": ""}
{"task_id": 496, "completion_id": 0, "solution": ""}
{"task_id": 499, "completion_id": 0, "solution": ""}
{"task_id": 500, "completion_id": 0, "solution": ""}
{"task_id": 505, "completion_id": 0, "solution": ""}
{"task_id": 509, "completion_id": 0, "solution": ""}
{"task_id": 510, "completion_id": 0, "solution": ""}
{"task_id": 513, "completion_id": 0, "solution": ""}
{"task_id": 517, "completion_id": 0, "solution": ""}
{"task_id": 518, "completion_id": 0, "solution": ""}
{"task_id": 520, "completion_id": 0, "solution": ""}
{"task_id": 528, "completion_id": 0, "solution": ""}
{"task_id": 537, "completion_id": 0, "solution": ""}
{"task_id": 539, "completion_id": 0, "solution": ""}
{"task_id": 552, "completion_id": 0, "solution": ""}
{"task_id": 555, "completion_id": 0, "solution": ""}
{"task_id": 561, "completion_id": 0, "solution": ""}
{"task_id": 562, "completion_id": 0, "solution": ""}
{"task_id": 563, "completion_id": 0, "solution": ""}
{"task_id": 564, "completion_id": 0, "solution": ""}
{"task_id": 565, "completion_id": 0, "solution": ""}
{"task_id": 566, "completion_id": 0, "solution": ""}
{"task_id": 568, "completion_id": 0, "solution": "import math\nfrom collections import defaultdict\nimport numpy as np\ndef maxent_predict(X_train: np.ndarray, y_train: np.ndarray, X_test: np.ndarray, epsilon: float=0.001, n_iter: int=100) -> list[int]:\n    \"\"\"Predict labels for X_test using a Maximum Entropy classifier trained on X_train and y_train.\"\"\"\n    (n_samples, n_features) = X_train.shape\n    labels = set(y_train)\n    feature_value_counts = defaultdict(int)\n    feature_value_label_counts = defaultdict(int)\n    label_counts = defaultdict(int)\n    for (x, y) in zip(X_train, y_train):\n        label_counts[y] += 1\n        for (feature_index, feature_value) in enumerate(x):\n            feature_value_counts[feature_index, feature_value] += 1\n            feature_value_label_counts[feature_index, feature_value, y] += 1\n    empirical_pxy = defaultdict(float)\n    empirical_py = {y: count / n_samples for (y, count) in label_counts.items()}\n    for ((feature_index, feature_value, y), count) in feature_value_label_counts.items():\n        empirical_pxy[feature_index, feature_value, y] = count / n_samples\n    weights = defaultdict(float)\n    for iteration in range(n_iter):\n        expected_counts = defaultdict(float)\n        for (x, y) in zip(X_train, y_train):\n            Zx = sum((math.exp(sum((weights[feature_index, feature_value, y] for (feature_index, feature_value) in enumerate(x)))) for y in labels))\n            for (feature_index, feature_value) in enumerate(x):\n                expected_counts[feature_index, feature_value, y] += math.exp(sum((weights[feature_index, feature_value, y] for (feature_index, feature_value) in enumerate(x)))) / Zx\n        max_update = 0\n        for ((feature_index, feature_value, y), expected_count) in expected_counts.items():\n            empirical_count = feature_value_label_counts[feature_index, feature_value, y]\n            update = math.log(empirical_count / expected_count) if expected_count > 0 else 0\n            weights[feature_index, feature_value, y] += update\n            max_update = max(max_update, abs(update))\n        if max_update < epsilon:\n            break\n    predictions = []\n    for x in X_test:\n        max_prob = -float('inf')\n        predicted_label = None\n        for y in labels:\n            log_prob = sum((weights[feature_index, feature_value, y] for (feature_index, feature_value) in enumerate(x)))\n            if log_prob > max_prob:\n                max_prob = log_prob\n                predicted_label = y\n        predictions.append(predicted_label)\n    return predictions"}
{"task_id": 569, "completion_id": 0, "solution": ""}
{"task_id": 571, "completion_id": 0, "solution": ""}
{"task_id": 572, "completion_id": 0, "solution": ""}
{"task_id": 574, "completion_id": 0, "solution": ""}
{"task_id": 579, "completion_id": 0, "solution": ""}
{"task_id": 581, "completion_id": 0, "solution": ""}
{"task_id": 591, "completion_id": 0, "solution": ""}
{"task_id": 595, "completion_id": 0, "solution": ""}
