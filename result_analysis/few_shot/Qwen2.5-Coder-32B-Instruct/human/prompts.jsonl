{"task_id": 1, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Matrix-Vector Dot Product\n# Description:\nWrite a Python function that computes the dot product of a matrix and a vector. The function should return a list representing the resulting vector if the operation is valid, or -1 if the matrix and vector dimensions are incompatible. A matrix (a list of lists) can be dotted with a vector (a list) only if the number of columns in the matrix equals the length of the vector. For example, an n x m matrix requires a vector of length m.\n# Examples:\n## Example 1:\n### Input:\nmatrix_dot_vector(a = [[1, 2], [2, 4]], b = [1, 2])\n### Output:\n[5, 10]\n### Reasoning:\nRow 1: (1 * 1) + (2 * 2) = 1 + 4 = 5; Row 2: (1 * 2) + (2 * 4) = 2 + 8 = 10\n# Your code should start with:\n```python\ndef matrix_dot_vector(a: list[list[int|float]], b: list[int|float]) -> list[int|float]:\n```\n# Output Constraints:\nYour code should return a list where each element is the dot product of a row of 'a' with 'b'. If the number of columns in 'a' does not match the length of 'b', return -1.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 2, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Transpose of a Matrix\n# Description:\nWrite a Python function that computes the transpose of a given matrix.\n# Examples:\n## Example 1:\n### Input:\ntranspose_matrix(a = [[1,2,3],[4,5,6]])\n### Output:\n[[1,4],[2,5],[3,6]]\n### Reasoning:\nRow 1: (1 * 1) + (2 * 2) = 1 + 4 = 5; Row 2: (1 * 2) + (2 * 4) = 2 + 8 = 10\n# Your code should start with:\n```python\ndef transpose_matrix(a: list[list[int|float]]) -> list[list[int|float]]:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 3, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Reshape Matrix\n# Description:\nWrite a Python function that reshapes a given matrix into a specified shape. if it can not be reshaped return back an empty list \"[]\".\n# Examples:\n## Example 1:\n### Input:\nreshape_matrix(a = [[1,2,3,4],[5,6,7,8]], new_shape = (4, 2))\n### Output:\n[[1, 2], [3, 4], [5, 6], [7, 8]]\n### Reasoning:\nThe given matrix is reshaped from 2x4 to 4x2.\n# Your code should start with:\n```python\nimport numpy as np\ndef reshape_matrix(a: list[list[int|float]], new_shape: tuple[int, int]) -> list[list[int|float]]:\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 4, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Mean by Row or Column\n# Description:\nWrite a Python function that calculates the mean of a matrix either by row or by column, based on a given mode. The function should take a matrix (list of lists) and a mode ('row' or 'column') as input and return a list of means according to the specified mode.\n# Examples:\n## Example 1:\n### Input:\ncalculate_matrix_mean(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], mode = 'column')\n### Output:\n[4.0, 5.0, 6.0]\n### Reasoning:\nCalculating the mean of each column results in [(1+4+7)/3, (2+5+8)/3, (3+6+9)/3].\n# Your code should start with:\n```python\ndef calculate_matrix_mean(matrix: list[list[float]], mode: str) -> list[float]:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 5, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Scalar Multiplication of a Matrix\n# Description:\nWrite a Python function that multiplies a matrix by a scalar and returns the result.\n# Examples:\n## Example 1:\n### Input:\nscalar_multiply(matrix = [[1, 2], [3, 4]], scalar = 2)\n### Output:\n[[2, 4], [6, 8]]\n### Reasoning:\nEach element of the matrix is multiplied by the scalar.\n# Your code should start with:\n```python\ndef scalar_multiply(matrix: list[list[int|float]], scalar: int|float) -> list[list[int|float]]:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 6, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Eigenvalues of a Matrix\n# Description:\nWrite a Python function that calculates the eigenvalues of a 2x2 matrix. The function should return a list containing the eigenvalues, sort values from highest to lowest.\n# Examples:\n## Example 1:\n### Input:\ncalculate_eigenvalues(matrix = [[2, 1], [1, 2]])\n### Output:\n[3.0, 1.0]\n### Reasoning:\nThe eigenvalues of the matrix are calculated using the characteristic equation of the matrix, which for a 2\u00d72 matrix is $\\lambda^2 -     ext{trace}(A)\\lambda +     ext{det}(A) = 0$ where $\\lambda$ are the eigenvalues.\n# Your code should start with:\n```python\ndef calculate_eigenvalues(matrix: list[list[float|int]]) -> list[float]:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 7, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Matrix Transformation\n# Description:\nWrite a Python function that transforms a given matrix $A$ using the operation $T^{-1}AS$, where $T$ and $S$ are invertible matrices. The function should first validate if the matrices $T$ and $S$ are invertible, and then perform the transformation. In cases where there is no solution return -1.\n# Examples:\n## Example 1:\n### Input:\ntransform_matrix(A = [[1, 2], [3, 4]], T = [[2, 0], [0, 2]], S = [[1, 1], [0, 1]])\n### Output:\n[[0.5,1.5],[1.5,3.5]]\n### Reasoning:\nThe matrices $T$ and $S$ are used to transform matrix $A$ by computing $T^{-1}AS$.\n# Your code should start with:\n```python\nimport numpy as np\ndef transform_matrix(A: list[list[int|float]], T: list[list[int|float]], S: list[list[int|float]]) -> list[list[int|float]]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 8, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate 2x2 Matrix Inverse\n# Description:\nWrite a Python function that calculates the inverse of a 2x2 matrix. Return 'None' if the matrix is not invertible.\n# Examples:\n## Example 1:\n### Input:\ninverse_2x2(matrix = [[4, 7], [2, 6]])\n### Output:\n[[0.6, -0.7], [-0.2, 0.4]]\n### Reasoning:\nThe inverse of a 2x2 matrix [a, b], [c, d] is given by (1/(ad-bc)) * [d, -b], [-c, a], provided ad-bc is not zero.\n# Your code should start with:\n```python\ndef inverse_2x2(matrix: list[list[float]]) -> list[list[float]]:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 9, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Matrix times Matrix\n# Description:\nWrite a Python function that multiplies two matrices. If the matrices cannot be multiplied, return -1.\n# Examples:\n## Example 1:\n### Input:\nmatrixmul(a = [[1,2],[2,4]], b = [[2,1],[3,4]])\n### Output:\n[[ 8,  9],[16, 18]]\n### Reasoning:\n1*2 + 2*3 = 8; 2*2 + 3*4 = 16; 1*1 + 2*4 = 9; 2*1 + 4*4 = 18 Example 2: input: A = [[1,2], [2,4]], B = [[2,1], [3,4], [4,5]] output: -1 reasoning: the length of the rows of A does not equal the column length of B\n# Your code should start with:\n```python\ndef matrixmul(a:list[list[int|float]], b:list[list[int|float]])-> list[list[int|float]]:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 10, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Covariance Matrix\n# Description:\nWrite a Python function to calculate the covariance matrix for a given set of vectors. The function should take a list of lists, where each inner list represents a feature with its observations, and return a covariance matrix as a list of lists. Additionally, provide test cases to verify the correctness of your implementation.\n# Examples:\n## Example 1:\n### Input:\ncalculate_covariance_matrix(vectors = [[1, 2, 3], [4, 5, 6]])\n### Output:\n[[1.0, 1.0], [1.0, 1.0]]\n### Reasoning:\n\n# Your code should start with:\n```python\ndef calculate_covariance_matrix(vectors: list[list[float]]) -> list[list[float]]:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 11, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Solve Linear Equations using Jacobi Method\n# Description:\nWrite a Python function that uses the Jacobi method to solve a system of linear equations given by Ax = b. The function should iterate n times, rounding each intermediate solution to four decimal places, and return the approximate solution x.\n# Examples:\n## Example 1:\n### Input:\nsolve_jacobi(A = [[5, -2, 3], [-3, 9, 1], [2, -1, -7]], b = [-1, 2, 3], n = 2)\n### Output:\n[0.146, 0.2032, -0.5175]\n### Reasoning:\nThe Jacobi method iteratively solves each equation for x[i] using the formula x[i] = (1/a_ii) * (b[i] - sum(a_ij * x[j] for j != i)), where a_ii is the diagonal element of A and a_ij are the off-diagonal elements.\n# Your code should start with:\n```python\nimport numpy as np\ndef solve_jacobi(A: np.ndarray, b: np.ndarray, n: int) -> list:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 12, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Singular Value Decomposition (SVD)\n# Description:\nWrite a Python function that approximates the Singular Value Decomposition on a 2x2 matrix by using the jacobian method and without using numpy svd function, i mean you could but you wouldn't learn anything. return the result in this format.\n# Examples:\n## Example 1:\n### Input:\nsvd_2x2_singular_values(A = [[2, 1], [1, 2]])\n### Output:\narray([[-0.70710678, -0.70710678], [-0.70710678,  0.70710678]]), array([3., 1.]), array([[-0.70710678, -0.70710678], [-0.70710678,  0.70710678]])\n### Reasoning:\nU is the first matrix sigma is the second vector and V is the third matrix\n# Your code should start with:\n```python\nimport numpy as np\ndef svd_2x2_singular_values(A: np.ndarray) -> tuple:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 13, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Determinant of a 4x4 Matrix using Laplace's Expansion\n# Description:\nWrite a Python function that calculates the determinant of a 4x4 matrix using Laplace's Expansion method. The function should take a single argument, a 4x4 matrix represented as a list of lists, and return the determinant of the matrix. The elements of the matrix can be integers or floating-point numbers. Implement the function recursively to handle the computation of determinants for the 3x3 minor matrices.\n# Examples:\n## Example 1:\n### Input:\ndeterminant_4x4(matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])\n### Output:\n0\n### Reasoning:\nUsing Laplace's Expansion, the determinant of a 4x4 matrix is calculated by expanding it into minors and cofactors along any row or column. Given the symmetrical and linear nature of this specific matrix, its determinant is 0. The calculation for a generic 4x4 matrix involves more complex steps, breaking it down into the determinants of 3x3 matrices.\n# Your code should start with:\n```python\ndef determinant_4x4(matrix: list[list[int|float]]) -> float:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 14, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Linear Regression Using Normal Equation\n# Description:\nWrite a Python function that performs linear regression using the normal equation. The function should take a matrix X (features) and a vector y (target) as input, and return the coefficients of the linear regression model. Round your answer to four decimal places, -0.0 is a valid result for rounding a very small number.\n# Examples:\n## Example 1:\n### Input:\nlinear_regression_normal_equation(X = [[1, 1], [1, 2], [1, 3]], y = [1, 2, 3])\n### Output:\n[0.0, 1.0]\n### Reasoning:\nThe linear model is y = 0.0 + 1.0*x, perfectly fitting the input data.\n# Your code should start with:\n```python\nimport numpy as np\ndef linear_regression_normal_equation(X: list[list[float]], y: list[float]) -> list[float]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 15, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Linear Regression Using Gradient Descent\n# Description:\nWrite a Python function that performs linear regression using gradient descent. The function should take NumPy arrays X (features with a column of ones for the intercept) and y (target) as input, along with learning rate alpha and the number of iterations, and return the coefficients of the linear regression model as a list. Round your answer to four decimal places. -0.0 is a valid result for rounding a very small number.\n# Examples:\n## Example 1:\n### Input:\nlinear_regression_gradient_descent(X = np.array([[1, 1], [1, 2], [1, 3]]), y = np.array([1, 2, 3]), alpha = 0.01, iterations = 1000)\n### Output:\n[0.1107, 0.9513]\n### Reasoning:\nThe linear model is y = 0.0 + 1.0*x, which fits the input data after gradient descent optimization.\n# Your code should start with:\n```python\nimport numpy as np\ndef linear_regression_gradient_descent(X: np.ndarray, y: np.ndarray, alpha: float, iterations: int) -> np.ndarray:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 16, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Feature Scaling Implementation\n# Description:\nWrite a Python function that performs feature scaling on a dataset using both standardization and min-max normalization. The function should take a 2D NumPy array as input, where each row represents a data sample and each column represents a feature. It should return two 2D lists: one scaled by standardization and one by min-max normalization.\n# Examples:\n## Example 1:\n### Input:\nfeature_scaling(data = np.array([[1, 2], [3, 4], [5, 6]]))\n### Output:\n([[-1.2247, -1.2247], [0.0, 0.0], [1.2247, 1.2247]], [[0.0, 0.0], [0.5, 0.5], [1.0, 1.0]])\n### Reasoning:\nStandardization rescales the feature to have a mean of 0 and a standard deviation of 1. Min-max normalization rescales the feature to a range of [0, 1], where the minimum feature value maps to 0 and the maximum to 1.\n# Your code should start with:\n```python\nimport numpy as np\ndef feature_scaling(data: np.ndarray) -> (list[list[float]], list[list[float]]):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 17, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Polynomial Regression using Normal Equation\n# Description:\nWrite a Python function that implements the k-Means clustering algorithm. This function should take specific inputs and produce a list of final centroids. k-Means clustering is a method used to partition n points into k clusters. The goal is to group similar points together and represent each group by its center (called the centroid).\nFunction Inputs:\n- points: A list of points, where each point is a tuple of coordinates (e.g., (x, y) for 2D points)\n- k: An integer representing the number of clusters to form\n- initial_centroids: A list of initial centroid points, each a tuple of coordinates\n- max_iterations: An integer representing the maximum number of iterations to perform\nFunction Output:\n- A list of the final centroids of the clusters, where each centroid is rounded to the nearest fourth decimal.\n# Examples:\n## Example 1:\n### Input:\nk_means_clustering(points = [(1, 2), (1, 4), (1, 0), (10, 2), (10, 4), (10, 0)], k = 2, initial_centroids = [(1, 1), (10, 1)], max_iterations = 10)\n### Output:\n[(1, 2), (10, 2)]\n### Reasoning:\nGiven the initial centroids and a maximum of 10 iterations, the points are clustered around these points, and the centroids are updated to the mean of the assigned points, resulting in the final centroids which approximate the means of the two clusters. The exact number of iterations needed may vary, but the process will stop after 10 iterations at most.\n# Your code should start with:\n```python\nimport numpy as np\ndef k_means_clustering(points: list[tuple[float, float]], k: int, initial_centroids: list[tuple[float, float]], max_iterations: int) -> list[tuple[float, float]]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 18, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement K-Fold Cross-Validation\n# Description:\nWrite a Python function to generate train and test splits for K-Fold Cross-Validation. Your task is to divide the dataset into k folds and return a list of train-test indices for each fold.\n# Examples:\n## Example 1:\n### Input:\nk_fold_cross_validation(X = np.array([0,1,2,3,4,5,6,7,8,9]), y = np.array([0,1,2,3,4,5,6,7,8,9]), k=5, shuffle=False)\n### Output:\n[([2, 3, 4, 5, 6, 7, 8, 9], [0, 1]), ([0, 1, 4, 5, 6, 7, 8, 9], [2, 3]), ([0, 1, 2, 3, 6, 7, 8, 9], [4, 5]), ([0, 1, 2, 3, 4, 5, 8, 9], [6, 7]), ([0, 1, 2, 3, 4, 5, 6, 7], [8, 9])]\n### Reasoning:\nThe function splits the dataset into 5 folds without shuffling and returns train-test splits for each iteration.\n# Your code should start with:\n```python\nimport numpy as np\ndef k_fold_cross_validation(X: np.ndarray, y: np.ndarray, k=5, shuffle=True, random_seed=None):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 19, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Principal Component Analysis (PCA) Implementation\n# Description:\nWrite a Python function that performs Principal Component Analysis (PCA) from scratch. The function should take a 2D NumPy array as input, where each row represents a data sample and each column represents a feature. The function should standardize the dataset, compute the covariance matrix, find the eigenvalues and eigenvectors, and return the principal components (the eigenvectors corresponding to the largest eigenvalues). The function should also take an integer k as input, representing the number of principal components to return.\n# Examples:\n## Example 1:\n### Input:\npca(data = np.array([[1, 2], [3, 4], [5, 6]]), k = 1)\n### Output:\n[[0.7071], [0.7071]]\n### Reasoning:\nAfter standardizing the data and computing the covariance matrix, the eigenvalues and eigenvectors are calculated. The largest eigenvalue's corresponding eigenvector is returned as the principal component, rounded to four decimal places.\n# Your code should start with:\n```python\nimport numpy as np\ndef pca(data: np.ndarray, k: int) -> list[list[float]]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 20, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Decision Tree Learning\n# Description:\nWrite a Python function that implements the decision tree learning algorithm for classification. The function should use recursive binary splitting based on entropy and information gain to build a decision tree. It should take a list of examples (each example is a dict of attribute-value pairs) and a list of attribute names as input, and return a nested dictionary representing the decision tree.\n# Examples:\n## Example 1:\n### Input:\nlearn_decision_tree(examples = [ {'Outlook': 'Sunny', 'Temperature': 'Hot', 'Humidity': 'High', 'Wind': 'Weak', 'PlayTennis': 'No'}, {'Outlook': 'Sunny', 'Temperature': 'Hot', 'Humidity': 'High', 'Wind': 'Strong', 'PlayTennis': 'No'}, {'Outlook': 'Overcast', 'Temperature': 'Hot', 'Humidity': 'High', 'Wind': 'Weak', 'PlayTennis': 'Yes'}, {'Outlook': 'Rain', 'Temperature': 'Mild', 'Humidity': 'High', 'Wind': 'Weak', 'PlayTennis': 'Yes'}], attributes = ['Outlook', 'Temperature', 'Humidity', 'Wind'], target_attr = 'PlayTennis')\n### Output:\n{'Outlook': { 'Sunny': {'Humidity': {'High': 'No', 'Normal': 'Yes'}}, 'Overcast': 'Yes', 'Rain': {'Wind': {'Weak': 'Yes', 'Strong': 'No'}}}}\n### Reasoning:\nUsing the given examples, the decision tree algorithm determines that 'Outlook' is the best attribute to split the data initially. When 'Outlook' is 'Overcast', the outcome is always 'Yes', so it becomes a leaf node. In cases of 'Sunny' and 'Rain', it further splits based on 'Humidity' and 'Wind', respectively. The resulting tree structure is able to classify the training examples with the attributes 'Outlook', 'Temperature', 'Humidity', and 'Wind'.\n# Your code should start with:\n```python\nimport math\nfrom collections import Counter\ndef learn_decision_tree(examples: list[dict], attributes: list[str], target_attr: str) -> dict:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 21, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Pegasos Kernel SVM Implementation\n# Description:\nWrite a Python function that implements a deterministic version of the Pegasos algorithm to train a kernel SVM classifier from scratch. The function should take a dataset (as a 2D NumPy array where each row represents a data sample and each column represents a feature), a label vector (1D NumPy array where each entry corresponds to the label of the sample), and training parameters such as the choice of kernel (linear or RBF), regularization parameter (lambda), and the number of iterations. Note that while the original Pegasos algorithm is stochastic (it selects a single random sample at each step), this problem requires using all samples in every iteration (i.e., no random sampling). The function should perform binary classification and return the model's alpha coefficients and bias.\n# Examples:\n## Example 1:\n### Input:\npegasos_kernel_svm(data = np.array([[1, 2], [2, 3], [3, 1], [4, 1]]), labels = np.array([1, 1, -1, -1]), kernel = 'rbf', lambda_val = 0.01, iterations = 100)\n### Output:\n([0.03, 0.02, 0.05, 0.01], -0.05)\n### Reasoning:\nUsing the RBF kernel, the Pegasos algorithm iteratively updates the weights based on a sub-gradient descent method, taking into account the non-linear separability of the data induced by the kernel transformation.\n# Your code should start with:\n```python\nimport numpy as np\ndef pegasos_kernel_svm(data: np.ndarray, labels: np.ndarray, kernel='linear', lambda_val=0.01, iterations=100, sigma=1.0):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 22, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Sigmoid Activation Function Understanding\n# Description:\nWrite a Python function that computes the output of the sigmoid activation function given an input value z. The function should return the output rounded to four decimal places.\n# Examples:\n## Example 1:\n### Input:\nsigmoid(z = 0)\n### Output:\n0.5\n### Reasoning:\nThe sigmoid function is defined as $\\sigma (z) = 1 / (1 + exp(-z))$. For z = 0, exp(-0) = 1, hence the output is 1 / (1 + 1) = 0.5.\n# Your code should start with:\n```python\nimport math\ndef sigmoid(z: float) -> float:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 23, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Softmax Activation Function Implementation\n# Description:\nWrite a Python function that computes the softmax activation for a given list of scores. The function should return the softmax values as a list, each rounded to four decimal places.\n# Examples:\n## Example 1:\n### Input:\nsoftmax(scores = [1, 2, 3])\n### Output:\n[0.0900, 0.2447, 0.6652]\n### Reasoning:\nThe softmax function converts a list of values into a probability distribution. The probabilities are proportional to the exponential of each element divided by the sum of the exponentials of all elements in the list.\n# Your code should start with:\n```python\nimport math\ndef softmax(scores: list[float]) -> list[float]:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 24, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Single Neuron\n# Description:\nWrite a Python function that simulates a single neuron with a sigmoid activation function for binary classification, handling multidimensional input features. The function should take a list of feature vectors (each vector representing multiple features for an example), associated true binary labels, and the neuron's weights (one for each feature) and bias as input. It should return the predicted probabilities after sigmoid activation and the mean squared error between the predicted probabilities and the true labels, both rounded to four decimal places.\n# Examples:\n## Example 1:\n### Input:\nsingle_neuron_model(features = [[0.5, 1.0], [-1.5, -2.0], [2.0, 1.5]], labels = [0, 1, 0], weights = [0.7, -0.4], bias = -0.1)\n### Output:\n([0.4626, 0.4134, 0.6682], 0.3349)\n### Reasoning:\nFor each input vector, the weighted sum is calculated by multiplying each feature by its corresponding weight, adding these up along with the bias, then applying the sigmoid function to produce a probability. The MSE is calculated as the average squared difference between each predicted probability and the corresponding true label.\n# Your code should start with:\n```python\nimport math\ndef single_neuron_model(features: list[list[float]], labels: list[int], weights: list[float], bias: float) -> (list[float], float):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 25, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Single Neuron with Backpropagation\n# Description:\nWrite a Python function that simulates a single neuron with sigmoid activation, and implements backpropagation to update the neuron's weights and bias. The function should take a list of feature vectors, associated true binary labels, initial weights, initial bias, a learning rate, and the number of epochs. The function should update the weights and bias using gradient descent based on the MSE loss, and return the updated weights, bias, and a list of MSE values for each epoch, each rounded to four decimal places.\n# Examples:\n## Example 1:\n### Input:\ntrain_neuron(features = [[1.0, 2.0], [2.0, 1.0], [-1.0, -2.0]], labels = [1, 0, 0], initial_weights = [0.1, -0.2], initial_bias = 0.0, learning_rate = 0.1, epochs = 2)\n### Output:\nupdated_weights = [0.1036, -0.1425], updated_bias = -0.0167, mse_values = [0.3033, 0.2942]\n### Reasoning:\nThe neuron receives feature vectors and computes predictions using the sigmoid activation. Based on the predictions and true labels, the gradients of MSE loss with respect to weights and bias are computed and used to update the model parameters across epochs.\n# Your code should start with:\n```python\nimport numpy as np\ndef train_neuron(features: np.ndarray, labels: np.ndarray, initial_weights: np.ndarray, initial_bias: float, learning_rate: float, epochs: int) -> (np.ndarray, float, list[float]):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 26, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implementing Basic Autograd Operations\n# Description:\nWrite a Python class similar to the provided 'Value' class that implements the basic autograd operations: addition, multiplication, and ReLU activation. The class should handle scalar values and should correctly compute gradients for these operations through automatic differentiation.\n# Examples:\n## Example 1:\n### Input:\na = Value(2)\nb = Value(-3)\nc = Value(10)\nd = a + b * c\ne = d.relu()\ne.backward()\na.data, a.grad, b.data, b.grad, c.data, c.grad, d.data, d.grad, e.data, e.grad\n### Output:\n(2, 0, -3, 0, 10, 0, -28, 0, 0, 1)\n### Reasoning:\nThe output reflects the forward computation and gradients after backpropagation. The ReLU on 'd' zeros out its output and gradient due to the negative data value.\n# Your code should start with:\n```python\nclass Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0\n        self._backward = lambda: None\n        self._prev = set(_children)\n        self._op = _op\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 27, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Transformation Matrix from Basis B to C\n# Description:\nGiven basis vectors in two different bases B and C for R^3, write a Python function to compute the transformation matrix P from basis B to C.\n# Examples:\n## Example 1:\n### Input:\ntransform_basis(B = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], C = [[1, 2.3, 3], [4.4, 25, 6], [7.4, 8, 9]])\n### Output:\n[[-0.6772, -0.0126, 0.2342], [-0.0184, 0.0505, -0.0275], [0.5732, -0.0345, -0.0569]]\n### Reasoning:\nThe transformation matrix P from basis B to C can be found using matrix operations involving the inverse of matrix C.\n# Your code should start with:\n```python\nimport numpy as np\ndef transform_basis(B: list[list[int]], C: list[list[int]]) -> list[list[float]]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 28, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: SVD of a 2x2 Matrix using eigen values & vectors\n# Description:\nGiven a 2x2 matrix, write a Python function to compute its Singular Value Decomposition (SVD). The function should return the matrices U, S, and V such that A = U * S * V, use the method based on eigendecomposition of $A^T A$. Specifically:\n- Compute $A^T A$, which is symmetric and positive semi-definite\n- Perform eigendecomposition on $A^T A$ to obtain its eigenvalues and eigenvectors\n- Construct the singular values as the square roots of the eigenvalues, forming the diagonal matrix $S$\n- Use the eigenvectors of $A^T A$ as the columns of $V$\n- Compute $U$ by normalizing $A v_i$ for each non-zero singular value $\\sigma_i$\nThis approach provides a geometrically motivated construction of SVD suitable for small matrices.\n# Examples:\n## Example 1:\n### Input:\nsvd_2x2(A = np.array([[-10, 8], [10, -1]]))\n### Output:\n([[0.8, -0.6], [-0.6, -0.8]], [15.6525, 4.4721], [[-0.8944, 0.4472], [-0.4472, -0.8944]])\n### Reasoning:\nThe SVD of the matrix A is calculated using the eigenvalues and eigenvectors of A^T A and A A^T. The singular values are the square roots of the eigenvalues, and the eigenvectors form the columns of matrices U and V.\n# Your code should start with:\n```python\nimport numpy as np\ndef svd_2x2(A: np.ndarray) -> tuple:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 29, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Random Shuffle of Dataset\n# Description:\nWrite a Python function to perform a random shuffle of the samples in two numpy arrays, X and y, while maintaining the corresponding order between them. The function should have an optional seed parameter for reproducibility.\n# Examples:\n## Example 1:\n### Input:\nshuffle_data(X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]]), y = np.array([1, 2, 3, 4]), seed=42)\n### Output:\n([[3, 4], [7, 8], [1, 2], [5, 6]], [2, 4, 1, 3])\n### Reasoning:\nThe samples in X and y are shuffled randomly, maintaining the correspondence between the samples in both arrays.\n# Your code should start with:\n```python\nimport numpy as np\ndef shuffle_data(X, y, seed=None):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 30, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Batch Iterator for Dataset\n# Description:\nImplement a batch iterable function that samples in a numpy array X and an optional numpy array y. The function should yield batches of a specified size. If y is provided, the function should yield batches of (X, y) pairs; otherwise, it should yield batches of X only.\n# Examples:\n## Example 1:\n### Input:\nbatch_iterator(X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), y = np.array([1, 2, 3, 4, 5]), batch_size=2)\n### Output:\n[[[[1, 2], [3, 4]], [1, 2]], [[[5, 6], [7, 8]], [3, 4]], [[[9, 10]], [5]]]\n### Reasoning:\nThe dataset X contains 5 samples, and we are using a batch size of 2. Therefore, the function will divide the dataset into 3 batches. The first two batches will contain 2 samples each, and the last batch will contain the remaining sample. The corresponding values from y are also included in each batch.\n# Your code should start with:\n```python\nimport numpy as np\ndef batch_iterator(X, y=None, batch_size=64):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 31, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Divide Dataset Based on Feature Threshold\n# Description:\nWrite a Python function to divide a dataset based on whether the value of a specified feature is greater than or equal to a given threshold. The function should return two subsets of the dataset: one with samples that meet the condition and another with samples that do not.\n# Examples:\n## Example 1:\n### Input:\ndivide_on_feature(X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), feature_i = 0, threshold = 5)\n### Output:\n[[[5, 6], [7, 8], [9, 10]], [[1, 2], [3, 4]]]\n### Reasoning:\nThe dataset X is divided based on whether the value in the 0th feature (first column) is greater than or equal to 5. Samples with the first column value >= 5 are in the first subset, and the rest are in the second subset.\n# Your code should start with:\n```python\nimport numpy as np\ndef divide_on_feature(X, feature_i, threshold):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 32, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Generate Polynomial Features\n# Description:\nWrite a Python function to generate polynomial features for a given dataset. The function should take in a 2D numpy array X and an integer degree, and return a new 2D numpy array with polynomial features up to the specified degree.\n# Examples:\n## Example 1:\n### Input:\npolynomial_features(X = np.array([[2, 3], [3, 4], [5, 6]]), degree = 2)\n### Output:\n[[1.0, 1.0, 2.0, 1.0, 2.0, 4.0], [1.0, 3.0, 4.0, 9.0, 12.0, 16.0], [1.0, 5.0, 6.0, 25.0, 30.0, 36.0]]\n### Reasoning:\nFor each sample in X, the function generates all polynomial combinations of the features up to the given degree. For degree=2, it includes combinations like [x1^0, x1^1, x1^2, x2^0, x2^1, x2^2, x1^1*x2^1], where x1 and x2 are the features.\n# Your code should start with:\n```python\nimport numpy as np\nfrom itertools import combinations_with_replacement\ndef polynomial_features(X, degree):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 33, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Generate Random Subsets of a Dataset\n# Description:\nWrite a Python function to generate random subsets of a given dataset. The function should take in a 2D numpy array X, a 1D numpy array y, an integer n_subsets, and a boolean replacements. It should return a list of n_subsets random subsets of the dataset, where each subset is a tuple of (X_subset, y_subset). If replacements is True, the subsets should be created with replacements; otherwise, without replacements.\n# Examples:\n## Example 1:\n### Input:\nget_random_subsets(X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), y = np.array([1, 2, 3, 4, 5]), n_subsets = 3, replacements = False)\n### Output:\n[([[7, 8], [1, 2]], [4, 1]), ([[9, 10], [5, 6]], [5, 3]), ([[3, 4], [5, 6]], [2, 3])]\n### Reasoning:\nThe function generates three random subsets of the dataset without replacements. Each subset includes 50% of the samples (since replacements=False). The samples are randomly selected without duplication.\n# Your code should start with:\n```python\nimport numpy as np\ndef get_random_subsets(X, y, n_subsets, replacements=True, seed=42):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 34, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: One-Hot Encoding of Nominal Values\n# Description:\nWrite a Python function to perform one-hot encoding of nominal values. The function should take in a 1D numpy array x of integer values and an optional integer n_col representing the number of columns for the one-hot encoded array. If n_col is not provided, it should be automatically determined from the input array.\n# Examples:\n## Example 1:\n### Input:\nto_categorical(x = np.array([0, 1, 2, 1, 0]))\n### Output:\n[[1. 0. 0.], [0. 1. 0.], [0. 0. 1.], [0. 1. 0.], [1. 0. 0.]]\n### Reasoning:\nEach element in the input array is transformed into a one-hot encoded vector, where the index corresponding to the value in the input array is set to 1, and all other indices are set to 0.\n# Your code should start with:\n```python\nimport numpy as np\ndef to_categorical(x, n_col=None):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 35, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Convert Vector to Diagonal Matrix\n# Description:\nWrite a Python function to convert a 1D numpy array into a diagonal matrix. The function should take in a 1D numpy array x and return a 2D numpy array representing the diagonal matrix.\n# Examples:\n## Example 1:\n### Input:\nmake_diagonal(x = np.array([1, 2, 3]))\n### Output:\n[[1., 0., 0.], [0., 2., 0.], [0., 0., 3.]]\n### Reasoning:\nThe input vector [1, 2, 3] is converted into a diagonal matrix where the elements of the vector form the diagonal of the matrix.\n# Your code should start with:\n```python\nimport numpy as np\ndef make_diagonal(x):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 36, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Accuracy Score\n# Description:\nWrite a Python function to calculate the accuracy score of a model's predictions. The function should take in two 1D numpy arrays: y_true, which contains the true labels, and y_pred, which contains the predicted labels. It should return the accuracy score as a float.\n# Examples:\n## Example 1:\n### Input:\naccuracy_score(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 0, 1, 0, 1]))\n### Output:\n0.8333\n### Reasoning:\nThe function compares the true labels with the predicted labels and calculates the ratio of correct predictions to the total number of predictions. In this example, there are 5 correct predictions out of 6, resulting in an accuracy score of 0.8333333333333334.\n# Your code should start with:\n```python\nimport numpy as np\ndef accuracy_score(y_true, y_pred):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 37, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Correlation Matrix\n# Description:\nWrite a Python function to calculate the correlation matrix for a given dataset. The function should take in a 2D numpy array X and an optional 2D numpy array Y. If Y is not provided, the function should calculate the correlation matrix of X with itself. It should return the correlation matrix as a 2D numpy array.\n# Examples:\n## Example 1:\n### Input:\ncalculate_correlation_matrix(X = np.array([[1, 2], [3, 4], [5, 6]]))\n### Output:\n[[1.0, 1.0], [1.0, 1.0]]\n### Reasoning:\nThe function calculates the correlation matrix for the dataset X. In this example, the correlation between the two features is 1, indicating a perfect linear relationship.\n# Your code should start with:\n```python\nimport numpy as np\ndef calculate_correlation_matrix(X, Y=None):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 38, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement AdaBoost Fit Method\n# Description:\nWrite a Python function `adaboost_fit` that implements the fit method for an AdaBoost classifier. The function should take in a 2D numpy array `X` of shape `(n_samples, n_features)` representing the dataset, a 1D numpy array `y` of shape `(n_samples,)` representing the labels, and an integer `n_clf` representing the number of classifiers. The function should initialize sample weights, find the best thresholds for each feature, calculate the error, update weights, and return a list of classifiers with their parameters.\n# Examples:\n## Example 1:\n### Input:\nadaboost_fit(X = np.array([[1, 2], [2, 3], [3, 4], [4, 5]]), y = np.array([1, 1, -1, -1]), n_clf = 3)\n### Output:\n[{'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 11.5129}, {'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 11.5129}, {'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 11.5129}]\n### Reasoning:\nThe function fits an AdaBoost classifier on the dataset X with the given labels y and number of classifiers n_clf. It returns a list of classifiers with their parameters, including the polarity, threshold, feature index, and alpha values\n# Your code should start with:\n```python\nimport numpy as np\nimport math\ndef adaboost_fit(X, y, n_clf):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 39, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implementation of Log Softmax Function\n# Description:\nIn machine learning and statistics, the softmax function is a generalization of the logistic function that converts a vector of scores into probabilities.\nThe log-softmax function is the logarithm of the softmax function, and it is often used for numerical stability when computing the softmax of large numbers.\nGiven a 1D numpy array of scores, implement a Python function to compute the log-softmax of the array.\n# Examples:\n## Example 1:\n### Input:\nlog_softmax(scores = np.array([1, 2, 3]))\n### Output:\n[-2.4076, -1.4076, -0.4076]\n### Reasoning:\nThe log-softmax function is applied to the input array [1, 2, 3]. The output array contains the log-softmax values for each element.\n# Your code should start with:\n```python\nimport numpy as np\ndef log_softmax(scores: list):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 40, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implementing a Custom Dense Layer in Python\n# Description:\nYou are provided with a base `Layer` class that defines the structure of a neural network layer.\nThe `Dense` class represents a fully connected neural network layer and extend the `Layer` class with the `__init__` method:\n- Define the layer with a specified number of neurons (`n_units`) and an optional input shape (`input_shape`).\n- Set up placeholders for the layer's weights (`W`), biases (`w0`), and optimizers.\nYour task is to complete the subclass `Dense` and implement the following methods:\n1. Weight Initialization (`initialize`):\n  - Initialize the weights `W` using a uniform distribution with a limit of `1 / sqrt(input_shape[0])`, and bias `w0` should be set to zero.\n  - Initialize optimizers for `W` and `w0`.\n2. Parameter Count (`parameters`):\n  - Return the total number of trainable parameters in the layer, which includes the parameters in `W` and `w0`.\n3. Forward Pass (`forward_pass`):\n  - Compute the output of the layer by performing a dot product between the input `X` and the weight matrix `W`, and then adding the bias `w0`.\n4. Backward Pass (`backward_pass`):\n  - Calculate and return the gradient with respect to the input.\n  - If the layer is trainable, update the weights and biases using the optimizer's update rule.\n5. Output Shape (`output_shape`):\n- Return the shape of the output produced by the forward pass, which should be `(self.n_units,)`.\nObjective:\nExtend the `Layer` class by implementing the `Dense` class to ensure it functions correctly within a neural network framework.\n# Examples:\n## Example 1:\n### Input:\n# Initialize a Dense layer with 3 neurons and input shape (2,)\ndense_layer = Dense(n_units=3, input_shape=(2,))\n\n# Define a mock optimizer with a simple update rule\nclass MockOptimizer:\n    def update(self, weights, grad):\n        return weights - 0.01 * grad\n\noptimizer = MockOptimizer()\n\n# Initialize the Dense layer with the mock optimizer\ndense_layer.initialize(optimizer)\n\n# Perform a forward pass with sample input data\nX = np.array([[1, 2]])\ndense_layer.forward_pass(X)\n\n# Perform a backward pass with sample gradient\naccum_grad = np.array([[0.1, 0.2, 0.3]])\ndense_layer.backward_pass(accum_grad)\n### Output:\n[[0.2082, -0.2293]]\n### Reasoning:\nThe code initializes a Dense layer with 3 neurons and input shape (2,). It then performs a forward pass with sample input data and a backward pass with sample gradients. The output demonstrates the forward and backward pass results.\n# Your code should start with:\n```python\nimport numpy as np\nimport copy\nimport math\n\nclass Layer(object):\n\n    def set_input_shape(self, shape):\n    \n        self.input_shape = shape\n\n    def layer_name(self):\n        return self.__class__.__name__\n\n    def parameters(self):\n        return 0\n\n    def forward_pass(self, X, training):\n        raise NotImplementedError()\n\n    def backward_pass(self, accum_grad):\n        raise NotImplementedError()\n\n    def output_shape(self):\n        raise NotImplementedError()\nclass Dense(Layer):\n    def __init__(self, n_units, input_shape=None):\n        self.layer_input = None\n        self.input_shape = input_shape\n        self.n_units = n_units\n        self.trainable = True\n        self.W = None\n        self.w0 = None\n\n    \"\"\"\n    implement the Dense class based on the above structure\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 41, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Simple Convolutional 2D Layer\n# Description:\nIn this problem, you need to implement a 2D convolutional layer in Python. This function will process an input matrix using a specified convolutional kernel, padding, and stride.\n# Examples:\n## Example 1:\n### Input:\nsimple_conv2d(input_matrix = np.array([[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],[13, 14, 15, 16]]), kernel = np.array([[1, 0],[-1, 1]]), padding = 1, stride = 2)\n### Output:\n[[1.0, 1.0, -4.0], [9.0, 7.0, -4.0], [0.0, 14.0, 16.0]]\n### Reasoning:\nThe function performs a 2D convolution operation on the input matrix using the specified kernel, padding, and stride. The output matrix contains the results of the convolution operation.\n# Your code should start with:\n```python\nimport numpy as np\ndef simple_conv2d(input_matrix: np.ndarray, kernel: np.ndarray, padding: int, stride: int):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 42, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement ReLU Activation Function\n# Description:\nWrite a Python function `relu` that implements the Rectified Linear Unit (ReLU) activation function. The function should take a single float as input and return the value after applying the ReLU function. The ReLU function returns the input if it's greater than 0, otherwise, it returns 0.\n# Examples:\n## Example 1:\n### Input:\nrelu(z = 0)\n### Output:\n0\n### Reasoning:\nThe ReLU function is applied to the input values 0, 1, and -1. The output is 0 for negative values and the input value for non-negative values.\n# Your code should start with:\n```python\ndef relu(z: float) -> float:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 43, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Ridge Regression Loss Function\n# Description:\nWrite a Python function `ridge_loss` that implements the Ridge Regression loss function. The function should take a 2D numpy array `X` representing the feature matrix, a 1D numpy array `w` representing the coefficients, a 1D numpy array `y_true` representing the true labels, and a float `alpha` representing the regularization parameter. The function should return the Ridge loss, which combines the Mean Squared Error (MSE) and a regularization term.\n# Examples:\n## Example 1:\n### Input:\nridge_loss(X = np.array([[1, 1], [2, 1], [3, 1], [4, 1]]), w = np.array([0.2, 2]), y_true = np.array([2, 3, 4, 5]), alpha = 0.1)\n### Output:\n2.204\n### Reasoning:\nThe Ridge loss is calculated using the Mean Squared Error (MSE) and a regularization term. The output represents the combined loss value.\n# Your code should start with:\n```python\nimport numpy as np\ndef ridge_loss(X: np.ndarray, w: np.ndarray, y_true: np.ndarray, alpha: float) -> float:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 44, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Leaky ReLU Activation Function\n# Description:\nWrite a Python function `leaky_relu` that implements the Leaky Rectified Linear Unit (Leaky ReLU) activation function. The function should take a float `z` as input and an optional float `alpha`, with a default value of 0.01, as the slope for negative inputs. The function should return the value after applying the Leaky ReLU function.\n# Examples:\n## Example 1:\n### Input:\nleaky_relu(z = 0)\n### Output:\n0\n### Reasoning:\nFor z = 0, the output is 0.\n# Your code should start with:\n```python\ndef leaky_relu(z: float, alpha: float = 0.01) -> float|int:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 45, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Linear Kernel Function\n# Description:\nWrite a Python function `kernel_function` that computes the linear kernel between two input vectors `x1` and `x2`. The linear kernel is defined as the dot product (inner product) of two vectors.\n# Examples:\n## Example 1:\n### Input:\nkernel_function(x1 = np.array([1, 2, 3]), x2 = np.array([4, 5, 6]))\n### Output:\n32\n### Reasoning:\nThe linear kernel between x1 and x2 is computed as:1*4 + 2*5 + 3*6 = 32\n# Your code should start with:\n```python\nimport numpy as np\ndef kernel_function(x1, x2):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 46, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Precision Metric\n# Description:\nWrite a Python function `precision` that calculates the precision metric given two numpy arrays: `y_true` and `y_pred`. The `y_true` array contains the true binary labels, and the `y_pred` array contains the predicted binary labels. Precision is defined as the ratio of true positives to the sum of true positives and false positives.\n# Examples:\n## Example 1:\n### Input:\nprecision(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 1, 0, 0, 1]))\n### Output:\n1.0\n### Reasoning:\nTrue Positives (TP) = 3\nFalse Positives (FP) = 0\nPrecision = TP / (TP + FP) = 3 / (3 + 0) = 1.0\n# Your code should start with:\n```python\nimport numpy as np\ndef precision(y_true, y_pred):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 47, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Gradient Descent Variants with MSE Loss\n# Description:\nIn this problem, you need to implement a single function that can perform three variants of gradient descent\u00e2\u0080\u0094Stochastic Gradient Descent (SGD), Batch Gradient Descent, and Mini-Batch Gradient Descent\u00e2\u0080\u0094using Mean Squared Error (MSE) as the loss function. The function will take an additional parameter to specify which variant to use.\n# Examples:\n## Example 1:\n### Input:\ngradient_descent(X = np.array([[1, 1], [2, 1], [3, 1], [4, 1]]), y = np.array([2, 3, 4, 5]), weights = np.zeros(2), learning_rate = 0.01, n_iterations = 1000, method='batch')\n### Output:\n[1.01, 0.9705]\n### Reasoning:\nThe function should return the final weights after performing the specified variant of gradient descent.\n# Your code should start with:\n```python\nimport numpy as np\ndef gradient_descent(X, y, weights, learning_rate, n_iterations, batch_size=1, method='batch'):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 48, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Reduced Row Echelon Form (RREF) Function\n# Description:\nIn this problem, your task is to implement a function that converts a given matrix into its Reduced Row Echelon Form (RREF). The RREF of a matrix is a special form where each leading entry in a row is 1, and all other elements in the column containing the leading 1 are zeros, except for the leading 1 itself.\nHowever, there are some additional details to keep in mind:\n- Diagonal entries can be 0 if the matrix is reducible (i.e., the row corresponding to that position can be eliminated entirely).\n- Some rows may consist entirely of zeros.\n- If a column contains a pivot (a leading 1), all other entries in that column should be zero.\nYour task is to implement the RREF algorithm, which must handle these cases and convert any given matrix into its RREF.\n# Examples:\n## Example 1:\n### Input:\nrref(matrix = np.array([[1, 2, -1, -4], [2, 3, -1, -11],[-2, 0, -3, 22]]))\n### Output:\n[[1.0, 0.0, 0.0, -8.0], [0.0, 1.0, 0.0, 1.0], [-0.0, -0.0, 1.0, -2.0]]\n### Reasoning:\nThe given matrix is converted to its Reduced Row Echelon Form (RREF) where each leading entry is 1, and all other entries in the leading columns are zero.\n# Your code should start with:\n```python\nimport numpy as np\ndef rref(matrix):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 49, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Adam Optimization Algorithm\n# Description:\nImplement the Adam (Adaptive Moment Estimation) optimization algorithm in Python. Adam is an optimization algorithm that adapts the learning rate for each parameter. Your task is to write a function `adam_optimizer` that updates the parameters of a given function using the Adam algorithm.\nThe function should take the following parameters:\n- `f`: The objective function to be optimized\n- `grad`: A function that computes the gradient of `f`\n- `x0`: Initial parameter values\n- `learning_rate`: The step size (default: 0.001)\n- `beta1`: Exponential decay rate for the first moment estimates (default: 0.9)\n- `beta2`: Exponential decay rate for the second moment estimates (default: 0.999)\n- `epsilon`: A small constant for numerical stability (default: 1e-8)\n- `num_iterations`: Number of iterations to run the optimizer (default: 1000)\nThe function should return the optimized parameters.\n# Examples:\n## Example 1:\n### Input:\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\ndef gradient(x):\n    return np.array([2*x[0], 2*x[1]])\n\nadam_optimizer(objective_function, gradient, x0 = np.array([1.0, 1.0]))\n### Output:\n[0.99, 0.99]\n### Reasoning:\nThe Adam optimizer updates the parameters to minimize the objective function. In this case, the objective function is the sum of squares of the parameters, and the optimizer finds the optimal values for the parameters.\n# Your code should start with:\n```python\nimport numpy as np\ndef adam_optimizer(f, grad, x0, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8, num_iterations=10):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 50, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Lasso Regression using Gradient Descent\n# Description:\nIn this problem, you need to implement the Lasso Regression algorithm using Gradient Descent. Lasso Regression (L1 Regularization) adds a penalty equal to the absolute value of the coefficients to the loss function. Your task is to update the weights and bias iteratively using the gradient of the loss function and the L1 penalty.\nThe objective function of Lasso Regression is:\n$J(w, b) = \frac{1}{2n} \\sum\\limits_{i=1}^n (y_i - (\\sum\\limits_{j=1}^p X_{ij} w_j + b))^2$\nWhere:\n- $y_i$  is the actual value for the i-th sample\n- $\\hat{y_i} = \\sum_{j=1}^p X_{ij}w_j + b$ is the predicted value for the i-th sample\n- $w_j$ is the weight associated with the j-th feature\n- $\u0007lpha$ is the regularization parameter\n- $b$ is the bias\nYour task is to use the L1 penalty to shrink some of the feature coefficients to zero during gradient descent, thereby helping with feature selection.\n# Examples:\n## Example 1:\n### Input:\nl1_regularization_gradient_descent(X = np.array([[0, 0], [1, 1], [2, 2]]), y = np.array([0, 1, 2]), alpha = 0.1, learning_rate=0.01, max_iter=1000)\n### Output:\n([0.4237, 0.4237], 0.1539)\n### Reasoning:\nThe Lasso Regression algorithm is used to optimize the weights and bias for the given data. The weights are adjusted to minimize the loss function with the L1 penalty.\n# Your code should start with:\n```python\nimport numpy as np\ndef l1_regularization_gradient_descent(X: np.array, y: np.array, alpha: float = 0.1, learning_rate: float = 0.01, max_iter: int = 1000, tol: float = 1e-4) -> tuple:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 51, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Optimal String Alignment Distance\n# Description:\nIn this problem, you need to implement a function that calculates the Optimal String Alignment (OSA) distance between two given strings. The OSA distance represents the minimum number of edits required to transform one string into another. The allowed edit operations are:\n- Insert a character\n- Delete a character\n- Substitute a character\n- Transpose two adjacent characters\nEach of these operations costs 1 unit.\nYour task is to find the minimum number of edits needed to convert the first string (s1) into the second string (s2).\nFor example, the OSA distance between the strings `caper` and `acer` is 2: one deletion (removing \"p\") and one transposition (swapping \"a\" and \"c\").\n# Examples:\n## Example 1:\n### Input:\nOSA(source = \"butterfly\", target = \"dragonfly\")\n### Output:\n6\n### Reasoning:\nThe OSA distance between the strings \"butterfly\" and \"dragonfly\" is 6. The minimum number of edits required to transform the source string into the target string is 6.\n# Your code should start with:\n```python\nimport numpy as np\ndef OSA(source: str, target: str) -> int:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 52, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Recall Metric in Binary Classification\n# Description:\nYour task is to implement the recall metric in a binary classification setting. Recall is a performance measure that evaluates how effectively a machine learning model identifies positive instances from all the actual positive cases in a dataset.\nYou need to write a function `recall(y_true, y_pred)` that calculates the recall metric. The function should accept two inputs:\n- `y_true`: A list of true binary labels (0 or 1) for the dataset.\n- `y_pred`: A list of predicted binary labels (0 or 1) from the model.\nYour function should return the recall value rounded to three decimal places. If the denominator (TP + FN) is zero, the recall should be 0.0 to avoid division by zero.\n# Examples:\n## Example 1:\n### Input:\nrecall(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 1, 0, 0, 1]))\n### Output:\n0.75\n### Reasoning:\nThe recall value for the given true labels and predicted labels is 0.75. The model correctly identified 3 out of 4 positive instances in the dataset.\n# Your code should start with:\n```python\nimport numpy as np\ndef recall(y_true, y_pred):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 53, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Self-Attention Mechanism\n# Description:\nYour task is to implement the self-attention mechanism, which is a fundamental component of transformer models, widely used in natural language processing and computer vision tasks. The self-attention mechanism allows a model to dynamically focus on different parts of the input sequence when generating a contextualized representation.\nYour function should return the self-attention output as a numpy array.\n# Examples:\n## Example 1:\n### Input:\nself_attention(X = np.array([[1, 0], [0, 1]]), W_q = np.array([[1, 0], [0, 1]]), W_k = np.array([[1, 0], [0, 1]]), W_v = np.array([[1, 2], [3, 4]]))\n### Output:\n[[1.6605, 2.6605], [2.3395, 3.3395]]\n### Reasoning:\nThe self-attention mechanism calculates the attention scores for each input, determining how much focus to put on other inputs when generating a contextualized representation. The output is the weighted sum of the values based on the attention scores.\n# Your code should start with:\n```python\nimport numpy as np\ndef self_attention(X, W_q, W_k, W_v):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 54, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implementing a Simple RNN\n# Description:\nWrite a Python function that implements a simple Recurrent Neural Network (RNN) cell. The function should process a sequence of input vectors and produce the final hidden state. Use the tanh activation function for the hidden state updates. The function should take as inputs the sequence of input vectors, the initial hidden state, the weight matrices for input-to-hidden and hidden-to-hidden connections, and the bias vector. The function should return the final hidden state after processing the entire sequence, rounded to four decimal places.\n# Examples:\n## Example 1:\n### Input:\nrnn_forward(input_sequence = [[1.0], [2.0], [3.0]], initial_hidden_state = [0.0], Wx = [[0.5]], Wh = [[0.8]], b = [0.0])\n### Output:\n[0.9759]\n### Reasoning:\nThe RNN processes each input in the sequence, updating the hidden state at each step using the tanh activation function.\n# Your code should start with:\n```python\nimport numpy as np\ndef rnn_forward(input_sequence: list[list[float]], initial_hidden_state: list[float], Wx: list[list[float]], Wh: list[list[float]], b: list[float]) -> list[float]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 55, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: 2D Translation Matrix Implementation\n# Description:\nYour task is to implement a function that applies a 2D translation matrix to a set of points. A translation matrix is used to move points in 2D space by a specified distance in the x and y directions.\nWrite a function `translate_object(points, tx, ty)` where `points` is a list of [x, y] coordinates and `tx` and `ty` are the translation distances in the x and y directions, respectively.\nThe function should return a new list of points after applying the translation matrix.\n# Examples:\n## Example 1:\n### Input:\ntranslate_object(points = [[0, 0], [1, 0], [0.5, 1]], tx =  2, ty = 3)\n### Output:\n[[2.0, 3.0], [3.0, 3.0], [2.5, 4.0]]\n### Reasoning:\nThe translation matrix moves the points by 2 units in the x-direction and 3 units in the y-direction. The resulting points are [[2.0, 3.0], [3.0, 3.0], [2.5, 4.0]].\n# Your code should start with:\n```python\nimport numpy as np\ndef translate_object(points, tx, ty):\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 56, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: KL Divergence Between Two Normal Distributions\n# Description:\nYour task is to compute the Kullback-Leibler (KL) divergence between two normal distributions. KL divergence measures how one probability distribution differs from a second, reference probability distribution.\nWrite a function `kl_divergence_normal(mu_p, sigma_p, mu_q, sigma_q)` that calculates the KL divergence between two normal distributions, where $ P \\sim N(\\mu_P, \\sigma_P^2) $ and $ Q \\sim N(\\mu_Q, \\sigma_Q^2) $.\nThe function should return the KL divergence as a floating-point number.\n# Examples:\n## Example 1:\n### Input:\nkl_divergence_normal(mu_p = 0.0, sigma_p = 1.0, mu_q = 1.0, sigma_q = 1.0)\n### Output:\n0.5\n### Reasoning:\nThe KL divergence between the normal distributions $ P $ and $ Q $ with parameters $ \\mu_P = 0.0 $, $ \\sigma_P = 1.0 $ and $ \\mu_Q = 1.0 $, $ \\sigma_Q = 1.0 $ is 0.5.\n# Your code should start with:\n```python\nimport numpy as np\ndef kl_divergence_normal(mu_p, sigma_p, mu_q, sigma_q):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 57, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Gauss-Seidel Method for Solving Linear Systems\n# Description:\nYour task is to implement the Gauss-Seidel method, an iterative technique for solving a system of linear equations (Ax = b).\nThe function should iteratively update the solution vector (x) by using the most recent values available during the iteration process.\nWrite a function `gauss_seidel(A, b, n, x_ini=None)` where:\n- `A` is a square matrix of coefficients,\n- `b` is the right-hand side vector,\n- `n` is the number of iterations,\n- `x_ini` is an optional initial guess for (x) (if not provided, assume a vector of zeros).\nThe function should return the approximated solution vector (x) after performing the specified number of iterations.\n# Examples:\n## Example 1:\n### Input:\ngauss_seidel(A = np.array([[4, 1, 2], [3, 5, 1], [1, 1, 3]], dtype=float), b = np.array([4, 7, 3], dtype=float), n = 100)\n### Output:\n[0.5, 1.0, 0.5]\n### Reasoning:\nThe Gauss-Seidel method iteratively updates the solution vector (x) until convergence. The output is an approximate solution to the linear system.\n# Your code should start with:\n```python\nimport numpy as np\ndef gauss_seidel(A, b, n, x_ini=None):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 58, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Gaussian Elimination for Solving Linear Systems\n# Description:\nYour task is to implement the Gaussian Elimination method, which transforms a system of linear equations into an upper triangular matrix. This method can then be used to solve for the variables using backward substitution.\nWrite a function `gaussian_elimination(A, b)` that performs Gaussian Elimination with partial pivoting to solve the system (Ax = b).\nThe function should return the solution vector (x).\n# Examples:\n## Example 1:\n### Input:\ngaussian_elimination(A = np.array([[2,8,4], [2,5,1], [4,10,-1]], dtype=float), b = np.array([2,5,1], dtype=float))\n### Output:\n[11.0, -4.0, 3.0]\n### Reasoning:\nThe Gaussian Elimination method transforms the system of equations into an upper triangular matrix and then uses backward substitution to solve for the variables.\n# Your code should start with:\n```python\nimport numpy as np\ndef gaussian_elimination(A, b):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 59, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Long Short-Term Memory (LSTM) Network\n# Description:\nYour task is to implement an LSTM network that processes a sequence of inputs and produces the final hidden state and cell state after processing all inputs.\nComplete the class `LSTM` with the method `forward(self, x, initial_hidden_state, initial_cell_state)`: processes a sequence of inputs and returns the hidden states at each time step, as well as the final hidden state and cell state.\nThe LSTM should compute the forget gate, input gate, candidate cell state, and output gate at each time step to update the hidden state and cell state.\n# Examples:\n## Example 1:\n### Input:\nlstm = LSTM(input_size=1, hidden_size=1)\nlstm.forward(x = np.array([[1.0], [2.0], [3.0]]), initial_hidden_state = np.zeros((1, 1)), initial_cell_state = np.zeros((1, 1)))\n### Output:\n([[[0.0806]], [[0.0358]], [[0.0077]]], [[0.0077]], [[0.0738]])\n### Reasoning:\nThe LSTM processes the input sequence [1.0, 2.0, 3.0] and produces the final hidden state [0.73698596].\n# Your code should start with:\n```python\nimport numpy as np\nclass LSTM:\n    def __init__(self, input_size, hidden_size):\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n\n        # Initialize weights and biases\n        self.Wf = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wi = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wc = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wo = np.random.randn(hidden_size, input_size + hidden_size)\n\n        self.bf = np.zeros((hidden_size, 1))\n        self.bi = np.zeros((hidden_size, 1))\n        self.bc = np.zeros((hidden_size, 1))\n        self.bo = np.zeros((hidden_size, 1))\n\n    def forward(self, x, initial_hidden_state, initial_cell_state):\n        \"\"\"\n        Processes a sequence of inputs and returns the hidden states, final hidden state, and final cell state.\n        \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 60, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement TF-IDF (Term Frequency-Inverse Document Frequency)\n# Description:\nYour task is to implement a function that computes the TF-IDF scores for a query against a given corpus of documents.\nFunction Signature\nWrite a function `compute_tf_idf(corpus, query)` that takes the following inputs:\n- `corpus`: A list of documents, where each document is a list of words.\n- `query`: A list of words for which you want to compute the TF-IDF scores.\nOutput\nThe function should return a list of lists containing the TF-IDF scores for the query words in each document, rounded to five decimal places.\nImportant Considerations\n1. Handling Division by Zero:\nWhen implementing the Inverse Document Frequency (IDF) calculation, you must account for cases where a term does not appear in any document (`df = 0`). This can lead to division by zero in the standard IDF formula. Add smoothing (e.g., adding 1 to both numerator and denominator) to avoid such errors.\n2. Empty Corpus:\nEnsure your implementation gracefully handles the case of an empty corpus. If no documents are provided, your function should either raise an appropriate error or return an empty result. This will ensure the program remains robust and predictable.\n3. Edge Cases:\n  - Query terms not present in the corpus.\n  - Documents with no words.\n  - Extremely large or small values for term frequencies or document frequencies.\nBy addressing these considerations, your implementation will be robust and handle real-world scenarios effectively.\n# Examples:\n## Example 1:\n### Input:\ncompute_tf_idf(corpus = [[\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], [\"the\", \"dog\", \"chased\", \"the\", \"cat\"], [\"the\", \"bird\", \"flew\", \"over\", \"the\", \"mat\"]], query = [\"cat\"])\n### Output:\n[[0.21461], [0.25754], [0.0]]\n### Reasoning:\nThe TF-IDF scores for the word \"cat\" in each document are computed and rounded to five decimal places.\n# Your code should start with:\n```python\nimport numpy as np\ndef compute_tf_idf(corpus, query):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 61, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement F-Score Calculation for Binary Classification\n# Description:\nImplement a function that calculates the F-Score for a binary classification task.\nThe F-Score combines both Precision and Recall into a single metric, providing a balanced measure of a model's performance.\nWrite a function `f_score(y_true, y_pred, beta)` where:\n- `y_true`: A numpy array of true labels (binary).\n- `y_pred`: A numpy array of predicted labels (binary).\n- `beta`: A float value that adjusts the importance of Precision and Recall. When `beta`=1, it computes the F1-Score, a balanced measure of both Precision and Recall.\nThe function should return the F-Score rounded to three decimal places.\n# Examples:\n## Example 1:\n### Input:\nf_score(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 1, 0, 0, 1]), beta = 1)\n### Output:\n0.857\n### Reasoning:\nThe F-Score for the binary classification task is calculated using the true labels, predicted labels, and beta value.\n# Your code should start with:\n```python\nimport numpy as np\ndef f_score(y_true, y_pred, beta):\n    \"\"\"\n    Calculate F-Score for a binary classification task.\n\n    :param y_true: Numpy array of true labels\n    :param y_pred: Numpy array of predicted labels\n    :param beta: The weight of precision in the harmonic mean\n    :return: F-Score rounded to three decimal places\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 62, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement a Simple RNN with Backpropagation Through Time (BPTT)\n# Description:\nImplement a simple Recurrent Neural Network (RNN) and backpropagation through time (BPTT) to learn from sequential data.\nThe RNN will process input sequences, update hidden states, and perform backpropagation to adjust weights based on the error gradient.\n`initialize_weights(input_size, hidden_size, output_size)` function initializes the RNN with weights set to random values multiplied by 0.01 and biases set to zero.\nWrite the following methods to complete forward pass, and backward pass of the RNN:\n- `rnn_forward(W_xh, W_hh, W_hy, b_h, b_y, hidden_size, input_sequence)`: Processes a sequence of inputs and returns the output, the last inputs and the hidden states.\n- `rnn_backward(W_xh, W_hh, W_hy, b_h, b_y, hidden_size, input_sequence, expected_output, outputs, last_inputs, last_hiddens, learning_rate)`: Performs backpropagation through time (BPTT) to adjust the weights based on the loss.\nIn this task, the RNN will be trained on sequence prediction, where the network will learn to predict the next item in a sequence.\nYou should use 1/2 * Mean Squared Error (MSE) as the loss function and make sure to aggregate the losses at each time step by summing.\n# Examples:\n## Example 1:\n### Input:\ninput_sequence = np.array([[1.0], [2.0], [3.0], [4.0]])\nexpected_output = np.array([[2.0], [3.0], [4.0], [5.0]])\n# Initialize RNN\nrnn = SimpleRNN(input_size=1, hidden_size=5, output_size=1)\n\nrnn.forward(input_sequence)\nrnn.backward(input_sequence, expected_output, learning_rate=0.01)\nrnn.forward(input_sequence)\n### Output:\n[[[0.001]], [[0.0021]], [[0.0031]], [[0.0041]]]\n### Reasoning:\nThe RNN processes the input sequence [1.0, 2.0, 3.0, 4.0] and predicts the next item in the sequence at each step.\n# Your code should start with:\n```python\nimport numpy as np\nclass SimpleRNN:\n    def __init__(self, input_size, hidden_size, output_size):\n        \"\"\"\n        Initializes the RNN with random weights and zero biases.\n        \"\"\"\n        self.hidden_size = hidden_size\n        self.W_xh = np.random.randn(hidden_size, input_size)*0.01\n        self.W_hh = np.random.randn(hidden_size, hidden_size)*0.01\n        self.W_hy = np.random.randn(output_size, hidden_size)*0.01\n        self.b_h = np.zeros((hidden_size, 1))\n        self.b_y = np.zeros((output_size, 1))\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass through the RNN for a given sequence of inputs.\n        \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 63, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Conjugate Gradient Method for Solving Linear Systems\n# Description:\nImplement the Conjugate Gradient (CG) method, an efficient iterative algorithm for solving large, sparse, symmetric, positive-definite linear systems.\nGiven a matrix `A` and a vector `b`, the algorithm will solve for `x` in the system ( Ax = b ).\nWrite a function `conjugate_gradient(A, b, n, x0=None, tol=1e-8)` that performs the Conjugate Gradient method as follows:\n- `A`: A symmetric, positive-definite matrix representing the linear system.\n- `b`: The vector on the right side of the equation.\n- `n`: Maximum number of iterations.\n- `x0`: Initial guess for the solution vector.\n- `tol`: Tolerance for stopping criteria.\nThe function should return the solution vector `x`.\n# Examples:\n## Example 1:\n### Input:\nconjugate_gradient(A = np.array([[4, 1], [1, 3]]), b = np.array([1, 2]), n = 5)\n### Output:\n[0.09090909, 0.63636364]\n### Reasoning:\nThe Conjugate Gradient method is applied to the linear system Ax = b with the given matrix A and vector b. The algorithm iteratively refines the solution to converge to the exact solution.\n# Your code should start with:\n```python\nimport numpy as np\ndef conjugate_gradient(A: np.array, b: np.array, n: int, x0: np.array=None, tol=1e-8):\n    \"\"\"\n    Solve the system Ax = b using the Conjugate Gradient method.\n\n    :param A: Symmetric positive-definite matrix\n    :param b: Right-hand side vector\n    :param n: Maximum number of iterations\n    :param x0: Initial guess for solution (default is zero vector)\n    :param tol: Convergence tolerance\n    :return: Solution vector x\n    \"\"\"\n```\n# Output Constraints:\nThe final solution vector x should be rounded to 8 decimal places and converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 64, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Gini Impurity Calculation for a Set of Classes\n# Description:\nImplement a function that calculates the Gini Impurity for a set of classes.\nGini impurity is commonly used in decision tree algorithms to measure the impurity or disorder within a node.\n# Examples:\n## Example 1:\n### Input:\ngini_impurity(y = [0, 1, 1, 1, 0])\n### Output:\n0.48\n### Reasoning:\nThe Gini Impurity is calculated as 1 - (p_0^2 + p_1^2), where p_0 and p_1 are the probabilities of each class. In this case, p_0 = 2/5 and p_1 = 3/5, resulting in a Gini Impurity of 0.48.\n# Your code should start with:\n```python\nimport numpy as np\ndef gini_impurity(y: list[int]) -> float:\n    \"\"\"\n    Calculate Gini Impurity for a list of class labels.\n\n    :param y: List of class labels\n    :return: Gini Impurity rounded to three decimal places\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 65, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Compressed Row Sparse Matrix (CSR) Format Conversion\n# Description:\nImplement a function that converts a given dense matrix into the Compressed Row Sparse (CSR) format, an efficient storage representation for sparse matrices.\nThe CSR format only stores non-zero elements and their positions, significantly reducing memory usage for matrices with a large number of zeros.\nWrite a function `compressed_row_sparse_matrix(dense_matrix)` that takes a 2D list `dense_matrix` as input and returns a tuple containing three lists:\n- Values array: List of all non-zero elements in row-major order.\n- Column indices array: Column index for each non-zero element in the values array.\n- Row pointer array: Cumulative number of non-zero elements per row, indicating the start of each row in the values array.\n# Examples:\n## Example 1:\n### Input:\ncompressed_row_sparse_matrix(dense_matrix = [[1, 0, 0, 0], [0, 2, 0, 0], [3, 0, 4, 0], [1, 0, 0, 5]])\n### Output:\n([1, 2, 3, 4, 1, 5], [0, 1, 0, 2, 0, 3], [0, 1, 2, 4, 6])\n### Reasoning:\nThe dense matrix is converted to CSR format with the values array containing non-zero elements, column indices array storing the corresponding column index, and row pointer array indicating the start of each row in the values array.\n# Your code should start with:\n```python\ndef compressed_row_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix to its Compressed Row Sparse (CSR) representation.\n\n    :param dense_matrix: 2D list representing a dense matrix\n    :return: A tuple containing (values array, column indices array, row pointer array)\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 66, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Orthogonal Projection of a Vector onto a Line\n# Description:\nImplement a function that calculates the orthogonal projection of a vector `v` onto another vector `L`. This projection results in the vector on `L` that is closest to `v`.\nWrite a function `orthogonal_projection(v, L)` that takes in two lists, `v` (the vector to be projected) and `L` (the line vector), and returns the orthogonal projection of `v` onto `L`.\nThe function should output a list representing the projection vector rounded to three decimal places.\n# Examples:\n## Example 1:\n### Input:\northogonal_projection(v = [3, 4], L = [1, 0])\n### Output:\n[3.0, 0.0]\n### Reasoning:\nThe orthogonal projection of vector [3, 4] onto the line defined by [1, 0] results in the projection vector [3, 0], which lies on the line [1, 0].\n# Your code should start with:\n```python\ndef orthogonal_projection(v, L):\n    \"\"\"\n    Compute the orthogonal projection of vector v onto line L.\n\n    :param v: The vector to be projected\n    :param L: The line vector defining the direction of projection\n    :return: List representing the projection of v onto L\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 67, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Compressed Column Sparse Matrix Format (CSC)\n# Description:\nImplement a function that converts a dense matrix into its Compressed Column Sparse (CSC) representation.\nThe CSC format stores only non-zero elements of the matrix and is efficient for matrices with a high number of zero elements.\nWrite a function `compressed_col_sparse_matrix(dense_matrix)` that takes in a two-dimensional list `dense_matrix` and returns a tuple of three lists:\n- `values`: List of non-zero elements, stored in column-major order.\n- `row indices`: List of row indices corresponding to each value in the values array.\n- `column pointer`: List that indicates the starting index of each column in the values array.\n# Examples:\n## Example 1:\n### Input:\ncompressed_col_sparse_matrix(dense_matrix = [[0, 0, 3, 0], [1, 0, 0, 4], [0, 2, 0, 0]])\n### Output:\n([1, 2, 3, 4], [1, 2, 0, 1], [0, 1, 2, 3, 4])\n### Reasoning:\nThe dense matrix is converted to CSC format with the values array containing non-zero elements, row indices array storing the corresponding row index, and column pointer array indicating the start of each column in the values array.\n# Your code should start with:\n```python\ndef compressed_col_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix into its Compressed Column Sparse (CSC) representation.\n\n    :param dense_matrix: List of lists representing the dense matrix\n    :return: Tuple of (values, row indices, column pointer)\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 68, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Find the Image of a Matrix Using Row Echelon Form\n# Description:\nImplement a function `matrix_image(A)` that calculates the column space of a given matrix `A`.\nThe column space, also known as the image or span, consists of all linear combinations of the columns of `A`. \nTo find this, you'll use concepts from linear algebra, focusing on identifying independent columns that span the matrix's image. \nThe function `matrix_image(A)` should return the basis vectors that span the column space of `A`.\nThese vectors should be extracted from the original matrix and correspond to the independent columns.\n# Examples:\n## Example 1:\n### Input:\nmatrix_image(A = np.array([[1, 2, 3], [4, 5, 6],[7, 8, 9]]))\n### Output:\n[[1, 2], [4, 5], [7, 8]]\n### Reasoning:\nThe column space of the matrix is spanned by the independent columns [1, 2], [4, 5], and [7, 8]. These columns form the basis vectors that represent the image of the matrix.\n# Your code should start with:\n```python\nimport numpy as np\ndef matrix_image(A):\n```\n# Output Constraints:\nThe matrix representing basis vectors should be rounded to 8 decimal places and converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 69, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate R-squared for Regression Analysis\n# Description:\nR-squared, also known as the coefficient of determination, is a measure that indicates how well the independent variables explain the variability of the dependent variable in a regression model.\nTo implement the function `r_squared(y_true, y_pred)` that calculates the R-squared value, given arrays of true values `y_true` and predicted values `y_pred`.\n# Examples:\n## Example 1:\n### Input:\nr_squared(y_true = np.array([1, 2, 3, 4, 5]), y_pred = np.array([1.1, 2.1, 2.9, 4.2, 4.8]))\n### Output:\n0.989\n### Reasoning:\nThe R-squared value is calculated to be 0.989, indicating that the regression model explains 98.9% of the variance in the dependent variable.\n# Your code should start with:\n```python\nimport numpy as np\ndef r_squared(y_true, y_pred):\n```\n# Output Constraints:\nYour code should return the R-squared value rounded to three decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 70, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Image Brightness\n# Description:\nImplement a function `calculate_brightness(img)` that calculates the average brightness of a grayscale image. The image is represented as a 2D matrix, where each element represents a pixel value between 0 (black) and 255 (white).\nThe function `calculate_brightness(img)` should:\n1. Return the average brightness of the image rounded to two decimal places.\n2. Handle edge cases:\n    - If the image matrix is empty.\n    - If the rows in the matrix have inconsistent lengths.\n    - If any pixel values are outside the valid range (0-255).\nFor any of these edge cases, the function should return `-1`.\n# Examples:\n## Example 1:\n### Input:\ncalculate_brightness(img = [[100, 200], [50, 150]])\n### Output:\n125.0\n### Reasoning:\nThe average brightness is calculated as (100 + 200 + 50 + 150) / 4 = 125.0\n# Your code should start with:\n```python\ndef calculate_brightness(img):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 71, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Root Mean Square Error (RMSE)\n# Description:\nImplement a function `rmse(y_true, y_pred)` that calculates the Root Mean Square Error (RMSE) between the actual values and the predicted values. RMSE is a commonly used metric for evaluating the accuracy of regression models, providing insight into the standard deviation of residuals.\nThe function `rmse(y_true, y_pred)` should:\n1. Calculate the RMSE between the arrays y_true and y_pred.\n2. Return the RMSE value rounded to three decimal places.\n3. Ensure the function handles edge cases such as:\n    - Mismatched array shapes.\n    - Empty arrays.\n    - Invalid input types.\nThe RMSE is defined as $ RMSE = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (y_{true,i} - y_{pred,i})^2} $, where:\n- $n$ is the number of observations.\n- $y_{true,i}$ and $y_{pred,i}$ are the actual and predicted values for the $i$-th observation.\n# Examples:\n## Example 1:\n### Input:\nrmse(y_true = np.array([3, -0.5, 2, 7]), y_pred = np.array([2.5, 0.0, 2, 8]))\n### Output:\n0.612\n### Reasoning:\nThe RMSE is calculated as sqrt((0.5^2 + 0.5^2 + 0^2 + 1^2) / 4) = 0.612\n# Your code should start with:\n```python\nimport numpy as np\ndef rmse(y_true, y_pred):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 72, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Jaccard Index for Binary Classification\n# Description:\nImplement a function `jaccard_index(y_true, y_pred)` that calculates the Jaccard Index, a measure of similarity between two binary sets. The Jaccard Index is widely used in binary classification tasks to evaluate the overlap between predicted and true labels.\nThe function `jaccard_index(y_true, y_pred)` should:\n1. Calculate the Jaccard Index between the arrays `y_true` and `y_pred`.\n2. Return the Jaccard Index as a float value.\n3. Ensure the function handles cases where:\n    - There is no overlap between `y_true` and `y_pred`.\n    - Both arrays contain only zeros (edge cases).\n\nThe Jaccard Index is defined as $ Jaccard Index = \\frac{\\text{Number of elements in the intersection of } y_{\\text{true}} \\text{ and } y_{\\text{pred}} }{\\text{Number of elements in the union of } y_{\\text{true}} \\text{ and } y_{\\text{pred}}} $, where:\n- $y_{\\text{true}}$ and $y_{\\text{pred}}$ are binary arrays of the same length, representing true and predicted labels.\n- The result ranges from 0 (no overlap) to 1 (perfect overlap).\n# Examples:\n## Example 1:\n### Input:\njaccard_index(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 1, 0, 0, 1]))\n### Output:\n0.75\n### Reasoning:\nThe Jaccard Index is calculated as 3 / 4 = 0.75, indicating a 75% overlap between the true and predicted labels.\n# Your code should start with:\n```python\nimport numpy as np\ndef jaccard_index(y_true, y_pred):\n```\n# Output Constraints:\nYour code should return the Jaccard Index rounded to three decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 73, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Dice Score for Classification\n# Description:\nImplement a function `dice_score(y_true, y_pred)` that calculates the Dice Score, also known as the S\u00c3\u00b8rensen-Dice coefficient or F1-score, for binary classification. The Dice Score is used to measure the similarity between two sets and is particularly useful in tasks like image segmentation and binary classification.\nThe function `dice_score(y_true, y_pred)` should:\n1. Calculate the Dice Score between the arrays `y_true` and `y_pred`.\n2. Return the Dice Score as a float value rounded to 3 decimal places.\n3. Handle edge cases appropriately, such as when there are no true or predicted positives.\n\nThe Dice Score is defined as $ Dice Score = \\frac{2 \\times (\\text{Number of elements in the intersection of } y_{\\text{true}} \\text{ and } y_{\\text{pred}})}{\\text{Number of elements in } y_{\\text{true}} + \\text{Number of elements in } y_{\\text{pred}}} $, where:\n- $y_{\\text{true}}$ and $y_{\\text{pred}}$ are binary arrays of the same length, representing true and predicted labels.\n- The result ranges from 0 (no overlap) to 1 (perfect overlap).\n# Examples:\n## Example 1:\n### Input:\ndice_score(y_true = np.array([1, 1, 0, 1, 0, 1]), y_pred = np.array([1, 1, 0, 0, 0, 1]))\n### Output:\n0.857\n### Reasoning:\nThe Dice Score is calculated as (2 * 3) / (2 * 3 + 0 + 1) = 0.857, indicating an 85.7% overlap between the true and predicted labels.\n# Your code should start with:\n```python\nimport numpy as np\ndef dice_score(y_true, y_pred):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 74, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Create Composite Hypervector for a Dataset Row\n# Description:\nImplement the function `create_row_hv(row, dim, random_seeds)` to generate a composite hypervector for a given dataset row using Hyperdimensional Computing (HDC).\nEach feature in the row is represented by binding hypervectors for the feature name and its value.\nThe hypervectors for the values are created using the same feature seed provided in the `random_seeds` dictionary to ensure reproducibility.\nAll feature hypervectors are then bundled to create a composite hypervector for the row.\nInput:\n- `row`: A dictionary representing a dataset row, where keys are feature names and values are their corresponding values.\n- `dim`: The dimensionality of the hypervectors.\n- `random_seeds`: A dictionary where keys are feature names and values are seeds to ensure reproducibility of hypervectors.\nOutput:\n- A composite hypervector representing the entire row.\n# Examples:\n## Example 1:\n### Input:\ncreate_row_hv(row = {\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}, dim = 5, random_seeds = {\"FeatureA\": 42, \"FeatureB\": 7})\n### Output:\n[ 1, -1,  1,  1,  1]\n### Reasoning:\nThe composite hypervector is created by binding hypervectors for each feature and bundling them together.\n# Your code should start with:\n```python\nimport numpy as np\ndef create_row_hv(row, dim, random_seeds):\n```\n# Output Constraints:\nThe composite hypervector should be converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 75, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Generate a Confusion Matrix for Binary Classification\n# Description:\nImplement the function `confusion_matrix(data)` that generates a confusion matrix for a binary classification problem.\nThe confusion matrix provides a summary of the prediction results on a classification problem, allowing you to visualize how many data points were correctly or incorrectly labeled.\nInput:\n    - A list of lists, where each inner list represents a pair\n    - `[y_true, y_pred]` for one observation. `y_true` is the actual label, and `y_pred` is the predicted label.\nOutput:\n    - A 2x2 confusion matrix represented as a list of lists.\n# Examples:\n## Example 1:\n### Input:\nconfusion_matrix(data = [[1, 1], [1, 0], [0, 1], [0, 0], [0, 1]])\n### Output:\n[[1, 1], [2, 1]]\n### Reasoning:\nThe confusion matrix shows the counts of true positives, false negatives, false positives, and true negatives.\n# Your code should start with:\n```python\nfrom collections import Counter\ndef confusion_matrix(data):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 76, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Cosine Similarity Between Vectors\n# Description:\nImplement a function `cosine_similarity(v1, v2)` that calculates the cosine similarity between two vectors.\nCosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\nInput:\n- `v1` and `v2`: Numpy arrays representing the input vectors.\nOutput:\n- A float representing the cosine similarity, rounded to three decimal places.\nConstraints:\n- Both input vectors must have the same shape.\n- Input vectors cannot be empty or have zero magnitude.\n# Examples:\n## Example 1:\n### Input:\ncosine_similarity(v1 = np.array([1, 2, 3]), v2 = np.array([2, 4, 6]))\n### Output:\n1.0\n### Reasoning:\nThe cosine similarity between v1 and v2 is 1.0, indicating perfect similarity.\n# Your code should start with:\n```python\nimport numpy as np\ndef cosine_similarity(v1, v2):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 77, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Performance Metrics for a Classification Model\n# Description:\nImplement a function `performance_metrics(actual, predicted)` that computes various performance metrics for a binary classification problem.\nThese metrics include:\n- Confusion Matrix\n- Accuracy\n- F1 Score\n- Specificity\n- Negative Predictive Value\nThe function should take in two lists as input:\n- `actual`: The actual class labels (1 for positive, 0 for negative).\n- `predicted`: The predicted class labels from the model.\nThe function should return a tuple containing:\n- `confusion_matrix`: A 2x2 matrix.\n- `accuracy`: A float representing the accuracy of the model.\n- `f1_score`: A float representing the F1 score of the model.\n- `specificity`: A float representing the specificity of the model.\n- `negative_predictive_value`: A float representing the negative predictive value.\nConstraints\n- All elements in the `actual` and `predicted` lists must be either 0 or 1.\n- Both lists must have the same length.\n# Examples:\n## Example 1:\n### Input:\nperformance_metrics(actual = [1, 0, 1, 0, 1], predicted = [1, 0, 0, 1, 1])\n### Output:\n([[2, 1], [1, 1]], 0.6, 0.667, 0.5, 0.5)\n### Reasoning:\nThe function calculates the confusion matrix, accuracy, F1 score, specificity, and negative predictive value based on the input labels. The resulting values are rounded to three decimal places as required.\n# Your code should start with:\n```python\nfrom collections import Counter\ndef performance_metrics(actual: list[int], predicted: list[int]) -> tuple:\n```\n# Output Constraints:\nWhen your code return `accuracy`, `f1_score`, `specificity`, and `negative_predictive_value`, their values should be rounded to three decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 78, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Descriptive Statistics Calculator\n# Description:\nWrite a Python function to calculate various descriptive statistics metrics for a given dataset. The function should take a list or NumPy array of numerical values and return a dictionary containing mean, median, mode, variance, standard deviation, percentiles (25th, 50th, 75th), and interquartile range (IQR).\n# Examples:\n## Example 1:\n### Input:\ndescriptive_statistics(data = [10, 20, 30, 40, 50])\n### Output:\n{'mean': 30.0, 'median': 30.0, 'mode': 10, 'variance': 200.0, 'standard_deviation': 14.1421, '25th_percentile': 20.0, '50th_percentile': 30.0, '75th_percentile': 40.0, 'interquartile_range': 20.0}\n### Reasoning:\nThe dataset is processed to calculate all descriptive statistics. The mean is the average value, the median is the central value, the mode is the most frequent value, and variance and standard deviation measure the spread of data. Percentiles and IQR describe data distribution.\n# Your code should start with:\n```python\nimport numpy as np\ndef descriptive_statistics(data):\n```\n# Output Constraints:\nThe output should be a dictionary with the following keys:\n- 'mean'\n- 'median'\n- 'mode'\n- 'variance'\n- 'standard_deviation'\n- '25th_percentile'\n- '50th_percentile'\n- '75th_percentile'\n- 'interquartile_range'\nExcept for statistics that draw from the data, all other values should be rounded to four decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 79, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Binomial Distribution Probability\n# Description:\nWrite a Python function to calculate the probability of achieving exactly k successes in n independent Bernoulli trials, each with probability p of success, using the Binomial distribution formula.\n# Examples:\n## Example 1:\n### Input:\nbinomial_probability(n = 6, k = 2, p = 0.5)\n### Output:\n0.23438\n### Reasoning:\nThe function calculates the Binomial probability, the intermediate steps include calculating the binomial coefficient, raising p and (1-p) to the appropriate powers, and multiplying the results.\n# Your code should start with:\n```python\nimport math\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Calculate the probability of achieving exactly k successes in n independent Bernoulli trials,\n    each with probability p of success, using the Binomial distribution formula.\n    :param n: Total number of trials\n    :param k: Number of successes\n    :param p: Probability of success on each trial\n    :return: Probability of k successes in n trials\n    \"\"\"\n```\n# Output Constraints:\nYour code should return the probability rounded to five decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 80, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Normal Distribution PDF Calculator\n# Description:\nWrite a Python function to calculate the probability density function (PDF) of the normal distribution for a given value, mean, and standard deviation. The function should use the mathematical formula of the normal distribution to return the PDF value rounded to 5 decimal places.\n# Examples:\n## Example 1:\n### Input:\nnormal_pdf(x = 16, mean = 15, std_dev = 2.04)\n### Output:\n0.17342\n### Reasoning:\nThe function computes the PDF using x = 16, mean = 15, and std_dev = 2.04.\n# Your code should start with:\n```python\nimport math\ndef normal_pdf(x, mean, std_dev):\n    \"\"\"\n    Calculate the probability density function (PDF) of the normal distribution.\n    :param x: The value at which the PDF is evaluated.\n    :param mean: The mean (\u03bc) of the distribution.\n    :param std_dev: The standard deviation (\u03c3) of the distribution.\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 81, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Poisson Distribution Probability Calculator\n# Description:\nWrite a Python function to calculate the probability of observing exactly k events in a fixed interval using the Poisson distribution formula. The function should take k (number of events) and lam (mean rate of occurrences) as inputs and return the probability rounded to 5 decimal places.\n# Examples:\n## Example 1:\n### Input:\npoisson_probability(k = 3, lam = 5)\n### Output:\n0.14037\n### Reasoning:\nThe function calculates the probability for a given number of events occurring in a fixed interval, based on the mean rate of occurrences.\n# Your code should start with:\n```python\nimport math\ndef poisson_probability(k, lam):\n    \"\"\"\n    Calculate the probability of observing exactly k events in a fixed interval,\n    given the mean rate of events lam, using the Poisson distribution formula.\n    :param k: Number of events (non-negative integer)\n    :param lam: The average rate (mean) of occurrences in a fixed interval\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 82, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Grayscale Image Contrast Calculator\n# Description:\nWrite a Python function to calculate the contrast of a grayscale image using the difference between the maximum and minimum pixel values.\n# Examples:\n## Example 1:\n### Input:\ncalculate_contrast(img = np.array([[0, 50], [200, 255]]))\n### Output:\n255\n### Reasoning:\nThe function calculates contrast by finding the difference between the maximum (255) and minimum (0) pixel values in the image, resulting in a contrast of 255.\n# Your code should start with:\n```python\nimport numpy as np\ndef calculate_contrast(img):\n    \"\"\"\n    Calculate the contrast of a grayscale image.\n    Args:\n        img (numpy.ndarray): 2D array representing a grayscale image with pixel values between 0 and 255.\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 83, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Dot Product Calculator\n# Description:\nWrite a Python function to calculate the dot product of two vectors. The function should take two 1D NumPy arrays as input and return the dot product as a single number.\n# Examples:\n## Example 1:\n### Input:\ncalculate_dot_product(vec1 = np.array([1, 2, 3]), vec2 = np.array([4, 5, 6]))\n### Output:\n32\n### Reasoning:\nThe function calculates the dot product by multiplying corresponding elements of the two vectors and summing the results. For vec1 = [1, 2, 3] and vec2 = [4, 5, 6], the result is (1 * 4) + (2 * 5) + (3 * 6) = 32.\n# Your code should start with:\n```python\nimport numpy as np\ndef calculate_dot_product(vec1, vec2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Args:\n        vec1 (numpy.ndarray): 1D array representing the first vector.\n        vec2 (numpy.ndarray): 1D array representing the second vector.\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 84, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Phi Transformation for Polynomial Features\n# Description:\nWrite a Python function to perform a Phi Transformation that maps input features into a higher-dimensional space by generating polynomial features. The transformation allows models like linear regression to fit nonlinear data by introducing new feature dimensions that represent polynomial combinations of the original input features. The function should take a list of numerical data and a degree as inputs, and return a nested list where each inner list represents the transformed features of a data point. If the degree is less than 0, the function should return an empty list.\n# Examples:\n## Example 1:\n### Input:\nphi_transform(data = [1.0, 2.0], degree = 2)\n### Output:\n[[1.0, 1.0, 1.0], [1.0, 2.0, 4.0]]\n### Reasoning:\nThe Phi Transformation generates polynomial features for each data point up to the specified degree. For data = [1.0, 2.0] and degree = 2, the transformation creates a nested list where each row contains powers of the data point from 0 to 2.\n# Your code should start with:\n```python\nimport numpy as np\ndef phi_transform(data: list[float], degree: int):\n    \"\"\"\n    Perform a Phi Transformation to map input features into a higher-dimensional space by generating polynomial features.\n\n    Args:\n        data (list[float]): A list of numerical values to transform.\n        degree (int): The degree of the polynomial expansion.\n    \"\"\"\n```\n# Output Constraints:\nThe function should output a list of lists, where each inner list contains the polynomial features of the corresponding data point. The output should be rounded to 8 decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 85, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Positional Encoding Calculator\n# Description:\nWrite a Python function to implement the Positional Encoding layer for Transformers. The function should calculate positional encodings for a sequence length (`position`) and model dimensionality (`d_model`) using sine and cosine functions as specified in the Transformer architecture. The function should return -1 if `position` is 0, or if `d_model` is less than or equal to 0.\n# Examples:\n## Example 1:\n### Input:\npos_encoding(position = 2, d_model = 8)\n### Output:\n[[0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0], [0.84130859375, 0.54052734375, 0.099853515625, 0.9951171875, 0.01000213623046875, 1.0, 0.0010004043579101562, 1.0]]\n### Reasoning:\nThe function computes the positional encoding by calculating sine values for even indices and cosine values for odd indices, ensuring that the encoding provides the required positional information.\n# Your code should start with:\n```python\nimport numpy as np\ndef pos_encoding(position: int, d_model: int):\n```\n# Output Constraints:\nThe position encoding array should be of dtype np.float16 and converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 86, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Detect Overfitting or Underfitting\n# Description:\nWrite a Python function to determine whether a machine learning model is overfitting, underfitting, or performing well based on training and test accuracy values. The function should take two inputs: `training_accuracy` and `test_accuracy`. It should return one of three values: 1 if Overfitting, -1 if Underfitting, or 0 if a Good fit. The rules for determination are as follows:\n\n- **Overfitting**: The training accuracy is significantly higher than the test accuracy (difference > 0.2).\n- **Underfitting**: Both training and test accuracy are below 0.7.\n- **Good fit**: Neither of the above conditions is true.\n# Examples:\n## Example 1:\n### Input:\nmodel_fit_quality(training_accuracy = 0.95, test_accuracy = 0.65)\n### Output:\n1\n### Reasoning:\nThe training accuracy is much higher than the test accuracy (difference = 0.30 > 0.2). This indicates that the model is overfitting to the training data and generalizes poorly to unseen data.\n# Your code should start with:\n```python\ndef model_fit_quality(training_accuracy, test_accuracy):\n    \"\"\"\n    Determine if the model is overfitting, underfitting, or a good fit based on training and test accuracy.\n    :param training_accuracy: float, training accuracy of the model (0 <= training_accuracy <= 1)\n    :param test_accuracy: float, test accuracy of the model (0 <= test_accuracy <= 1)\n    :return: int, one of '1', '-1', or '0'.\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 87, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Adam Optimizer\n# Description:\nImplement the Adam optimizer update step function. Your function should take the current parameter value, gradient, and moving averages as inputs, and return the updated parameter value and new moving averages. The function should also handle scalar and array inputs and include bias correction for the moving averages.\n# Examples:\n## Example 1:\n### Input:\nadam_optimizer(parameter = 1.0, grad = 0.1, m = 0.0, v = 0.0, t = 1)\n### Output:\n(0.999, 0.01, 0.00001)\n### Reasoning:\nThe Adam optimizer computes updated values for the parameter, first moment (m), and second moment (v) using bias-corrected estimates of gradients. With input values parameter=1.0, grad=0.1, m=0.0, v=0.0, and t=1, the updated parameter becomes 0.999.\n# Your code should start with:\n```python\nimport numpy as np\ndef adam_optimizer(parameter, grad, m, v, t, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8):\n    \"\"\"\n    Update parameters using the Adam optimizer.\n    Adjusts the learning rate based on the moving averages of the gradient and squared gradient.\n    :param parameter: Current parameter value\n    :param grad: Current gradient\n    :param m: First moment estimate\n    :param v: Second moment estimate\n    :param t: Current timestep\n    :param learning_rate: Learning rate (default=0.001)\n    :param beta1: First moment decay rate (default=0.9)\n    :param beta2: Second moment decay rate (default=0.999)\n    :param epsilon: Small constant for numerical stability (default=1e-8)\n    :return: tuple: (updated_parameter, updated_m, updated_v)\n    \"\"\"\n```\n# Output Constraints:\nThe updated parameter, first moment (m), and second moment (v) should be rounded to 5 decimal places and converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 88, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: GPT-2 Text Generation\n# Description:\nImplement a Simplified GPT-2-like Text Generation Function\n\nYou are tasked with implementing a simplified GPT-2-like text generation function in Python. This function will incorporate the following components of a minimal GPT-2 architecture:\n\n- **Token Embeddings**: Map input tokens to dense vector representations.\n- **Positional Embeddings**: Add positional information to token embeddings.\n- **Multi-head Attention**: Attend to various parts of the sequence.\n- **Feed-Forward Network**: Process attention outputs through a dense layer.\n- **Layer Normalization**: Stabilize the training process.\n\nThe function must take in the following parameters:\n\n1. Prompt: The initial text to guide the generation process.\n2. Number of Tokens to Generate: Specify how many tokens to output.\n\nYour function should output the generated text.\n\nAdditionally, utilize the helper function `load_encoder_hparams_and_params` to retrieve:\n\n- A dummy encoder.\n- Model hyperparameters.\n- Model parameters.\n\nBuild your text generation logic around these components. This exercise is designed to help you understand the core concepts behind GPT-2's autoregressive text generation.\n# Examples:\n## Example 1:\n### Input:\ngen_text(prompt=\"hello\", n_tokens_to_generate=5)\n### Output:\n\"world <UNK> <UNK> <UNK> <UNK>\"\n### Reasoning:\nThe function encodes the input \"hello\" into tokens using the dummy encoder, then runs a simplified GPT-2 forward pass to generate 5 tokens. Finally, it decodes the generated tokens back into text.\n# Your code should start with:\n```python\nimport numpy as np\n\ndef load_encoder_hparams_and_params(model_size: str = \"124M\", models_dir: str = \"models\"):\n    class DummyBPE:\n        def __init__(self):\n            self.encoder_dict = {\"hello\": 1, \"world\": 2, \"<UNK>\": 0}\n\n        def encode(self, text: str):\n            tokens = text.strip().split()\n            return [self.encoder_dict.get(token, self.encoder_dict[\"<UNK>\"]) for token in tokens]\n\n        def decode(self, token_ids: list):\n            reversed_dict = {v: k for k, v in self.encoder_dict.items()}\n            return \" \".join([reversed_dict.get(tok_id, \"<UNK>\") for tok_id in token_ids])\n\n    hparams = {\n        \"n_ctx\": 1024,\n        \"n_head\": 12\n    }\n\n    params = {\n        \"wte\": np.random.rand(3, 10),\n        \"wpe\": np.random.rand(1024, 10),\n        \"blocks\": [],\n        \"ln_f\": {\n            \"g\": np.ones(10),\n            \"b\": np.zeros(10),\n        }\n    }\n\n    encoder = DummyBPE()\n    return encoder, hparams, params\ndef gen_text(prompt: str, n_tokens_to_generate: int = 40):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 89, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: The Pattern Weaver's Code\n# Description:\nDeep in the Crystal Cave, the enigmatic Pattern Weaver creates stunning sequences by uncovering the intricate relationships between crystals.\nEach crystal is marked by a unique numeric value, and the Weaver emphasizes that the true power of any crystal depends on how it interacts with all others.\nYou have discovered N crystals, each with a specific value, and need to reveal their enhanced patterns by analyzing these relationships using self-attention.\nGiven a sequence of crystals and their values, implement a simplified self-attention mechanism.\nFor each crystal, calculate its relationship with every other crystal, compute the attention scores using the softmax function, and derive the final weighted pattern for each crystal.\n# Examples:\n## Example 1:\n### Input:\npattern_weaver(n = 5, crystal_values = [4, 2, 7, 1, 9], dimension = 1)\n### Output:\n[8.9993, 8.9638, 9.0, 8.7259, 9.0]\n### Reasoning:\nThe self-attention mechanism calculates relationships (attention scores) for each crystal using the given formula. These scores are converted to probabilities using the softmax function, and the final weighted pattern for each crystal is derived by summing the weighted values.\n# Your code should start with:\n```python\nimport numpy as np\ndef pattern_weaver(n, crystal_values, dimension):\n    def softmax(values):\n        # Implement the softmax function first\n```\n# Output Constraints:\nYour code should return a list of floats, each rounded to the 4th decimal place.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 90, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: BM25 Ranking\n# Description:\nImplement the BM25 ranking function to calculate document scores for a query in an information retrieval context. BM25 is an advanced variation of TF-IDF that incorporates term frequency saturation, document length normalization, and a configurable penalty for document length effects.\n# Examples:\n## Example 1:\n### Input:\ncalculate_bm25_scores(corpus = [['the', 'cat', 'sat'], ['the', 'dog', 'ran'], ['the', 'bird', 'flew']], query = ['the', 'cat'])\n### Output:\n[0.693, 0., 0. ]\n### Reasoning:\nBM25 calculates scores for each document in the corpus by evaluating how well the query terms match each document while considering term frequency saturation and document length normalization.\n# Your code should start with:\n```python\nimport numpy as np\nfrom collections import Counter\ndef calculate_bm25_scores(corpus, query, k1=1.5, b=0.75):\n```\n# Output Constraints:\nThe function should output a list representing the score of each document in the corpus, with each rounded to three decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 91, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate F1 Score from Predicted and True Labels\n# Description:\nImplement a function to calculate the F1 score given predicted and true labels. The F1 score is a widely used metric in machine learning, combining precision and recall into a single measure. round your solution to the 3rd decimal place\n# Examples:\n## Example 1:\n### Input:\ncalculate_f1_score(y_true = [1, 0, 1, 1, 0], y_pred = [1, 0, 0, 1, 1])\n### Output:\n0.667\n### Reasoning:\nThe true positives, false positives, and false negatives are calculated from the given labels. Precision and recall are derived, and the F1 score is computed as their harmonic mean.\n# Your code should start with:\n```python\ndef calculate_f1_score(y_true, y_pred):\n    \"\"\"\n    Calculate the F1 score based on true and predicted labels.\n\n    Args:\n        y_true (list): True labels (ground truth).\n        y_pred (list): Predicted labels.\n\n    Returns:\n        float: The F1 score rounded to three decimal places.\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 92, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Linear Regression - Power Grid Optimization\n# Description:\nIt is the year 2157. Mars has its first thriving colony, and energy consumption is steadily on the rise. As the lead data scientist, you have daily power usage measurements (10 days) affected by both a growing linear trend and a daily fluctuation. The fluctuation follows the formula $f(i) = 10 \\times \\sin(2\\pi i / 10)$, where i is the day number (1 through 10). Your challenge is to remove this known fluctuation from each data point, fit a linear regression model to the detrended data, predict day 15's base consumption, add back the fluctuation for day 15, and finally include a 5% safety margin. The final answer must be an integer, ensuring you meet the colony's future needs.\n# Examples:\n## Example 1:\n### Input:\npower_grid_forecast(consumption_data = [150, 165, 185, 195, 210, 225, 240, 260, 275, 290])\n### Output:\n404\n### Reasoning:\nFor each of the 10 days, we subtract the daily fluctuation given by 10*sin(2\u03c0*i/10). We then perform linear regression on the resulting values, predict day 15\u2019s base usage, and add back the day 15 fluctuation. Finally, we apply a 5% margin. Running the provided solution code yields 404 for this dataset.\n# Your code should start with:\n```python\nimport math\nPI = 3.14159\ndef power_grid_forecast(consumption_data):\n    # 1) Subtract the daily fluctuation (10 * sin(2\u03c0 * i / 10)) from each data point.\n    # 2) Perform linear regression on the detrended data.\n    # 3) Predict day 15's base consumption.\n    # 4) Add the day 15 fluctuation back.\n    # 5) Round, then add a 5% safety margin (rounded up).\n    # 6) Return the final integer.\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 93, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Mean Absolute Error (MAE)\n# Description:\nImplement a function to calculate the Mean Absolute Error (MAE) between two arrays of actual and predicted values. The MAE is a metric used to measure the average magnitude of errors in a set of predictions without considering their direction.\n# Examples:\n## Example 1:\n### Input:\nmae(y_true = np.array([3, -0.5, 2, 7]), y_pred = np.array([2.5, 0.0, 2, 8]))\n### Output:\n0.500\n### Reasoning:\nThe MAE is calculated by taking the mean of the absolute differences between the predicted and true values. Using the formula, the result is 0.500.\n# Your code should start with:\n```python\nimport numpy as np\ndef mae(y_true, y_pred):\n    \"\"\"\n    Calculate Mean Absolute Error between two arrays.\n\n    Parameters:\n    y_true (numpy.ndarray): Array of true values\n    y_pred (numpy.ndarray): Array of predicted values\n\n    Returns:\n    float: Mean Absolute Error rounded to 3 decimal places\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 94, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Multi-Head Attention\n# Description:\nImplement the multi-head attention mechanism, a key component in the Transformer model, via three key functions: `compute_qkv`, `self_attention`, and `multi_head_attention`.\n# Examples:\n## Example 1:\n### Input:\nnp.random.seed(42)\nm, n = 2, 2\nn_heads = 2\nX = np.arange(m*n).reshape(m,n)\nX = np.random.permutation(X.flatten()).reshape(m, n)\nW_q = np.random.randint(0,4,size=(n,n))\nW_k = np.random.randint(0,5,size=(n,n))\nW_v = np.random.randint(0,6,size=(n,n))\n\nmulti_head_attention(X, W_q, W_k, W_v, n_heads)\n### Output:\n[[9.9852, 18.0], [7.0, 14.0]]\n### Reasoning:\nMulti-head attention is computed for 2 heads using the input Q, K, and V matrices. The resulting outputs for each head are concatenated to form the final attention output.\n# Your code should start with:\n```python\nimport numpy as np\ndef multi_head_attention(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray, n_heads: int) -> list:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 95, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate the Phi Coefficient\n# Description:\nImplement a function to calculate the Phi coefficient, a measure of the correlation between two binary variables. The function should take two lists of integers (0s and 1s) as input and return the Phi coefficient rounded to 4 decimal places.\n# Examples:\n## Example 1:\n### Input:\nphi_corr(x = [1, 1, 0, 0], y = [0, 0, 1, 1])\n### Output:\n-1.0\n### Reasoning:\nThe Phi coefficient measures the correlation between two binary variables. In this example, the variables have a perfect negative correlation, resulting in a Phi coefficient of -1.0.\n# Your code should start with:\n```python\ndef phi_corr(x: list[int], y: list[int]) -> float:\n    \"\"\"\n    Calculate the Phi coefficient between two binary variables.\n\n    Args:\n    x (list[int]): A list of binary values (0 or 1).\n    y (list[int]): A list of binary values (0 or 1).\n\n    Returns:\n    float: The Phi coefficient rounded to 4 decimal places.\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 96, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Hard Sigmoid Activation Function\n# Description:\nImplement the Hard Sigmoid activation function, a computationally efficient approximation of the standard sigmoid function. Your function should take a single input value and return the corresponding output based on the Hard Sigmoid definition.\n# Examples:\n## Example 1:\n### Input:\nhard_sigmoid(x = 0.0)\n### Output:\n0.5\n### Reasoning:\nThe input 0.0 falls in the linear region of the Hard Sigmoid function. Using the formula $HardSigmoid(x) = 0.2x + 0.5$, the output is $0.2 \\times 0.0 + 0.5 = 0.5$.\n# Your code should start with:\n```python\ndef hard_sigmoid(x: float) -> float:\n    \"\"\"\n    Implements the Hard Sigmoid activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Hard Sigmoid of the input\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 97, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the ELU Activation Function\n# Description:\nImplement the ELU (Exponential Linear Unit) activation function, which helps mitigate the limitations of ReLU by providing negative outputs for negative inputs. The function should compute the ELU activation value for a given input.\n# Examples:\n## Example 1:\n### Input:\nelu(x = -1)\n### Output:\n-0.6321\n### Reasoning:\nFor x = -1 and alpha = 1.0, the ELU activation is computed as $\\alpha \\times (e^{x} - 1)$.\n# Your code should start with:\n```python\nimport math\ndef elu(x: float, alpha: float = 1.0) -> float:\n    \"\"\"\n    Compute the ELU activation function.\n\n    Args:\n        x (float): Input value\n        alpha (float): ELU parameter for negative values (default: 1.0)\n\n    Returns:\n        float: ELU activation value\n    \"\"\"\n```\n# Output Constraints:\nYour code should return a float rounded to the 4th decimal place.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 98, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the PReLU Activation Function\n# Description:\nImplement the PReLU (Parametric ReLU) activation function, a variant of the ReLU activation function that introduces a learnable parameter for negative inputs.\nCompute the PReLU activation value for a given input.\n# Examples:\n## Example 1:\n### Input:\nprelu(x = -2.0, alpha = 0.25)\n### Output:\n-0.5\n### Reasoning:\nFor x = -2.0 and alpha = 0.25, the PReLU activation is calculated as $ PReLU(x) = \\alpha x = 0.25 \\times -2.0 = -0.5$.\n# Your code should start with:\n```python\ndef prelu(x: float, alpha: float = 0.25) -> float:\n    \"\"\"\n    Implements the PReLU (Parametric ReLU) activation function.\n\n    Args:\n        x: Input value\n        alpha: Slope parameter for negative values (default: 0.25)\n\n    Returns:\n        float: PReLU activation value\n    \"\"\"\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 99, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Softplus Activation Function\n# Description:\nImplement the Softplus activation function, a smooth approximation of the ReLU function.\nCompute the Softplus value for a given input, handling edge cases to prevent numerical overflow or underflow.\n# Examples:\n## Example 1:\n### Input:\nsoftplus(x = 2)\n### Output:\n2.1269\n### Reasoning:\nFor x = 2, the Softplus activation is calculated as $\\log(1 + e^{x})$.\n# Your code should start with:\n```python\nimport math\ndef softplus(x: float) -> float:\n    \"\"\"\n    Compute the softplus activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The softplus value: log(1 + e^x)\n    \"\"\"\n```\n# Output Constraints:\nYour code should return a float rounded to the 4th decimal place.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 100, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Softsign Activation Function\n# Description:\nImplement the Softsign activation function, a smooth activation function used in neural networks.\nCompute the Softsign value for a given input, ensuring the output is bounded between -1 and 1.\n# Examples:\n## Example 1:\n### Input:\nsoftsign(x = 1)\n### Output:\n0.5\n### Reasoning:\nFor x = 1, the Softsign activation is calculated as $ \\frac{x}{1 + |x|}$.\n# Your code should start with:\n```python\ndef softsign(x: float) -> float:\n    \"\"\"\n    Implements the Softsign activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Softsign of the input\n    \"\"\"\n```\n# Output Constraints:\nYour code should return a float rounded to the 4th decimal place.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 101, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the GRPO Objective Function\n# Description:\nImplement the GRPO (Group Relative Policy Optimization) objective function used to optimize policy parameters in reinforcement learning. Your task is to compute the GRPO objective given the likelihood ratios, advantage estimates, old policy probabilities, reference policy probabilities, and apply the clipping mechanism and KL divergence penalty correctly to maintain training stability.\n# Examples:\n## Example 1:\n### Input:\n[1.2, 0.8, 1.1], [1.0, 1.0, 1.0], [0.9, 1.1, 1.0], [1.0, 0.5, 1.5], epsilon=0.2, beta=0.01\n### Output:\n1.032749\n### Reasoning:\nThe function calculates the GRPO objective by first clipping the likelihood ratios, computing the minimum terms, averaging them, and then subtracting the KL divergence penalty scaled by beta.\n# Your code should start with:\n```python\nimport numpy as np\ndef grpo_objective(rhos, A, pi_theta_old, pi_theta_ref, epsilon=0.2, beta=0.01) -> float:\n    \"\"\"\n    Compute the GRPO objective function.\n\n    Args:\n        rhos: List of likelihood ratios (p_i) = pi_theta(o_i | q) / pi_theta_old(o_i | q).\n        A: List of advantage estimates (A_i).\n        pi_theta_old: List representing the old policy probabilities pi_theta_old(o_i | q).\n        pi_theta_ref: List representing the reference policy probabilities pi_ref(o_i | q).\n        epsilon: Clipping parameter (eps).\n        beta: KL divergence penalty coefficient (beta).\n\n    Returns:\n        The computed GRPO objective value.\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 6th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 102, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Swish Activation Function\n# Description:\nImplement the Swish activation function, a self-gated activation function that has shown superior performance in deep neural networks compared to ReLU. Your task is to compute the Swish value for a given input.\n# Examples:\n## Example 1:\n### Input:\n1\n### Output:\n0.7311\n### Reasoning:\nFor $x=1$, the Swish activation is calculated as $\\mathit{Swish}(x)=x     imes \\sigma(x)$, where $\\sigma(x)=\frac{1}{1+e^{-x}}$. Substituting the value, $\\mathit{Swish}(1)=1     imes \frac{1}{1+e^{-1}}=0.7311$.\n# Your code should start with:\n```python\nimport math\nimport numpy as np\ndef swish(x: float) -> float:\n    \"\"\"\n    Implements the Swish activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The Swish activation value\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 103, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the SELU Activation Function\n# Description:\nImplement the SELU (Scaled Exponential Linear Unit) activation function, a self-normalizing variant of ELU. Your task is to compute the SELU value for a given input while ensuring numerical stability.\n# Examples:\n## Example 1:\n### Input:\n-1.0\n### Output:\n-1.1113\n### Reasoning:\nFor $x=-1.0$, the SELU activation is calculated using the formula $\\mathit{SELU}(x)=$ $\\lambda \u0007lpha\\left(e^x-1\night)$. Substituting the values of $\\lambda$ and $\u0007lpha$, we get $\\mathit{SELU}(-1.0)=$ $1.0507     imes 1.6733     imes\\left(e^{-1.0}-1\night)=-1.1113$.\n# Your code should start with:\n```python\nimport math\nimport numpy as np\ndef selu(x: float) -> float:\n    \"\"\"\n    Implements the SELU (Scaled Exponential Linear Unit) activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        SELU activation value\n    \"\"\"\n    alpha = 1.6732632423543772\n    scale = 1.0507009873554804\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 104, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Binary Classification with Logistic Regression\n# Description:\nImplement the prediction function for binary classification using Logistic Regression. Your task is to compute class probabilities using the sigmoid function and return binary predictions based on a threshold of 0.5.\n# Examples:\n## Example 1:\n### Input:\nnp.array([[1, 1], [2, 2], [-1, -1], [-2, -2]]), np.array([1, 1]), 0\n### Output:\n[1,1,0,0]\n### Reasoning:\nEach sample's linear combination is computed using $z=X w+b$. The sigmoid function is applied, and the output is thresholded at 0.5 , resulting in binary predictions.\n# Your code should start with:\n```python\nimport numpy as np\ndef predict_logistic(X: np.ndarray, weights: np.ndarray, bias: float) -> list:\n    \"\"\"\n    Implements binary classification prediction using Logistic Regression.\n\n    Args:\n        X: Input feature matrix (shape: N \u00c3\u0097 D)\n        weights: Model weights (shape: D)\n        bias: Model bias\n\n    Returns:\n        Binary predictions (0 or 1)\n    \"\"\"\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 105, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Train Softmax Regression with Gradient Descent\n# Description:\nImplement a gradient descent-based training algorithm for Softmax regression. Your task is to compute model parameters using Cross Entropy loss and return the optimized coefficients along with collected loss values over iterations.\n# Examples:\n## Example 1:\n### Input:\nnp.array([[0.5, -1.2], [-0.3, 1.1], [0.8, -0.6]]), np.array([0, 1, 2]), 0.01, 10\n### Output:\n([[-0.0011, 0.0145, -0.0921], [0.002, -0.0598, 0.1263], [-0.0009, 0.0453, -0.0342]], [3.2958, 3.2611, 3.2272, 3.1941, 3.1618, 3.1302, 3.0993, 3.0692, 3.0398, 3.011])\n### Reasoning:\nThe function iteratively updates the Softmax regression parameters using gradient descent and collects loss values over iterations.\n# Your code should start with:\n```python\nimport numpy as np\ndef train_softmaxreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for Softmax regression, optimizing parameters with Cross Entropy loss.\n\n    Returns:\n        B : list[float], CxM updated parameter vector rounded to 4 floating points\n        losses : list[float], collected values of a Cross Entropy rounded to 4 floating points\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 106, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Train Logistic Regression with Gradient Descent\n# Description:\nImplement a gradient descent-based training algorithm for logistic regression. Your task is to compute model parameters using Binary Cross Entropy loss and return the optimized coefficients along with collected loss values over iterations(round to the 4th decimal).\n# Examples:\n## Example 1:\n### Input:\nnp.array([[1.0, 0.5], [-0.5, -1.5], [2.0, 1.5], [-2.0, -1.0]]), np.array([1, 0, 1, 0]), 0.01, 20\n### Output:\n([0.0037, 0.0246, 0.0202], [2.7726, 2.7373, 2.7024, 2.6678, 2.6335, 2.5995, 2.5659, 2.5327, 2.4997, 2.4671, 2.4348, 2.4029, 2.3712, 2.3399, 2.3089, 2.2783, 2.2480, 2.2180, 2.1882, 2.1588])\n### Reasoning:\nThe function iteratively updates the logistic regression parameters using gradient descent and collects loss values over iterations.\n# Your code should start with:\n```python\nimport numpy as np\ndef train_logreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for logistic regression, optimizing parameters with Binary Cross Entropy loss.\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 107, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Masked Self-Attention\n# Description:\nImplement masked self-attention, a variation of the attention mechanism used in sequence modeling tasks such as text generation. Your task is to compute masked self-attention using query (Q), key (K), value (V) matrices and an attention mask.\n# Examples:\n## Example 1:\n### Input:\nQ, K, V, mask\n### Output:\n[[547. 490. 399. 495. 485. 439. 645. 393.]\n [547. 490. 399. 495. 485. 439. 645. 393.]\n [471. 472. 429. 538. 377. 450. 531. 362.]\n [471. 472. 429. 538. 377. 450. 531. 362.]\n [471. 472. 429. 538. 377. 450. 531. 362.]\n [471. 472. 429. 538. 377. 450. 531. 362.]]\n### Reasoning:\nThe function computes self-attention by applying a mask to restrict information flow, ensuring causal dependencies are maintained.\n# Your code should start with:\n```python\nimport numpy as np\n\ndef compute_qkv(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray):\n    \"\"\"\n    Compute Query (Q), Key (K), and Value (V) matrices.\n    \"\"\"\n    Q = np.dot(X, W_q)\n    K = np.dot(X, W_k)\n    V = np.dot(X, W_v)\n    return Q, K, V\ndef masked_attention(Q: np.ndarray, K: np.ndarray, V: np.ndarray, mask: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute masked self-attention.\n    \"\"\"\n```\n# Output Constraints:\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 108, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Measure Disorder in Apple Colors\n# Description:\nImplement a function that calculates the disorder in a basket of apples based on their colors, where each apple color is represented by an integer. The disorder must be 0 if all apples are the same color and must increase as the variety of colors increases. In particular:\n- [0,0,0,0] should yield 0.\n- [1,1,0,0] should have a higher disorder than [0,0,0,0].\n- [0,1,2,3] should have a higher disorder than [1,1,0,0].\n- [0,0,1,1,2,2,3,3] should have a higher disorder than [0,0,0,0,0,1,2,3].\nYou may use any method to measure disorder as long as these properties are satisfied.\n# Examples:\n## Example 1:\n### Input:\n[1,1,0,0]\n### Output:\n0.5\n### Reasoning:\nIn the basket [1,1,0,0], there are two distinct colors each appearing with equal frequency (0.5).\n# Your code should start with:\n```python\ndef disorder(apples: list) -> float:\n    \"\"\"\n    Calculates a measure of disorder in a basket of apples based on their colors.\n    \"\"\"\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 109, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Layer Normalization for Sequence Data\n# Description:\nImplement a function to perform Layer Normalization on an input tensor. Given a 3D array representing batch size, sequence length, and feature dimensions, normalize the data across the feature dimension for each sequence, then apply scaling and shifting parameters.\n# Examples:\n## Example 1:\n### Input:\nlayer_normalization(X = np.random.randn(2, 2, 3), gamma = np.ones(3).reshape(1, 1, -1), beta = np.zeros(3).reshape(1, 1, -1))\n### Output:\n[[[-0.12092, 1.2807, -1.15978], [-1.3847, 0.94123, 0.44347]], [[0.02428, -1.23669, 1.21241], [1.41034, -0.79475, -0.61559]]]\n### Reasoning:\nThe function computes the mean and variance across the feature dimension (d_model=3) for each sequence, normalizes the input, then applies gamma=1 and beta=0, resulting in a normalized output with zero mean and unit variance scaled as is.\n# Your code should start with:\n```python\nimport numpy as np\ndef layer_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5):\n```\n# Output Constraints:\nThe normalized X should be rounded to 5 decimal places and converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 110, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Evaluate Translation Quality with METEOR Score\n# Description:\nDevelop a function to compute the METEOR score for evaluating machine translation quality. Given a reference translation and a candidate translation, calculate the score based on unigram matches, precision, recall, F-mean, and a penalty for word order fragmentation.\n# Examples:\n## Example 1:\n### Input:\nmeteor_score(reference = 'Rain falls gently from the sky', candidate = 'Gentle rain drops from the sky')\n### Output:\n0.625\n### Reasoning:\nThe function identifies 4 unigram matches ('rain', 'gently'/'gentle', 'from', 'sky'), computes precision (4/6) and recall (4/5), calculates an F-mean, and then apply a small penalty for two chunks.\n# Your code should start with:\n```python\nimport numpy as np\nfrom collections import Counter\ndef meteor_score(reference, candidate, alpha=0.9, beta=3, gamma=0.5):\n```\n# Output Constraints:\nYour function should return a float value rounded to 3 decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 111, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Compute Pointwise Mutual Information\n# Description:\nImplement a function to compute the Pointwise Mutual Information (PMI) given the joint occurrence count of two events, their individual counts, and the total number of samples. PMI measures how much the actual joint occurrence of events differs from what we would expect by chance.\n# Examples:\n## Example 1:\n### Input:\ncompute_pmi(joint_counts = 50, total_counts_x = 200, total_counts_y = 300, total_samples = 1000)\n### Output:\n-0.263\n### Reasoning:\nThe PMI calculation compares the actual joint probability (50/1000 = 0.05) to the product of the individual probabilities (200/1000 * 300/1000 = 0.06). Thus, PMI = log\u2082(0.05 / (0.2 * 0.3)) \u2248 -0.263, indicating the events co-occur slightly less than expected by chance.\n# Your code should start with:\n```python\nimport numpy as np\ndef compute_pmi(joint_counts, total_counts_x, total_counts_y, total_samples):\n```\n# Output Constraints:\nYour function should return a float value rounded to 3 decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 112, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Min-Max Normalization of Feature Values\n# Description:\nImplement a function that performs Min-Max Normalization on a list of integers, scaling all values to the range [0, 1]. Min-Max normalization helps ensure that all features contribute equally to a model by scaling them to a common range.\n# Examples:\n## Example 1:\n### Input:\nmin_max(x = [1, 2, 3, 4, 5])\n### Output:\n[0.0, 0.25, 0.5, 0.75, 1.0]\n### Reasoning:\nThe minimum value is 1 and the maximum is 5. Each value is scaled using the formula (x - min) / (max - min).\n# Your code should start with:\n```python\ndef min_max(x: list[int]) -> list[float]:\n```\n# Output Constraints:\nYour function should return a list of floats rounded to 4 decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 113, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement a Simple Residual Block with Shortcut Connection\n# Description:\nImplement a function that creates a simple residual block using NumPy. The block should take a 1D input array, process it through two weight layers (using matrix multiplication), apply ReLU activations, and add the original input via a shortcut connection before a final ReLU activation.\n# Examples:\n## Example 1:\n### Input:\nresidual_block(x = np.array([1.0, 2.0]), w1 = np.array([[1.0, 0.0], [0.0, 1.0]]), w2 = np.array([[0.5, 0.0], [0.0, 0.5]]))\n### Output:\n[1.5, 3.0]\n### Reasoning:\nThe input x is [1.0, 2.0]. First, compute w1 @ x = [1.0, 2.0], apply ReLU to get [1.0, 2.0]. Then, compute w2 @ [1.0, 2.0] = [0.5, 1.0]. Add the shortcut x to get [0.5 + 1.0, 1.0 + 2.0] = [1.5, 3.0]. Final ReLU gives [1.5, 3.0].\n# Your code should start with:\n```python\nimport numpy as np\ndef residual_block(x: np.ndarray, w1: np.ndarray, w2: np.ndarray):\n```\n# Output Constraints:\nThe final output should be rounded to 4 decimal places and converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 114, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Global Average Pooling\n# Description:\nImplement a function that performs Global Average Pooling on a 3D NumPy array representing feature maps from a convolutional layer. The function should take an input of shape (height, width, channels) and return a 1D array of shape (channels,), where each element is the average of all values in the corresponding feature map.\n# Examples:\n## Example 1:\n### Input:\nglobal_avg_pool(x = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]))\n### Output:\n[5.5, 6.5, 7.5]\n### Reasoning:\nFor each channel, compute the average of all elements. For channel 0: (1+4+7+10)/4 = 5.5, for channel 1: (2+5+8+11)/4 = 6.5, for channel 2: (3+6+9+12)/4 = 7.5.\n# Your code should start with:\n```python\nimport numpy as np\ndef global_avg_pool(x: np.ndarray):\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 115, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Batch Normalization for BCHW Input\n# Description:\nImplement a function that performs Batch Normalization on a 4D NumPy array representing a batch of feature maps in the BCHW format (batch, channels, height, width). The function should normalize the input across the batch and spatial dimensions for each channel, then apply scale (gamma) and shift (beta) parameters. Use the provided epsilon value to ensure numerical stability.\n# Examples:\n## Example 1:\n### Input:\nbatch_normalization(X = np.array([[[[ 0.4967, -0.1383], [ 0.6477,  1.523 ]], [[-0.2342, -0.2341], [ 1.5792,  0.7674]]], [[[-0.4695,  0.5426], [-0.4634, -0.4657]], [[ 0.242 , -1.9133], [-1.7249, -0.5623]]]]), gamma = np.array([[[[1.]], [[1.]]]]), beta = np.array([[[[0.]], [[0.]]]]))\n### Output:\n[[[[0.4286, -0.5178], [0.6536, 1.9582]], [[0.0235, 0.0236], [1.6735, 0.9349]]], [[[-1.0114, 0.497], [-1.0023, -1.0058]], [[0.4568, -1.5043], [-1.3329, -0.275]]]]\n### Reasoning:\nThe input X is a 2x2x2x2 array. For each channel, compute the mean and variance across the batch (B), height (H), and width (W) dimensions. Normalize X using (X - mean) / sqrt(variance + epsilon), then scale by gamma and shift by beta. The output matches the expected normalized values.\n# Your code should start with:\n```python\nimport numpy as np\ndef batch_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5):\n```\n# Output Constraints:\nThe final output should be rounded to 4 decimal places and converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 116, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Derivative of a Polynomial\n# Description:\nImplement a function that computes the derivative of a polynomial term of the form `c * x^n` at a given point `x`, where `c` is a coefficient and `n` is the exponent. The function should return the value of the derivative, accounting for the coefficient in the power rule. This is useful for understanding how polynomials change at specific points in machine learning optimization problems.\n# Examples:\n## Example 1:\n### Input:\npoly_term_derivative(c = 2.0, x = 3.0, n = 2.0)\n### Output:\n12.0\n### Reasoning:\nFor the term 2 * x^2, the derivative is 2 * 2 * x^(2-1) = 4 * x. At x = 3, this evaluates to 4 * 3 = 12.0.\n# Your code should start with:\n```python\ndef poly_term_derivative(c: float, x: float, n: float) -> float:\n```\n# Output Constraints:\nYour function should return a float value rounded to 4 decimal places.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 117, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Compute Orthonormal Basis for 2D Vectors\n# Description:\nImplement a function that computes an orthonormal basis for the subspace spanned by a list of 2D vectors using the Gram-Schmidt process. The function should take a list of 2D vectors and a tolerance value (tol) to determine linear independence, returning a list of orthonormal vectors (unit length and orthogonal to each other) that span the same subspace. This is a fundamental concept in linear algebra with applications in machine learning, such as feature orthogonalization.\n# Examples:\n## Example 1:\n### Input:\northonormal_basis(vectors = [[1, 0], [1, 1]])\n### Output:\n[[1., 0.], [0., 1.]]\n### Reasoning:\nStart with [1, 0], normalize to [1, 0]. For [1, 1], subtract its projection onto [1, 0] (which is [1, 0]), leaving [0, 1]. Check if norm > 1e-10 (it is 1), then normalize to [0, 1]. The result is an orthonormal basis.\n# Your code should start with:\n```python\nimport numpy as np\ndef orthonormal_basis(vectors: list[list[float]], tol: float = 1e-10):\n```\n# Output Constraints:\nEvery basis within your return list should be rounded to 4 decimal places and converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 118, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Compute the Cross Product of Two 3D Vectors\n# Description:\nImplement a function to compute the cross product of two 3-dimensional vectors. The cross product of two vectors results in a third vector that is perpendicular to both and follows the right-hand rule. This concept is fundamental in physics, engineering, and 3D graphics.\n# Examples:\n## Example 1:\n### Input:\ncross_product(a = [1, 0, 0], b = [0, 1, 0])\n### Output:\n[0, 0, 1]\n### Reasoning:\nThe cross product of two orthogonal unit vectors [1, 0, 0] and [0, 1, 0] is [0, 0, 1], pointing in the positive z-direction as per the right-hand rule.\n# Your code should start with:\n```python\nimport numpy as np\ndef cross_product(a, b):\n```\n# Output Constraints:\nThe final output should be rounded to 4 decimal places and converted to a list using tolist() when returned.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 119, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Solve System of Linear Equations Using Cramer's Rule\n# Description:\nImplement a function to solve a system of linear equations $Ax = b$ using Cramer's Rule. The function should take a square coefficient matrix $A$ and a constant vector $b$, and return the solution vector $x$. If the system has no unique solution (i.e., the determinant of $A$ is zero), return -1.\n# Examples:\n## Example 1:\n### Input:\ncramers_rule(A = [[2, -1, 3], [4, 2, 1], [-6, 1, -2]], b = [5, 10, -3])\n### Output:\n[0.1667 3.3333 2.6667]\n### Reasoning:\nWe compute the determinant of A and then replace each column with vector b to compute the determinants of modified matrices. These are then used in the formula $x_i = \frac{\\det(A_i)}{\\det(A)}$ to get the solution.\n# Your code should start with:\n```python\nimport numpy as np\ndef cramers_rule(A, b):\n```\n# Output Constraints:\nMake sure all valid results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 120, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Bhattacharyya Distance Between Two Distributions\n# Description:\nImplement a function to calculate the Bhattacharyya distance between two probability distributions. The function should take two lists representing discrete probability distributions `p` and `q`, and return the Bhattacharyya distance rounded to 4 decimal places. If the inputs have different lengths or are empty, return 0.0.\n# Examples:\n## Example 1:\n### Input:\nbhattacharyya_distance(p = [0.1, 0.2, 0.3, 0.4], q = [0.4, 0.3, 0.2, 0.1])\n### Output:\n0.1166\n### Reasoning:\nThe Bhattacharyya coefficient is calculated as the sum of element-wise square roots of the product of p and q, giving BC = 0.8898. The distance is then -log(0.8898) = 0.1166.\n# Your code should start with:\n```python\nimport numpy as np\ndef bhattacharyya_distance(p: list[float], q: list[float]) -> float:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 121, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Vector Element-wise Sum\n# Description:\nWrite a Python function that computes the element-wise sum of two vectors. The function should return a new vector representing the resulting sum if the operation is valid, or -1 if the vectors have incompatible dimensions. Two vectors (lists) can be summed element-wise only if they are of the same length.\n# Examples:\n## Example 1:\n### Input:\nvector_sum(a = [1, 3], b = [4, 5])\n### Output:\n[5, 8]\n### Reasoning:\nElement-wise sum: [1+4, 3+5] = [5, 8].\n# Your code should start with:\n```python\ndef vector_sum(a: list[int|float], b: list[int|float]) -> list[int|float]:\n```\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 122, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Policy Gradient with REINFORCE\n# Description:\nImplement the policy gradient estimator using the REINFORCE algorithm. The policy is parameterized by a 2D NumPy array `theta` of shape `(num_states, num_actions)`. The policy for each state is computed via softmax over `theta[s, :]`. Given a list of episodes (each a list of (state, action, reward) tuples), compute the average gradient of the log-policy multiplied by the return at each time step.\n# Examples:\n## Example 1:\n### Input:\ncompute_policy_gradient(theta = np.zeros((2,2)), episodes = [[(0,1,0), (1,0,1)], [(0,0,0)]])\n### Output:\n[[-0.25, 0.25], [0.25, -0.25]]\n### Reasoning:\nEpisode 1 contributes a positive gradient from reward 1 at t=1; episode 2 adds zero. Result is averaged across episodes.\n# Your code should start with:\n```python\nimport numpy as np\ndef compute_policy_gradient(theta: np.ndarray, episodes: list[list[tuple[int, int, float]]]):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 123, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Calculate Computational Efficiency of MoE\n# Description:\nCalculate the computational cost savings of an MoE layer compared to a dense layer, as discussed in the paper 'Outrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer.' Given the number of experts, sparsity (number of active experts), and input/output dimensions, compute the floating-point operations (FLOPs) for both and determine the savings percentage.\n# Examples:\n## Example 1:\n### Input:\ncompute_efficiency(n_experts = 1000, k_active = 2, d_in = 512, d_out = 512)\n### Output:\n99.8\n### Reasoning:\nDense layer FLOPs: 1000 * 512 * 512 = 262,144,000. MoE FLOPs: 2 * 512 * 512 = 524,288. Savings: ((262,144,000 - 524,288) / 262,144,000) x 100 \u2248 99.8%.\n# Your code should start with:\n```python\ndef compute_efficiency(n_experts, k_active, d_in, d_out):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 1th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 124, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement the Noisy Top-K Gating Function\n# Description:\nImplement the Noisy Top-K gating mechanism used in Mixture-of-Experts (MoE) models. Given an input matrix, weight matrices, pre-sampled noise, and a sparsity constraint k, compute the final gating probabilities matrix.\n# Examples:\n## Example 1:\n### Input:\nnoisy_topk_gating(X = np.array([[1.0, 2.0]]), W_g = np.array([[1.0, 0.0], [0.0, 1.0]]), W_noise = np.array([[0.5, 0.5], [0.5, 0.5]]), N = np.array([[1.0, -1.0]]), k = 2)\n### Output:\n[[0.917, 0.0825]]\n### Reasoning:\nThis example demonstrates that the gating function produces a sparse softmax output, favoring the higher gate after noise perturbation.\n# Your code should start with:\n```python\nimport numpy as np\ndef noisy_topk_gating(\n    X: np.ndarray,\n    W_g: np.ndarray,\n    W_noise: np.ndarray,\n    N: np.ndarray,\n    k: int\n):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 125, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement a Sparse Mixture of Experts Layer\n# Description:\nImplement a Mixture-of-Experts (MoE) layer using softmax gating and top-k routing. Given an input tensor, a set of expert weight matrices, a gating weight matrix, and parameters specifying the number of experts and the value of k, compute the final MoE output by selecting the top-k experts per token, applying their transformations, and aggregating the results weighted by the normalized gating probabilities.\n# Examples:\n## Example 1:\n### Input:\nmoe(x = np.arange(12).reshape(2, 3, 2), We = np.ones((4, 2, 2)), Wg = np.ones((2, 4)), n_experts = 4, top_k = 1)\n### Output:\n[[[1, 1], [5, 5], [9, 9]], [[13, 13], [17, 17], [21, 21]]]\n### Reasoning:\nEach token is routed to its top expert and processed using a weight matrix of ones. The result matches the input tokens due to identity transformation and weight 1.\n# Your code should start with:\n```python\nimport numpy as np\ndef moe(x: np.ndarray, We: np.ndarray, Wg: np.ndarray, n_experts: int, top_k: int):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 126, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Implement Group Normalization\n# Description:\nWrite a Python function to perform Group Normalization on a 4D input tensor with shape (B, C, H, W). The function should normalize over smaller groups of channels, then apply a learned scale (gamma) and shift (beta).\n# Examples:\n## Example 1:\n### Input:\ngroup_normalization(X = np.array([[[[0, 1], [2, 3]], [[4, 5], [ 6, 7]]], [[[ 8, 9], [10, 11]], [[12, 13], [14, 15]]]]), gamma = np.array([1, 1]), beta = np.array([0, 0]), num_groups = 2)\n### Output:\n[[[[-1.3416, -0.4472], [0.4472, 1.3416]], [[-1.3416, -0.4472], [0.4472, 1.3416]]], [[[-1.3416, -0.4472], [0.4472, 1.3416]], [[-1.3416, -0.4472], [0.4472, 1.3416]]]]\n### Reasoning:\nFirst split the channels into groups, compute mean and variance per group, normalize within the group, then scale and shift with gamma and beta.\n# Your code should start with:\n```python\nimport numpy as np\ndef group_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, num_groups: int, epsilon: float = 1e-5):\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 127, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Find Captain Redbeard's Hidden Treasure\n# Description:\nCaptain Redbeard, the most daring pirate of the seven seas, has uncovered a mysterious ancient map.\nInstead of islands, it shows a strange wavy curve, and the treasure lies at the lowest point of the land! (watch out for those tricky local mins)\nThe land's height at any point $x$ is given by: $ f(x) = x^4 - 3x^3 + 2$.\nYour Mission: Implement a Python function that finds the value of $x$ where $f(x)$ reaches its minimum, starting from any random initial position.\n# Examples:\n## Example 1:\n### Input:\nfind_treasure(start_x = 2.0)\n### Output:\n2.1475\n### Reasoning:\nCant really give you a example without giving the solution... so ya\n# Your code should start with:\n```python\nimport numpy as np\ndef find_treasure(start_x: float, learning_rate: float = 0.1, tolerance: float = 1e-6, max_iters: int = 10000) -> float:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
{"task_id": 128, "prompt": "You are an expert Python programmer, and here is your task:\n# Task: Dynamic Tanh: Normalization-Free Transformer Activation\n# Description:\nImplement the Dynamic Tanh (DyT) function, a normalization-free transformation inspired by the Tanh function. DyT replaces layer normalization in Transformer architectures while preserving squashing behavior and enabling stable training.\n# Examples:\n## Example 1:\n### Input:\ndynamic_tanh(x = np.array([[[0.14115588, 0.00372817, 0.24126647, 0.22183601]]]), alpha = 0.5, gamma = np.ones((4,)), beta = np.zeros((4,)))\n### Output:\n[[[0.0705, 0.0019, 0.1201, 0.1105]]]\n### Reasoning:\nEach element in the input is scaled by alpha, passed through tanh, and then scaled by gamma and shifted by beta. This mimics the squashing behavior of layer normalization without explicitly using statistics.\n# Your code should start with:\n```python\nimport numpy as np\ndef dynamic_tanh(x: np.ndarray, alpha: float, gamma: float, beta: float) -> list[float]:\n```\n# Output Constraints:\nMake sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.\n\nPlease follow the examples and provide a self-contained Python script that solves the above task in a markdown code block.\n"}
